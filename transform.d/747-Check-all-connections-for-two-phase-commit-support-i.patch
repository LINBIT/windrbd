From 412d3643ad6325a49dfda5ac6f959d3a45d29d29 Mon Sep 17 00:00:00 2001
From: Johannes Thoma <johannes@johannesthoma.com>
Date: Thu, 25 Aug 2022 16:47:14 +0200
Subject: [PATCH 2/2] Check all connections for two phase commit support in
 do_change_disk_state()

Before this commit only the first connection was checked for supporting
two phase commit (protocol level 110 or higher). In some cornercases
when there were many detach/attach and connect/disconnect load happening
this could lead to a wrong (=false) return value of do_change_disk_state().
More precisely if the connection checked was up but no protocol level
was negotiated yet (agreed protocol level being min_level, usually 86)
a wrong cluster_wide_state_change supported flag was computed.

This lead to a situation where a local disk was attached without
notifying all the peers via a two phase commit cycle.
The peer, in turn, did not update the original node's peer
disk state (still in D_DISKLESS instead of D_NEGOTIATING)
and didn't send its state back which lead the
original node thinking (wrongly) that the replation state of
the peer is L_NEGOTIATING (it was set to off earlier in
finish_state_change() when this disk transisted locally from
not D_NEGOTIATING to D_NEGOTIATING). As a consequence, the
original node thought that negotiation hasn't finished and
the node's disk state was stuck in Negotiating forever.

Note that this issue only arised when there were more than
two diskful nodes.

This commit searches all connection for (at least) one
connection that supports two phase commit. It fixes the
Negotiating stuckness we observed when experimenting with
WinDRBD and LINSTOR for Windows (which - wrongly - does
detach / attach on every drbdadm adjust, this will be fixed
in an extra commit).

Signed-off-by: Johannes Thoma <johannes@johannesthoma.com>
---
 drbd/drbd_state.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/drbd/drbd_state.c b/drbd/drbd_state.c
index 205a562..4683f82 100644
--- a/drbd/drbd_state.c
+++ b/drbd/drbd_state.c
@@ -5117,11 +5117,14 @@ static bool device_has_connected_peer_devices(struct drbd_device *device)
 	return false;
 }
 
-static bool device_has_peer_devices_with_disk(struct drbd_device *device)
+static bool device_has_peer_devices_with_disk(struct drbd_device *device, bool *supports_twopc)
 {
 	struct drbd_peer_device *peer_device;
 	bool rv = false;
 
+	if (supports_twopc)
+		*supports_twopc = false;
+
 	for_each_peer_device(peer_device, device) {
 		if (peer_device->connection->cstate[NOW] == C_CONNECTED) {
 			/* We expect to receive up-to-date UUIDs soon.
@@ -5132,6 +5135,10 @@ static bool device_has_peer_devices_with_disk(struct drbd_device *device)
 			    peer_device->disk_state[NOW] != D_UNKNOWN)
 				rv = true;
 		}
+
+		if (supports_twopc &&
+                    peer_device->connection->agreed_pro_version >= 110)
+			*supports_twopc = true;
 	}
 
 	return rv;
@@ -5203,14 +5210,12 @@ static bool do_change_disk_state(struct change_context *context, enum change_pha
 	struct drbd_device *device =
 		container_of(context, struct change_disk_state_context, context)->device;
 	bool cluster_wide_state_change = false;
+	bool supports_twopc;
 
 	if (device->disk_state[NOW] == D_ATTACHING &&
 	    context->val.disk == D_NEGOTIATING) {
-		if (device_has_peer_devices_with_disk(device)) {
-			struct drbd_connection *connection =
-				first_connection(device->resource);
-			cluster_wide_state_change =
-				connection && connection->agreed_pro_version >= 110;
+		if (device_has_peer_devices_with_disk(device, &supports_twopc)) {
+			cluster_wide_state_change = supports_twopc;
 		} else {
 			/* very last part of attach */
 			context->val.disk = disk_state_from_md(device);
-- 
2.17.0

