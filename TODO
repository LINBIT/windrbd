TODO: Check in install script if it runs as adminstrator.

	I just ran into that ... it fails silently.

TODO: Do not display Please reboot .. when installation is finished.

	INF install already does this.

TODO: SendPage on sync always sends the same page.
	Probably there is data corruption.

TODO: patch_boot_sector: DRBD signature on peer.
	Should only be on backing device, never on the wire.

Report: Both sides are SyncSource??
w0 role:Secondary
  volume:17 disk:UpToDate
  linbit-wdrbd role:Secondary
    volume:17 replication:SyncSource peer-disk:Inconsistent
        done:0.00

	It seems that DRBD 9.0.13 fails to detect split brain
	correctly (downgrading WinDRBD to DRBD 9.0.10 detects
	the split brain). That seems to be an upstream problem.
	Report?

Same on other side.

TODO: BSOD on network failure
	Check if still there.

TODO: On network failure (unplug cable) stays in NetworkFailure state.

TODO: drbdadm status fails after unplug cable when syncing.

TODO: Error reporting of SendPage()

TODO: Clean up wsk2.c
	Remove unneccessary code.

TODO: On much VM, one CPU core (has 2 cores) goes to 100% on sync.
	I assume there is an unneccessary (?) copy somewhere.

TODO: bio_set_op_attrs <2>[0xFFFFFA80033783B0] BUG: failure

	Maybe this was introduced during code cleanup. Update: no it wasn't.
	The reason is that REQ_OP_FLUSH != REQ_OP_WRITE in windrbd,
	which has to be fixed (they also should be powers of two,
	see comment in win4lin/drbd_wrappers.h:544.

	The bug appears on testing resync.

TODO: test-loop hangs after about 16 iterations.

	format k: sometimes gets stuck when run from test script.

TODO: Device FFFFFA8004F2D4C0 accessed after it was deleted.
	Strange.

TODO: invalidate read cache when becoming secondary.

	Problem is that if windows is primary, becomes secondary and
	then primary again the read cache is still filled from the
	former primary.

	Should invalidate when becoming secondary: reason is
	that while secondary requests still are served from
	the read cache (they should fail).

	Update: Moving that to beta2 because we are a little bit
	short on time. Document that defect.

TODO: Re-check the WIN32 / WIN64 thing in drbd_endian.h

TODO: blue screen on drbdadm detach --force (when needing uptodate
	data) and then drbdadm status.

	Cannot reproduce at the moment.

TODO: logging: printk's without terminating \n not displayed.

	Also: if there are some special characters (\0?) the
	line is not displayed.

	Update: Please fix this, it is annoying, I just ran into
	it.

TODO: mountmanager / register device with PNP

	Drive letter (mount point) is created now.

	Right now, need to log in / log out to make windrbd drive
	visible in explorer.

	Need to have a valid DeviceNode (that is attach it somewhere
	in the PNP device tree). It does not work to attach it to
	the backing device (backing device then becomes invalid and
	BSODs)

	This seems to be a little bit more complicated than expected..
	maybe attaching the windrbd device to the root device object
	helps? (But root device object also does not have a device
	node). Update: fails with PNP BSOD.

	See Microsoft driver samples for how to do this.

TODO: Auto-promote seems not to work as expected.

	dir h: should make device primary if possible and then
	not fail.

	Strange, but neither with read/write nor with read only we get
	a create request on the windrbd device. (tested with windrbd-test)

TODO: logging to localhost (windows) seems to cause boot problems (?)
	When using 192.168.56.101 instead of 127.0.0.1

TODO: windrbd show-filesystem should check if device is used as
	a backing device.

TODO: Create file with version number

TODO: On formatting: error message cannot write NTFS boot sector.

TODO: drbd-util: Update manpage.
	And write one for windrbd utility.

TODO: Redo installation of sshd on Windows VM
--------------------------------------------------------------------
TODO: Why doesn't it work on Phil's machine?

TODO: msi installer instead of self extracting exe.

--------------------------------------------------------------------
TODO: remove all tags from alloc() routines
	and revert patches.

TODO: Mount to NTFS directories.

Maybe: remove drive letter from volume on attach.
	And not reassign it on detach: Users shouldn't modify
	data on a backing device even when the device is down,
	unless they really want it.

	Print a howto showing:
		how to change from drive letter to GUID in drbd.conf
		how to recover the drive letter later (in case
			DRBD is never needed again, or if it was
			the wrong drive letter).

TODO: fix the case where backing device contains a file system.
	It should not blue screen.
	(maybe later, this seems to be rather complex)
	We are now avoiding the case when there is a filesystem
	on an attached backing device. This blue screen should
	be fixed but maybe in a later release.

TODO: flush not supported by some (all?) devices: currently we
	ignore this (as reactOS also does it). Update: ext2
	file system uses CcFlushCache(): see
	reactos/reactos/drivers/filesystems/ext2/src/flush.c

	Also try to use the ZwFlushXXX function (as Mantech does it)

TODO: Windows 10 would require more testing.

	Blue screen THREAD_EXCEPTION_NOT_HANDLED when writing data
	while connected (on a NTFS filesystem). Maybe because of
	extensive logging. Update: happened again last log message
	is:
Feb 20 19:04:48 10.43.8.215  U18:04:48.392|51a96700 windrbd_thread_setup <6>[0xFFFFD40351A96700] stopped.

	maybe the rcu?

	Accessing directory (reading) from windrbd device stalls
	when connected (and syncing). Writing data works (but
	that is maybe just in the cache).

	Syncing is very slow at the moment.
	This is most likely a network issue (non-windrbd issue)

TODO: when installing a signed DRBD driver, installing an unsigned
	DRBD driver fails silently.

	It is unclear how this really works. When installing a
	signed driver it seems to be not possible any more to
	install an unsigned driver over it. Test signed drivers
	is separate virtual machines.

TODO: New blue screen on connecting Windows 10 to buildhost Windows 7
	(I think it was D1).

	This might be because of wrong rcu handling (must sleep
	before cleaning up)

--------------------------------------------------------------
windrbd-next-next

In progress: Later: RCU needs change
	At least call_rcu now calls the function. I don't think
	that it is a good idea to port the linked list thing to
	windows, we want to stay thin..

	Update: talk to phil about current solution (just call
	the function). I don't think that it is a good idea to
	mimic the original intended behaviour in Windows.

	Update: We now call the cleanup / on update function 
	in the call_rcu() function, which makes the thing work.
	Double check if that works as expected.
TODO: /cygdrive/c/windrbd/var/lib/drbd should exist.

In progress: how and when is flush to backing device done?
	This is important. Right now NTFS files only appear on
	Linux when sync is done manually. Should sync at least
	when becoming secondary. sync must be done while primary
	(when secondary it would fail)

TODO: on windrbd show/hide filesystem check if attached.

	And refuse to touch it if yes.

TODO: mandatory locking for backing device.

TODO: One day we want to not blue screen when backing device contains a file system.

TODO: Kernel really should report an error if Bind() fails. 
	For example if the local IP address does not exist.


TODO: check if windrbd can be loaded not at boot time but later.

	Working on it .. test with demand load on a fresh installed
	windows (it blue screens on boot if there was a windrbd before
	installed).

TODO: upgrade DRBD to 9.0.12

	So Need Access to up to date data on drbdadm down is fixed.

TODO: review TODOs in source code.

TODO: Create windrbd device on becoming primary and delete
	windrbd device on secondary.

	Update: drbd_create_device needs to assign a valid
	this_bdev. Do not create Windows device in bdget, 
	instead create it on becoming primary and delete
	it (with checking for open references) in becoming
	secondary. This way we do not support auto promote
	(because the block device cannot be opened) but
	that is not so important.

	Update: Phil wants the auto promote feature (for
	virtualization), so alternative would be to
	patch the boot sector as long it is secondary. 
	However this does not solve the read cache problem.

	Update: Right now, we return IO error if a secondary
	resource is accessed via ReadFile/WriteFile. Eventually
	we want to declare the secondary resource offline
	but not sure yet how to do this.

	Rethink this and do that later.

TODO: Someday we want to pass user level buffer to driver directly
	on READ requests instead of having a temp buffer (needed
	for Windows 10).

TODO: blue screen when backing device fails.

TODO: Cannot write first sector on format h:
	Sector seems to be alright (showing DRBD on the backing device
	and NTFS on the windrbd device). Not sure where this is coming
	from.

TODO: spurious error 5 (ACCESS_DENIED) when reading DRBD device.
	after doing some experiments. drbdadm down / up solved the
	problem.

TODO: Fix windows shutdown bug.

	Most likely this was introduced when implementing the
	cleanup() method.

	Update: Not observed lately.
	Update: just reappeared again.

TODO: support I/O vectors in windrbd device (irp_to_bio)
	and clean up code (see TODOs in source code)

	Also have a test that does WriteFileGather and ReadFileScatter.

TODO: Integrate (manually rebase) windrbd branch of drbd-utils to its master

TODO: Also allow for mounting windrbd device to NTFS folder

In Progress: Port agruen's test suite to cygwin.
	exxe is running. Ask phil about how to install it.
	Depends on chmod working (else cannot install
	opensshd).

	Update: chmod works now.

TODO: Re-port drbd_transport_tcp.c to windrbd's
	drbd_transport_wtcp.c.
	Update: currently it seems that the problem is
	somewhere else. 
	However we need those updates. Best way would be to
	git diff the original drbd transport_tcp to the version
	we had before and apply the patches manually.

	Update: we should integrate drbd_transport_tcp back to
	converted-sources.

TODO: test no I/O when disk is failed.

--------------------------------------------------------------

TODO: Test other file systems (FAT, FAT32, ...)
	FAT does not work (Invalid function when accessing DRBD device)
	FAT32 also not (something with flushing?)
	Probably there is one important IOCTL missing.

TODO: Review patches if they are still needed.
	Especially kmalloc(,, Tag) which is not neccessary.

TODO: kzalloc should call kmalloc not the other way around.

TODO: Do not have a root device.
	It is useless.

TODO: when losing Quorum go into read only mode.
	(quorum means that our connected network contains > n/2 
	(n .. total number of names) valid nodes.
	This is currently being implemented in DRBD

TODO: Device FFFFFA80038B03F0 accessed after it was deleted.
	After formatting and drbdadm down

TODO: check what _WIN32_DEBUG_OOS is really doing.
	Dumping bitmap?

TODO: have dump_stack function

TODO: I/O seems to be rather slow even when being unconnected (and primary)

TODO: make ssh to Windows box work

TODO: Inform windows about new drive.
	So that explorer opens.

TODO: on patching boot sector, inform Windows that file system is
	raw now.
	So that it disappears.

TODO: read error: Volume dismounted
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 DrbdIoCompletion <4>[0xFFFFFA800131B040] DrbdIoCompletion: I/O failed with error c000026e
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 drbd_report_io_error <4>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x208): local READ IO error sector 0+1 on

TODO: Understand what windows means by mounting / dismounting.

TODO: check out drbd-utils from github and see if that works.
	(once it is pushed)
----------------------------------------------------------------------

TODO: check out mantech wdrbd and see if it works (and why)
	Update: mantech WDRBD lacks many features we have
	in windrbd most notably: it cannot connect to a
	Linux DRBD. It does not support internal meta disk.

TODO: How is sync done? 
	Data appears delayed on backing device (about 10 - 20 
	seconds later).

TODO: lots of more tests (corner cases like reading near the
	end of the device)

TODO: have windrbd-test execute drbdadm as needed.
	This is a nice to have.

TODO: test if loading drbd driver later (not at boot) works.

-----------------------------------------------------------------------

TODO: Nice to have: Cygwin should have /dev/drbd<n> mapped to
	\\Device\\Drbd<n>

TODO: have a make depend target
	Or at least header file dependencies.

TODO: Check if it is a network share (currently blue screens)
	Update: blue screen was something else. Should check if the
	drive letter is a network share. Unfortunately they do not
	appear in the \DosDevices directory. If we create a drive
	letter (symbolic link) in the \DosDevices it will be silently
	ignored. Warn the user if it is a network share.

TODO: One day we want to have a more specific error message
	than Device does not have a disk config if the device or
	the drive letter already exist.

---------------

TODO: We should really lock the backing devices using NT kernel
	mechanisms.

	Maybe use the mechanically locked IOCTL? Then one would
	have to drbdadm down <res> --force

TODO: Implement function stubs created when integrating DRBD 9.0.9

TODO: Have a function that initialized all (global) spinlocks
	and replace the racy solution (with an flag indicating
	wheter it is initialized) we have now.

TODO: cond_wait shouldn't busy loop. How is this done in Linux.

TODO: #ifdef the Windows netlink code in drbd-utils

TODO: Make drbd service stoppable
	This probably takes some while
	Update: with the new architecture that should be possible
	one day.

TODO: fix the macro redefinition problems in drbd_windows.c
	For now we have to copy the function prototypes from MSDN.
	Not good style.

	Update: check if the prototypes are still needed.
	Update: we probably reject this.

--------------------------------

Done: fix patch errors on Linux side build (conversion)
	a make clean did solve it

Done: backup on www.johannesthoma.com

Rejected: install Windows kernel headers
	Is part of EWDK.

Rejected: Download heise Linux Virus scanner CD and check image.
	I tried Desinfec't 2014 but it hangs. Now have Avira 
	inside the Windows machine.

	TO DO: This should start automatically at boot

Rejected: Maybe migrate vdi image to internal SSD

Done: Reboot Mac and see if it is still slow
	Done: Something in the VM config was slow, created a new one

Rejected: Install FreeSshD
	
Done: Install cygwin
	Done, works
	Also installed Dev (GNU toolchain)

Done: Install Visual Studio
	C headers are missing, TO DO: Uninstall and redo installation
	from scratch.	
	Done, works now

Rejected: Reorganize converted sources (have drbd and drbd-headers inside
	a dummy dir, to make it compatible to original layout.

Done: Make it compile under Windows
	Done: Fixed permission errors
	Done: Must work with /cygdrive/z/... mapping (cmd.exe does not
		support UNC names)

	Done: path to cl.exe
	Done: install EWDK (plus prerequisites like device driver
		kit)

	Done: make signing the driver work.
	Done: Make clean and remake to see if it still works.

	Must:
	1.) Run 
		make 
	on the Linux box (from $HOME/Linbit/Work/wdrbd9)

	2.) Run
		make
	on the Windows box (from $HOME/Linbit/Work/wdrbd9 (takes some while)

	3.) Run
		make install
	on the Windows box (from $HOME/Linbit/Work/wdrbd9/converted-sources/drbd)

	4.) Run (in an Administrator cmd.exe Console: to open it go to
		 C:\Windows\System32 in Explorer, Cmd-Click on cmd.exe
		 and select Run as Administrator)
		INSTALL-DRBD-admin.bat

	5.) To load the driver, do (from Adminstrator Console)
		sc start drbd
	DbgViewer will show output. To start DbgViewer go to 
	C:\drbd\DebugViewer and start DbgView.exe as Administrator

Done: Revert to original build layout
	Done: Backported work done in converted sources
	Rejected: Cross compiling coccinelle for Linux (requires ocaml)
		Does not work, Ubuntu OCaml parmap library installation
		seems to be broken.
	Done: see if there is a cygwin package for coccinelle
		No
	Rejected: install ocaml for CygWin
	Rejected: Cross compile conccinelle for CygWin
		If possible, do not try to fix too many things.
	Rejected: make should build everything under Windows

Done: make install should install the driver and activate it
	(Rethink: only install the service User should do 
	sc start drbd manually, since that could crash the
	machine rightaway)

Done: make install should also be possible in top make file

Rejected: Migrate sources to Windows C: drive and build from there
	Maybe then it is faster..but then we need to make tarball and
	the like .. Hmmm.

	Rejected because Windows crashes randomly. It is also better
	to have sources on Linux since step 1 of the build has to be
	executed under Linux.

Rejected: Remove everything with signing (signtool exits with an error)
	We leave it in, even though it does not work. Must start Windows
	with Load unsigned drivers (Press F8 at boot and select bottom
	most entry (Load unsigned drivers))

Done: Insmod
	Rejected: pnputil -a drbd.inf
	Done: currently fails with Permission denied.
		Must run cmd.exe as administrator (Cmd-Click on
		cmd.exe in /Windows/System32)
	Done: try if F8 + load unsigned drivers works.
		Yes it does.

Done: Install DRBD Linux peer VM
	Ubuntu Server? Took Ubuntu 16.04 Gnome edition
	Installed drbd from git repo
	Update: we are using the production VM since not enough
	RAM for running 3 VMs.

Done: Add volume to Windows VM for DRBD test drive.

Done: logging: syslog server (see how it is done)
	Currently checking DebugViewer (but doesn't survive blue screen)

Done: Run DRBD with provided config file
	One Windows one Linux peer, with added Volume as backing
	storage.
	However there are many issues, see KNOWN-BUGS

Done: send public key to upstream

Done: Add build instructions to repo

Done: revert (make invisible) last 3 patches from upstream

Done: git pull last commit

Done: rebase dev branch to upstream master

Done: Merge into 

Done: drbd-adm: For now, have two different entries (NT-style, UNIX style)
	have win-disk and win-meta-disk in addition to UNIX style
	disk device paths. 

Done: Reconfigure drbd-utils with sane paths (/usr/local/etc ->
	/etc) 
	Problem is that drbdadm fails because some path does not
	exist.

Done: fix the syslog printk code to print all messages
	At least partially .. print all messages to the local
	Debugging facility (use DbgView.exe to see them), when
	IRQL is higher than DISPATCH we must not sleep and cannot
	send UDP packets. 

Done: Why does DRBD crash when loaded at boot time?
	Because signature is invalid. Boot windows with 
	F8+Allow invalid signatures.

Rejected: kernel: keep track of opened HANDLEs and struct drbd_block_devices
		(but please not in VOLUME_EXTENSIONs they don't belong there)
Rejected: kernel: Use that handle for I/O on backing device
	This is probably too slow. Keep the current device stack
	approach.

Done: kernel: win4lin: see if symlinks work
	We need to resolve them (ZwQuerySymbolicLinkObject), Done

Done: drbdsetup should translate NT-style pathes to NT kernel internal
	style pathes (this is easy)

Done: drbdmeta should accept NT-style pathes
	Problem is that /dev/sda and /dev/sdb is sometimes
	swapped (see KNOWN-BUGS) 

Done: We need to use NT-style I/O functions for drbdmeta
	(ReadFile, WriteFile) in pread/write_or_die()
	and use NtOpenFile() (need to load address
	from NTDLL.DLL).

Done: Open backing device:
	Need to reboot Windows to make it work. Right now I don't see any
	possibilty to attach to the device stack without rebooting
	(maybe pnp manager can be told to reiterate disk devices somehow..)

Done: For some disk sizes, NtReadFile fails with EOF reached
	(0xc0000011)
	Root kit?
	Update: No, seems to be a NTFS kind of hack. With cygwin it
	works. Our version fails on NTFS partitions (which don't contain
	DRBD meta data anyway), so we can work around it.

	We just print a warning and terminate now.

Rejected: Have NTDLL functions in separate file?
	Without knowing struct format internals.
	We are using WIN32 API which is not that wild.

Done: D: -> \\DosDevices\\D: also in drbdmeta
	Done

Done: check if drbd-utils compiles on Linux.
	No it doesn't. Netlink port was unclean (doesn't #ifdef __CYGWIN__)
	takes some time to repair.

Done: Revert the win-disk patch later to use only 
	NT style disk device paths (win-disk becomes disk, UNIX
	disk device paths are not used any more).

	We need to patch drbdmeta for that.
	Update: Patch is there, need to revert and test.
	Reverted and tested.

Done: printk_syslog(): collect the messages in a ring buffer and send them 
	later.
	Nice-to-have, do that later.
	Done it, it is good to have it for further work.

Done: Locking for ring buffer

Done: IRQ message should go before current message.

Done: printk_syslog(): merge logging functions of
	jt/logging-fixed-and-windows-boots-with-signature-check-disabled
	into master and push

Done: IP address of logging host should be configurable (Registry?)

Rejected: fix driver signature
	Don't know how this works..we now use Windows Test Mode to 
	avoid pressing F8 all the time.

Done: integrate INSTALL-DRBD-admin.bat in Makefile.win

Done: Merge changes to master (including drbd_thread_setup non-static)
	and push.

Done: Frees in Completion routine: is the memory freed by lower level
	driver?
	No it is Paged and accessed in an IRQ routine.
	Update: Now returning MORE_PROCESSING_REQUIRED and the
	blue screen disappeared.
	See https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/constraints-on-completion-routines :
		"After calling IoFreeIrp, the completion routine must return STATUS_MORE_PROCESSING_REQUIRED to indicate that no further completion processing is needed."

Done: fix 0x4e blue screen on drbdadm detach / down
	Last message: 
drbd_bm_resize <6>drbd w0/17 minor 26, ds(Diskless), dvflag(0x2000): drbd_bm_resize called with capacity == 0
	
Done: Make it work with DRBD from September

Done: Do we really need all those IOCTLs?
	drbdcon does not exist in WinDRBD, new ioctls are not 
	needed.

Done: use gtest to write tests.
	Probably for some tests where we need to call Windows API functions.
	Maybe we can extent agruen's test suite to call mini binaries.

Done: What we would need is something that overwrites Windows' default
	behaviour of determining device sizes (when Meta data is
	internal we want to report only the payload size without
	the meta data).

	Update: With the new architecture this comes for free.

Done: Have a lower level device for drbdmeta for access of internal
	DRBD meta data while resource is up.
	Update: with new architecture this came for free.

Done: Have other device extension with only the fields we
	need.

	We now disabled mvolAddDevice (by returning NO_SUCH_DEVICE,
	else we blue screen because some verifier) so volume
	extension does not exist any more (except in non-accessible
	code). 

	Update: maybe the struct block_device should be the windows
	device extension, so we safe a intermediate data structure.

	Update: That's what we do now. While having NT kernel internal
	variables inside linux structures seems like bad design at
	first, it saves a lot of (unneccessary) work. For example
	we now have the offset and io_stat used by 
	win_generic_make_request() internally as part of the struct bio.

	Done: Next thing is to have replacment data structure so
	that attach works again (create block_device with target
	device looked up in find_target_dev). Also get I/O on
	that target dev working (used to blue screen but maybe
	it works now that we do not create a device in AddDevice())

	Update: for DRBD devices device extension is now struct
	block_device. 

	Update: after long research (and with help from a stack overflow
	kernel guru) we solved the blue screen and now do not do 
	AddDevices any more.

	Rejected: check if generic_make_request can use the ZwCreateFile
	API (instead of creating an IRP)
		I/O on the backing devices work now (again) with the
		IRP API.

	Done: remove devices in bdput destroyer.
	Implemented but cannot test it now, it is newer called from 
	drbd_destroy_device (which is also never called).
	Update: calling it now from drbd_unregister_device(). Works.

	Done: bdput in drbd_create_device on failure.

	Done: clean up code, delete commented out code.

	Done: size fix (with external meta data something destroys the
	disk size setting, so that drbdadm up / down only works once).
	Update: this doesn't happen no more.

	Done: clean up block devices created by blkdev_get_by_path().

	Done: keep an internal list of struct block_devices created
	for backing devices (so that internal meta data works again).
	and don't have more than one struct block_device per physical
	partition.

	Works now (again) with internal meta data.

Done: Redesign of architecture.

	Currently the DRBD device is stacked atop of the low level
	Disk drivers. This way all I/O goes through the WinDRBD
	driver also that of the non-drbd drives (like C:, ...).
	An Active flag controls whether I/O is routed through
	DRBD or not.
	
	One major drawback is that once the Active flag is set
	we cannot access the lower device. This is needed however
	by drbdmeta.
	
	We want an architecture that is more close to that one
	of Linux where DRBD devices and backing devices are different
	device objects, even for the Windows kernel.


Done: Try to put I/O on DRBD device.
	This will be the same device as if there was no DRBD (use
	the drive letters).

	Update: Started setting the Active flag automatically from
	within DRBD (currently only at successful attach, later
	also on connect. Somewhere else?).

Done: Unset the flag on down / detach. Or better set it on
	becoming primary, clear it on becoming secondary (let
	DRBD do the checks).

Rejected: Remove check in mvolWrite(): DRBD should do this.

	Update: Currently drbd_open() fails because of some
	auto-promote mechanism that never happens. It seems
	that the synchronisation (wait_event_interruptible()
	and the like) are broken.

	Update: We now try to have a separate Windows device for drbd
	and backing device this is more close to what DRBD under
	Linux does.

Done: Create patches for DRBD for recent changes.

Done: README.md

Done: Submit current sources.

Done: make format H: work

Done: Writing partition table should not fail.

Done: Fix sharing violation problem.
	Currently find_windows_device fails (as it should) calling
	IoGetDeviceObjectPointer() (before it can check the list
	of already open backing devices, these are currently indexed
	by exactly that pointer) because close_backing_dev is currently
	not called on detach. The reason is probably that schedule_work()
	mechanism is implemented wrong in windrbd.

	Update: drbd_destroy isn't called because the rcu mechanism
	is not implemented (or not implemented correctly) in windrbd.
	Do that after 0.2

	Update: sharing violation now fixed, however now there is
	an IO ERROR: neither local nor remote data which is new.

	Update: We now shift the backing device by one sector so
	that Windows NT does not recognize the backing device as
	NTFS (or whatever) formatted. This solution works quite
	well for us and also prevents Windows NT from replaying
	journal before the DRBD device is brought up.

Done: Fix IO ERROR
	It seems to come from an 0xc0000022 (access denied) error
	from the lower level device.

	Update: Error was not propagated to user space, this should be
	fixed now.

	Update: error c0000011 on accessing meta data (end of file
	error) when meta data is internal.

	Sectors are now shifted, see sharing violation problem.

Done: where did the volsize blue screen disappear.
	When using IRPs on an NTFS formatted partition, we had
	blue screens which do not happen any more. This is strange.

	Update: Also does not blue screen when meta data is internal,
	however apply-al does not work (error c0000011 (end of file)
	when reading meta data).

	Sectors are now shifted, see sharing violation problem.

Done: when there is NTFS on the backing device drbdadm up fails
	(with internal meta data) because it cannot access meta
	data.

	Plus there is a blue screen when changing from internal
	to external meta data. (This might be a windows internal
	bug tough).

	Update: No it was something else..Irps don't work with
	getting volsize of an NTFS partition, rewrote it to 
	use ZwXXX() API, now we have problems with sharing
	violations.

	Sectors are now shifted, see sharing violation problem.

Done: DeviceControl (there are many more but those
	are the ones called when the device is opened):

Done: implement I/O handler stubs
	Stubs done, return STATUS_OK (or STATUS_NOT_IMPLEMENTED)

Done: nc test
	Works as expected.

Done: Fix Spurious timeout error on receive.
	Was behaving as intended.

Done: hack test

Done: Make drbd run on peer Linux box
	We cannot run 3 VMs on our Macbook Air since it has only
	4 GB of RAM. Now, we are using the production Linux box
	for DRBD peer.

Done: make drbdmeta be able to read near the end of an NTFS 
	partition.
	We now hide NTFS from windows when it is a backing
	device.

Rejected / Partially done: tcpdump nc and drbd and see if there is a difference.
	Didn't find anything yet, however there must be
	something. Look at the packets with hex?

	Update: The packets were received but on the windrbd side
	the 80 byte handshake parameter packet never is received
	(it is sent by Linux DRBD).

Rejected: schedule_timeout_interruptible not implemented correctly.

	It just does a wait on single object with a timeout object. so it
	isn't interruptible.

	If solved then also write a small test for it.
	
	Update: No it can only be interrupted by a UNIX signal
	(which does not exist on Windows) so the implementation
	is correct.

Done: Who is supposed to wake up schedule_timeout_interruptible() in
	dtt_connection_established()?

	Ask phil or lars. Don't want to dig too deep into DRBD now.

	Those two are needed to make connection work.

	Done: Nobody.

Done: Make connection work.
	It seems that kernel_recvmsg() does not receive anything
	from the windrbd side (it fails with an EAGAIN error
	reproducible).
	If DRBD on Linux is replaced by a ncat we can see the
	packets arriving on both sockets: 
ncat -l 7600 -k | hexdump -v
0000000 7483 6702 f1ff 0000 7483 6702 f2ff 0000

	Update: If connection is established in the order
	connect send connect send the first packet is received.

	Done: Write a small C program (with gcc) to test that from user
	mode. 
	It works non-interleaved (is a cygwin program)

	Now, check tcpdump output.
	TCP checksums are wrong but this is most likely due to 
	checksum offloadinng (they are correct on the wire only
	the network card displays it wrong).

	Apart from that the packets seem to be equal (sequence number?)
	Update sequence number is Wireshark connection ID.

	Update: difference is that Linux DRBD upon incoming connection
	tries to reach windrbd which fails because windrbd makes a
	bind but no listen currently. What is strange is that 
	connect() on Linux side succeeds while we see a RST in 
	the TCP packet coming from windrbd (but that is maybe
	because the socket is non-blocking on the Linux side).
	
	We now patch Linux DRBD so that connect(2) always fails and
	see if that works.
	Update: unfortunately this did not fix the error.

	netcat on the windrbd port shows that connection is
	accepted(?) but closed immedieately

	Update: No packets get lost. The initial packets are received
	and the 80 byte handshake packet is sent to windrbd.
	However there it is never received (drbd_recv_short
	is never being called by windrbd). So the whole
	thing was because receiving the handshake packet
	(80 bytes) is not implemented on the windrbd side.

	Rejected: write 2 C (user space) programs that show how this
	scenario looks like in POSIX environment (bind without listen
	and connect returning 0)

	Update: Reasons were:
		ping timeout was set incorrectly.
		peer (Linux) disk was too small.

	So in fact it always worked. Arghhhh!


Done: blkdev_put isn't called on drbdadm down

	fix this one day, this is probably a DRBD9 bug. Or maybe
	it is intentional.

	INIT_WORK and schedule_work do what they say?

	Later: Currently bdput is called from within drbd_unregister_device,
	ask phil if that is ok (it should make the device invisible, which
	is what it does).

	Update: this is something with RCUs

	Update: call_rcu now does something, is this fixed now?

	Update: Yes it is. Closed.

Done: Possible race at drbd_thread_setup() (drbdmain.c:567) with
	use-after-free.

Done: implement open and close methods.

Done: Right now, windrbd isn't listening for incoming connections.

	Connection should work nevertheless.
	Update: setting event mask correctly now, incoming
	connections work (tested with disabling outgoing connection,
	the DRBDs eventually connect anyway).

Done: eliminate bio_databuf fields.

Rejected: Have sshd on Windows and work remotely
	Would be convenient, however setup is a little bit
	complicated ...
	This is a nice to have.

Done: errnos should match linux error codes
	(so that errno cmd line tool works).

Done: get cygwin chmod working.

Done: Implement multi page I/O

	Required for DRBD sync

	Currently fixing some blue screens: on multiple page I/O
	one issue was fixed (length of first MDL was wrong), now
	when doing a:

	drbdadm up
	drbdadm cstate == connected
	drbdadm down

	we crash (PFL something)
	when we do

	drbdadm up
	drbdadm cstate == connected
	drbdadm detach
	drbdadm disconnect
	drbdadm down

	everything works. So disconnecting when we have a backing
	device is what doesn't work. Also:

	drbdadm up
	drbdadm cstate == connected
	drbdadm disconnect

	Crashes on disconnect

	Update: Reason most likely a buggy implementation of
	mempool_free() in windrbd. (see drbd_bitmap.c:drbd_bm_endio
	around line 1074: if that line is commented out, no
	crash). mempool_free probably should not free the page
	itself, have reference counting on the page.

	Update: Problem fixed for now. The real problem is the
	question of who owns the memory pointed to by the MDLs.
	There seem to be other instances where the DRBD endio
	routine frees memory and also if we comment out MDL
	freeing we get a blue screen when syncing (at the end
	of format h: command).

	Update: We still have I/O errors however BSODs are gone.
	We now check if MDL has MDL_PAGES_LOCKED set (which is
	only the case for the first entry) before calling
	MmUnlockPages().

	TO DO is to check where the I/O errors come from.

	Jan 11 15:25:13 192.168.56.101  U14:24:54.369|0131bb50 __drbd_chk_io_error_ <3>drbd w0/17 minor 5, ds(Failed), dvflag(0x2c): Local IO failed in __req_mod. Detaching...

	Update: fixed. Was a wrong bi_vcnt in irp_to_bio (windrbd
	toplevel device object (H:)).

Done: windrbd-test destroyed (!) partition table?
	Yes it does (set_partition_info test). Now protected by
	an interactive query (unless --force is given).

Done: make write_whole_disk test work.
	Only fails when connected. Works when primary and disconnected.

	Update: stalls at sector 73924 when primary and disconnected.

	Update: connection fails from time to time and we need to
	reconnect.

	Update: works when unconnected (except the aforementioned stall,
	which we cannot reproduce at the moment).

Done: all I/O should fail when Secondary
	Important.
	Done. format h: however does not display an error (but
	this is a format problem, the data on disk is unchanged).

Done: Throw away lots of Mantech code.
	Mostly done.
	Get rid of PVOLUME_EXTENSION as well.
	Done

Invalid: Release backing device:
	drbdadm up / drbdadm down / format f:
	Not clear what this means. It works for me.
	Reopen that when it bites.

Done: test external meta data
	Currently running with external meta data

Done: write sometimes stalls when there is too much logging.
	Solved: this is a bug in VirtualBox (network is down
	and write test runs from network share).

Done: Cannot mount NTFS after sync.

	johannes@johannes-VirtualBox:~/Linbit/tmp$ sudo mount /dev/drbd26 -t ntfs mnt/
	ntfs_mst_post_read_fixup_warn: magic: 0x00000000  size: 1024   usa_ofs: 0  usa_count: 65535: Invalid argument
	Record 0 has no FILE magic (0x0)
	Failed to load $MFT: Input/output error
	Failed to mount '/dev/drbd26': Input/output error
	NTFS is either inconsistent, or there is a hardware fault, or it's a
	SoftRAID/FakeRAID hardware. In the first case run chkdsk /f on Windows
	then reboot into Windows twice. The usage of the /f parameter is very
	important! If the device is a SoftRAID/FakeRAID then first activate
	it and mount a different device under the /dev/mapper/ directory, (e.g.
	/dev/mapper/nvidia_eahaabcc1). Please see the 'dmraid' documentation
	for more details.

	Update: It seems that somebody writes to the DRBD device (what we
	did is write it while unconnected, then copy drbd device on windows
	to a file and then connect the DRBD to linux wait until sync is
	finished and then copy the Linux contents to a file and diff the
	hexdumps of both files). Either Sync is broken or somebody writes
	the device where he shouldn't. Update: windows data seems to be
	correct, so sync is broken.

	Strange: DRBD does not sync while all bits are set in bitmap.

	Update: when copiing the dumped DRBD block device from windows
	to Linux, it also fails. Maybe the Linux NTFS driver is buggy?

	Update: when using external meta data and copy the backing
	device (F:) via scp we can mount the NTFS partition with
	ntfs-3g (Update: also with mainline kernel ntfs driver)
	The backing device must be patched so that where it says
	DRBD it should read NTFS in the boot sector (can be done
	with vi).
	It is clear that copiing the DRBD device (instead of the
	backing device) does not work because Windows hides the
	last 8 sectors.

	Update: It seems that the invalid pages point to somewhere
	where windows kernel alloc tags (like WD4E, E4DW in the source
	code) are. So we have an invalid pointer (use after free?)
	problem.

	Check if all pages are transferred first and then validate
	the pointers.

	Test was made with write-test.sh not with NTFS (so NTFS
	driver isn't the problem)

	Update: Problem was that Length of I/O was only the first
	MDL entry not the total length. Should work now. TODO:
	test with NTFS.

	New blue screen: IoBuildPartialMdl was called with a
	virtual address outside the range of the source Mdl.
	When syncing.

	When restricting max number of MDLs to 16 we do not
	blue screen but data is corrupt (at offset 0x1000
	which cannot be explained by the 16 MDLs limit).

	Update: we have 3 errors here: one is that we cannot
	read more than 64K (16 Pages/MDLs) without blue screen
	one is a page fault blue screen (which does not always
	happen) and one is a data corruption between
	DrbdIoCompletion and sending the packet.

	Update: error #3 (data corruption is because 
	_drbd_send_zc_ee is wrongly patched by windrbd. 
	Undo this patch and it should work. Update: yes
	it does.

	Update: Mount works now. Error #2 (page fault blue
	screen) is most likely fixed. Error 1 is TO DO.

	Update: NTFS mounting works now, however there
	is a blue screen when reading more than 64K
	from the backing device. Making seperate TODO.

Done: BSOD sometimes when syncing

	Update: New blue screen page fault in non paged area
	(when waiting before connecting) Update: this is probably
	fixed by locking all the pages into memory. Observe
	and reopen this if it happens again. Update: happened
	again.

	Update: the page fault in non paged area BSOD reappeared
	(while Syncing).

	Update: again, while syncing (2 times in a row)

	Update: again, while syncing (and not freeing pages)

	Update: Fixed something in drbd_main.c this should
	not happen any more. Reopen when it occurs again.

Rejected: fix freeing bio without irp.
	Not to fix. DRBD sometimes allocates bios without ever
	calling generic_make_request on them.

Done: fix memleak in getting volsize.

Done: use after free blue screen after patching bio split in.

	When not freeing mdls and irps and not freeing the bio
	it disappears. Not putting the bio in upper device does
	not help. Nor does not freeing the buffers themselves
	(in __free_page()).

	Now holding reference to bio in generic_make_request this
	seems to solve the problem.

Done: Cannot read more and 64K (16 MDLs) from backing device.

	Blue screen shows STOP: 0x0000012E (0xFFFFFA80037AD980,
	0xFFFFFA80039951A0, 0xFFFFFA800669F000, 0x0000000012000)

	Update: According to:
	http://osronline.com/showThread.CFM?link=204514
	this is a known bug in some Windows versions (esp.
	Windows 7 Professional 64 bit), while it works
	in other versions. We should restrict the number of
	sectors read/written to max 128 and test this on various
	windows versions.

	Update: not possible to patch DRBD not to use more than
	128K because this is an over the wire parameter (would
	have to patch linux DRBD as well). Implement solution
	that splits the bios into smaller pieces.

	Update: its 128K (32 pages) according to our experiments.

	Update: Implemented but currently leaks IRPs.
	Update: fixed leak seem to work ok (except blue screen
	when formatting and drbd is connected). This is now a
	separate TO DO since it also happens when doing something
	(writing) to the DRBD device and the resources are connected.

Done: Network goes down while sync. When syncing an NTFS partition only.

Jan 20 12:46:05 192.168.56.101  U11:46:05.795|0393cb50 find_request <3>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x2): receive_DataReply: failed to find request 0x136c6c00, sector 26160s
Jan 20 12:46:05 192.168.56.101  [last message was in IRQ context]
Jan 20 12:46:05 192.168.56.101  U11:46:05.795|0393cb50 drbdd <3>drbd w0 pnode-id:1, cs(Connected), prole(Secondary), cflag(0x200a), scf(0x1): error receiving P_DATA_REPLY, e: -5 l: 4096!

	This seems to be fixed by the > 32 bio_vecs patch.

Done: check 2 patches using bio_databuf
	bio_databuf is gone. So are the patches.

Done: with DRBD: 500 kB/sec (unconnected) without 900 kB/sec
	500 kB was with lots of debug output. Now we have 600 kB/Sec
	a bit better.
	without DRBD: 983.71 kB/Sec
	with DRBD (unconnected): 586.25 kB / Sec

	Update: with 1Meg write requests it is very fast. So
	the problem seems to be the OS overhead (both DRBD
	and NT kernel)

Done: The functions enclosed by _WIN32_MVFL (see win4lin/src/util.c) are
	not referenced anywhere in the code. I assume that they never have been
	tested. I would like to remove them (or at least rewrite them if the
	functionality is needed) since they depend on some other stuff I would
	like to redesign.

	Update: We need the functionality if DeviceIoControl() (user level
	function) is called on the DRBD device. So leave it in for now.

	Update: We don't want any DRBD specific DeviceIoControls. Check if
	one of those are really needed and then remove the code.

	Done. We removed about 4000 lines of code.

Done: drbd w0 linbit-wdrbd: error receiving P_RS_DATA_REQUEST, e: -22 l: 0!
	Update: didn't observe lately (with 0.3.7) but I am
	pretty sure it is still in there.

	Hopefully fixed by multiple requests patch.
	Update: No it isn't. Just happened while Windows was SyncTarget.

	Update: bm_op was returning unsigned long instead of 
	ULONG_PTR. Fixed by patching DRBD.

Done: Test windows being SyncTarget
	Works now, error receiving P_RS_DATA_REQUEST was fixed.

Done: PFN list corrupted when connected and I/O is on windrbd device
	Just reappeared again when sync completed and windrbd was
	SyncTarget.

	Update: We now unlock the mdl page's memory created by
	IoBuildAsynchronousFdsRequest() right after creating the
	Irp. Furthermore we now use MmBuildMdlForNonPagedPool()
	since the page memory is from NonPagedPool. It seems to
	work now. Please reopen when blue screen happens again.

Done: IRP_MJ_SHUTDOWN (0x10) not implemented.

	Update: Implemented but does not get called if we
	never access the DRBD device. This functionality should
	be in a one time called function.

	Update: shutdown done when the root device object is
	shut down (exactly once).

Done: it seems that free_page crashes sometimes (0x1E)

	Reactivate the hack to see if it crashes there.

	Update: No free_page is ok. Crash is because there are
	still drbd resources on line while we free all buffers
	(which is generally not a good idea). For now don't do
	anything on shutdown, we should see how Linux DRBD behaves
	on forced system shutdown.

Done: logical block sizes do not match (me:512, peer:0); this may cause problems.
	Fix this (should be easy)

	Update: Reenabled assign_p_sizes_qlim() in drbd_main.c
	this should have fixed it.

Done: data corruption when doing a 

	cp /dev/urandom /cygdrive/h/random-file

	and diff it against the synced linux ntfs.

	Maybe this is a sync error.

	Update: bio->bi_sector was set wrong when splitting
	the bio in generic_make_request. Is fixed now.

Rejected: compile user space apps with MinGW
	Isn't meant for POSIX apps

Rejected: Error receiving P_STATE on Linux on split-brain.
	Phil says this is normal

Done: Test with Windows 10 (we have to do that anyway some day)

	Installing to Linbit supplied test machine.

	Driver loads (with TESTSIGNING ON) userland currently fails 
	to find POSIX root (/) dir (/etc/drbd.conf not found).

	Update: works. When accessing windrbd device (dir h:) it
	blue screens
	Update: Blue screen fixed.

	Connection currently unclear (error receiving initial packet).
	With netcat a TCP/IP connection works.

	Update: Was a split brain.

	Except for a sync instability windows 10 now works as good
	as windows 7 (including logging)

Done: Fix logging errors

Done: Have DRBD and windrbd release number in log and properties of driver

	Review. And there is a bug in printk() ring buffer which causes
	corrupt initial log messages.

	Put DRBD and windrbd version number in 1. dialog of self extracting
	exe

Done: make install package
	self extracting exe or msi file.
	Know how to do it (iexpress.exe) do it properly once
	everything else is done.

	Works almost .. we however have to compile user space utilities
	with MinGW, which would use native Windows DLLs. Currently
	bundling with cygwin fails because the POSIX root (/) cannot
	be set to the cygwin path.

	We should switch to msi based install. Or at least get rid
	of the Must reboot now panel, because userland tools are installed
	later.

	Check the GPL line feeds.
	Get rid of reboot now message (change type of driver?)
	Make userland use C:\windrbd as cygwin root (take care not
	to destroy existing Cygwin installations)

	Update: setting StartType to 3 (on demand) makes windows not
	boot. Try this with a freshly installed windows.

	Also blue screens on a virgin windows (well almost..) we
	skip this for now and try again later.

	For now, self extracting exe should be fine. But install
	userland before reboot message appears.

Done: Install userland before driver
	So we can safely reboot.

	This is now done by calling infdefaultinstall from
	within the cmd script (as last command). infdefaultinstall
	needs a path (even if it is the current working directory,
	so do infdefaultinstall .\drbd.inf

	Eventually we want to have msi.

Done: install c:\windrbd filesystem hierachy

	Had to include cygwin's unzip (plus an extra DLL) in package

Done: Remove most registry keys.

	Also do not create them on installing windrbd.

Done: In progress: reinstall windows 7 and check if last 4096 bytes in NTFS
	are still hidden.

	They seem to be under Windows 10.

	Update: Need cygwin to run tests (else WriteFile will always
	fail with error 87 Invalid Parameter, even on a newly created
	partition when running from cmd shell). However I/O returns
	5 (Access denied) when accessing an NTFS partition. So the
	answer is yes.

Duplicate: Logging Eventlog? windrbd server localhost UDP.

Duplicate: In progress: allow user to pass name of symbolic link created
	(i.e. the drive letter) via drbdadm/drbdsetup/kernel

	Update: This should be userspace-only. It should
	also be possible to mount the device upon an
	empty NTFS folder (later).

	At this point also clean up drbd-utils (separate
	files for UNIX and Windows) and integrate upstream
	changes (later).

	Update: we wait for our patched drbd-headers to
	appear on github.

	Update: Created windrbd utility that does it. For now
	users have to execute it manually (it creates drive letters
	only for the user that runs the script which might be
	confusing since drbdadm usually runs as administrator).

	Later, remove the drive letter magic from the kernel driver.

	Nice-to-have: a list-drive-letters command.

	Update: find out how to set drive letters visible to
	all users.

	Update: syntax is:

	device "l:" minor n

	which is quite intuitive

Done: Windows to Windows test: blue screen on both sides on drbdadm up

	Is when backing device contains an NTFS filesystem (which
	is normally not the case, but it shouldn't blue screen).

	Maybe it is in general not a good idea to attach to a backing
	storage containing a file system, because this means that the
	user has done something wrong. (We are patching NTFS<->DRBD,
	so a valid windrbd NTFS contains DRBD as filesystem magic)

	Update: when there is a file system on the backing device
	Windows still crashes.

	We now refuse to attach backing device when it contains
	a file system. Formatting an attached file system currently
	force detaches the device, this is not exactly what we want
	There should be a mandarory locking preventing all I/O
	(except DRBD) on the backing device. Do that later.

Done: When playing with show / hide filesystem blue screen on attach.
	1D (1E?)

	Occured again. Please fix this.

	drbdadm up w0 		# fails to attach
	windrbd hide-filesystem f:
	drbdadm attach w0
	drbdadm primary w0
	ls /cygdrive/h		# blue screens

	Windows seems to cache the file system separately (something
	like Linux' directory cache). Solution would be to unmount
	and mount again it on hide-filesystem (already tried manually
	with mountvol utility). Update: there seem to be some sort
	of reread filesystem mountvol delete does.

	Update: Obviously our patching NTFS <-> DRBD of the filesystem
	bootsector at offset 3 isn't enough .. we need to patch more
	than that. Update: no it isn't. Need to call mountvol to
	remount volume, works now with Windows 7 Windows 10 unclear.

	Reopen when it happens again.

Done: windrbd hide-filesystem <drive-letter/GUID>
	also show-filesystem and filesystem-state
	no GUID yet.

	In progress: umount / mount Volume on hide-filesystem
	to clear windows directory cache (else drbdadm
	up / drbdadm primary / accessing the windrbd device
	will blue screen)

	We now call mountvol directly, it works on Windows 7
	but not (always) on Windows 10 (but maybe this is
	another BSOD)

Done: windrbd log-server -o logfile

Done: Use Linbit certificate to sign driver.
	It should be trusted.

	We have a certificate now, but the root of this certificate
	isn't trusted by Windows 7.

	Phil is currently trying to get a proper certificate.

	Update: Works now, but build / sign process is a little
	bit clumsy. Need to copy files manually and patch
	Windows Makefile.

Done: Don't install cygwin1.dll when cygwin is found on the target.

	Now, taking cygwin1.dll from existing installation. Done:
	Test if this works.

Done: IP address of "Closing unexpected connection" printk is still wrong

Rejected: also test with 32 bit version of Windows 7
	(does it exist for Windows 10?)

Done: clean up the registry
	Except for logging IP we don't need anything IMHO

Done: windrbd.exe hide-ntfs-partition

Rejected: We want to see the syslog output when the system did boot, not
	only when we configure a DRBD device.

	This is sometimes practical.

Done: Implemented flushing for WinDRBD device.

Done: hide backing device from Windows on attach.
	This can (?) be done from user space by including
	windrbd hide-filesystem automatically on drbdadm attach
	(and maybe show-filesystem on drbdadm detach).

	Doing it from kernel does not "add value" .. it would just
	be extra effort (and might fail, since we had troubles
	with ZwCreateFile()).

Done: windrbd show/hide filesystem also with GUIDs.
	
Rejected: show filesystem on drbdadm down (not on detach).
	Instead instruct the user how he could do it.

Done: most windrbd command should also take GUIDs (show-filesystem, ...).

Done: drbdadm should call windrbd to assign the drive letter

Done: remove 'C'+minor magic from kernel
	Maybe: generate a GUID in kernel and create a Volume{GUID}
	entry. So we can assign the drive letter for all users.
	Update: create a GUID once and hardcode it in the driver /
	windrbd utility.

	Update: implement IOCTL_MOUNTDEV_QUERY_DEVICE_NAME
	to return /Device/Drbd5, and check if this is being called.

	Update: have to register device with mount manager, which
	currently fails with invalid device request.

	Update: have drbdsetup new-minor --mount-point parameter
	now, drbdadm uses the device name for the mount point.

Rejected: assign-drive-letter should assign drive letter for all users.
	Still there, but we are not using it. Now there is an extra
	field mount-point in new-minor. 

Rejected: delete drive letter also on drbdadm down.
	Problem is that on down there is no volume. Maybe we have to
	iterate over all volumes.
	Superseded by mount-point flag in new-minor.

Done: drbdmeta called before hide-filesystem and fails
	(on drbdadm up / format f: / down / up)

drbdsetup new-resource w0 2 
drbdsetup new-minor w0 5 17 --mount-point K: 
drbdsetup new-peer w0 1 --_name=ubuntu-gnome --use-rle=no --protocol=A 
drbdsetup new-path w0 1 ipv4:192.168.56.101:7600 ipv4:192.168.56.103:7600 
drbdmeta 5 v09 F: internal apply-al 
windrbd -q hide-filesystem F: 
drbdsetup attach 5 F: F: internal 
drbdsetup connect w0 1 

	should be 

windrbd -q hide-filesystem F: 
drbdmeta 5 v09 F: internal apply-al 

	Update: Done, but this is still invalid. After formatting
	the backing device, meta data gets destroyed. Need to redo
	a create-md.

Done: Cannot format virtual drive.
	Regression introduced recently (right before windrbd-0.6.0)
	
	Impletented Done: test it when we have internet again (just
	format k:, should run without error), works

Done: up / down: down fails with failed to detach
	Fixed, was problem drbd_release() when drbd_open failed before.

Done: Blue screen when opening windrbd_control (root device object)
	with WinObj

	DriverVerifier expects IRP requests to succeed (at least create
	close and cleanup)

Done: receive_DataReply: failed to find request 0x1a186c00, sector 25896s
	When writing on Windows DRBD.

Done: error receiving P_RS_DATA_REQUEST, e: -5 l: 0!

	On windows side when syncing.

	Also:

	linbit-wdrbd: error receiving P_STATE, e: -5 l: 0!
	on windows side on connection establishment.

	Update: The later is because of a split brain. For now
	resolved it by re-creating meta data in the Linux side.

	Update: this seems to be correlated with the data corruption
	bug. Update: no it isn't data corruption happened when accessing
	the backing device.

	Update: it is also (or only) on Linux side.

	Update: error receiving P_STATE on split brain should also not happen.
	But low priority.

	Update: this error is not so critical, do that later

	Update: peer has no local data:

Feb 14 16:08:05 johannes-VirtualBox kernel: [ 4722.510438] drbd w0/17 drbd26: Can not satisfy peer's read request, no local data.

	So maybe this behaves as expected.

	Was typedef char bool which caused is_write_request() to
	always return 0.

Done: blue screen on writing while connected.

	Also reported by Devin.

	Reason is (most likely (Update: yes that was it)) that
	the bi_vecs contain elements bigger than PAGE_SIZE which
        isn't supported by DRBD (when it comes to sending pages).
        On fixing this (at windrbd level, see irp_to_bio) we
	introduced a new error which causes formatting to fail.

	Update: Fixed a bug that caused formatting to fail.
    
	But not the read/write tests of our testsuite..we probably want
	to cover this case too. Formatting works now, as well as writing
	to windrbd device while it is connected (also writing on the
	remote side while being connected works).

Done: remove the #ifdef _WIN32 defines

Done: Segmentation fault on drbdadm invalidate

	drbdadm invalidate-remote works.

	Should be fixed, was easy.

Done: drbdadm del-minor should not call windrbd delete-drive-letter
	any more.

	Check if this is needed and remove that code if not.
	Done, removed. I don't think we still need this.

Done: new blue screen running (new) test.sh
	driver verifier again. Peer is not running (no connection)
	Reason was a missing IoCompleteRequest on windrbd_ioctl()
	when device was already deleted.

	Tested, no blue screen.

Done: DRBD windows to windows sync is very slow.

	Not clear if it is the network or something else.

	Update: it is not the network.

	I/O on Windows 10 is very slow also (format h: on a
	connected resource takes forever)

	Update: when connecting to windows build host it is
	faster (network is over the air), so maybe something
	with the Linbit Windows VM is wrong.

	Update: Devin (Linbit USA) also reported this.

	Update: Something between drbd-9.0.9 and drbd-9.0.13
	has been fixed to solve that (it is slow between a 
	9.0.9 and a 9.0.13 under Linux also (in one direction), 
	upgrading 9.0.9 to 9.0.13 solves that so it is fast in
	both directions). Also put

        disk {
                c-max-rate 4048000;
                c-fill-target 1048000;
        }

	into w0.res (at resource config level) on both sides.
	Then it should work. TODO: upgrade windrbd to 9.0.13

	Done, with 9.0.13 Sync is faster (14MB / sec instead of
	4 MB / sec), should be 50 MB / sec however.

	Update: between much VM (Windows 7) and Windows 10 sync
	rate is still at 200 kB which is way too less.

	Some printk's for researching slow sync show that requests are sent
	by 4k (instead of up to 1m) from the windows side (if windows is
	SyncTarget). Fix that and see if it is faster, then.

	Compared to Linux/Linux sync it is then still slower (about
	a factor of 3 or 4) maybe because Windows I/O is slower?

[ 3979.671662] KARIN cmd: 9 sector: 14336 size: 1048576
[ 3979.671665] KARIN cmd: 9 sector: 16384 size: 32768
[ 3979.780097] KARIN cmd: 9 sector: 16448 size: 32768
[ 3979.780121] KARIN cmd: 9 sector: 16512 size: 65536

	Windows sometimes stucks when replying to data requests (11ms
	pause).

	Update: Initialize max_hw_sects in queue.

	Now resync requests are sent in chunks of (up to) 1M which makes
	resync much faster (was 4K chunks, because max_hw_sects was 0).

	Right now, resync between Windows and Linux is still a bit slower
	(factor 4) than beween Linuxes, this is maybe because the I/O
	stack is slower under Windows (?).

	Update: Between win7 (much VM) and win10 sync gets stucked
	now (number is 0)

	Update: Research showed that when called via drbd_submit_peer_request()
	I/O on the backing device is very slow (reading 512kb takes over
	one minute). Dig deeper into the windrbd implementation and
	see why endio arrives so late (SyncSource was a Windows 10 box)

	Update: We found a performance leak in the Send() (wsk2.c)
	function. It completes synchrouniously, throughput is
	2 MBit/sec (4096 bytes / call). When switching to asynchronous
	completion this raises to 27MBit/sec. Problem is: how to
	free buffer memory (should be done by put_page(), however
	this is not implemented yet), and, much worse, error
	reporting (don't know yet how to solve this).

	Update: we had a version that worked (with SendPage()?) find
	it again. Update: Yes that was the working version. It performs
	well on our test setup (syncing with 100MBit/s, which is on
	the VM side the maximum). However there is a blue screen
	on PingAck didn't arrive in time (see separate TODO) plus
	one or two additional memory leaks. Performance problem
	seems to be fixed now.

Done: Memory leaks on SendPage()
	doing a put_page and MmUnlockPages()

