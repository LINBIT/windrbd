TODO: Physical USB stick BSOD on becoming Primary.

	Most likely because of MAX_MDL_ELEMENTS being 16.

TODO: test backing device failure with small I/O sizes

TODO: test I/O with requests > 1 Megabyte

TODO: Performance: patch DRBD to handle biovec elements larger than 4K.

	There might be other limits .. 1 Meg is the maximum size
	of a data request packet, so we still need the splitting
	in windrbd.

TODO: Bug: BSOD on backing device failure while I/O is running

	This was tested by unplugging a USB stick (contained the
	backing device) while copiing a large file to windrbd
	device. OS was Windows 10 (physical machine).

	Update: We cannot call the backing device driver again
	if the device already failed (else BSOD). Immeadietly
	before calling it check if it has failed and cancel
	IRP without calling the driver if yes.

	Update: When logging is not on, there's still a BSOD,
	(windrbd log-server not running), reopened. Maybe fix
	the logging first (wait for UDP packet to arrive).

TODO: Bug: From Devin: d->bi_size (from peer request) too big:

	2018-05-17T13:37:08.765112-07:00 aragorn.us.linbit  U20:37:08.743|d6f31040(receiver) static_inline_expect_fn_peer_device <3>drbd w0/0 minor 0 pnode-id:1, pdsk(UpToDate), prpl(Established), pdvflag(0x600): ASSERTION d->bi_size <= DRBD_MAX_BIO_SIZE FAILED in read_in_block

	Test with large block device sizes.

	Update: did, but didn't yet happen (sync would take 3 hours)

	Update: happened on syncing between Windows Server 2016 and
	Linux: two more assertions failed:

Jun 27 15:37:45 wintestubuntu kernel: [85326.250911] drbd w0/1 drbd1 WIN-F11R93CP9KI: ASSERTION (n_oos - peer_device->rs_failed) == 0 FAILED in drbd_resync_finished
Jun 27 17:02:04 wintestubuntu kernel: [90385.215243] drbd w0/1 drbd1 WIN-F11R93CP9KI: ASSERTION node_mask == 0 FAILED in _drbd_send_uuids110
Jun 27 17:03:02 wintestubuntu kernel: [90443.041728] drbd w0/1 drbd1 WIN-F11R93CP9KI: ASSERTION d->bi_size <= DRBD_MAX_BIO_SIZE FAILED in read_in_block

TODO: Bug: blue screen on drbdadm detach --force (when needing uptodate
	data) and then drbdadm status.

	Cannot reproduce at the moment.

	Update: Yes this still happens (when I/O is on the windrbd
	device). BSOD on drbdadm detach --force (no need for drbdadm
	status). Happened on Windows 10.

	Does not happen on Windows 7, however on Windows 7 there is
	no error reported to user space (I/O application hangs and
	is not killable).

TODO: Bug: WinDRBD unresponsive when syslog host can't be reached.

	This is most likely because we wait for completion. Not
	sure yet if we want to fix this, because that probably
	would cause last messages before BSOD getting lost.

	On the other hand this probably can also fix the
	does not boot when local interface IP is configured bug
	(which is severe).

TODO: Bug: On Primary diskless (after backing dev failure) BSOD when unplugging Network cable.

	Check if also on 'normal' diskless.
	Update: No (did 1 test), but peer stuck in NetworkFailure

TODO: Bug: BSOD on passive remote side on reconnect to failed peer.

	This happened after restarting the peer after it had a
	BSOD on backing device failure.

	Update: There appears to be more than one problem. One last line
	is:

Jun 29 19:02:29 192.168.56.101  U17:02:24.344|0d994fa0(sender) w_e_end_rsdata_req <3>drbd usb-stick/1 minor 6 pnode-id:2, pdsk(Inconsistent), prpl(Established), pdvflag(0x600): Sending NegRSDReply. sector 32832s.

	but also

Jun 29 19:02:29 192.168.56.101  U17:02:24.329|171bcfa0(receiver) windrbd_generic_make_request <3>[0xFFFFFA800237AB50] IoBuildAsynchronousFsdRequest: cannot alloc new IRP

	before that line (which is most likely some invalid argument, not
	out of memory).

	Another last line is:

Jun 29 17:29:25 192.168.56.101  U15:29:08.370|133befa0(receiver) drbd_md_sync_page_io <7>drbd usb-stick/1 minor 6, ds(Inconsistent), dvflag(0x0): meta_data io: receiver [64726384]:drbd_md_sync_page_io(,15728632s,WRITE) FFFFF88001ADAD1CS

	This happens always after Down/Up after stuck in NetworkFailure.

	Update: After fixing the NetworkFailure bug, this unfortunately
	still happens (when reconnecting and syncing). Can't test at the
	moment.

TODO: BSOD on unplugging network cable in 3 node setup

	Was most likely something with 3 node setup (freezes when
	network cable is unplugged). Logging was local (BSOD when
	it is remote). Update: after several minutes BSOD also
	when freezed (WATCHDOG_VIOLATION).

TODO: Bug: Connection instable when connecting two Windows boxes.

	In that case our physical Windows 10 with Windows 7 VM on
	much.

	And one box is not pingable any more. Maybe something with
	libvirt? Hangs because logging does not work (was configured
	to log to Linux VM).

	Update: happens also with VirtualBox (Mac) Windows 7 box.
	drbdadm down / up on Windows 10 usually solves the problem.

	Update: really? Was split-brain, IP address change.

	Update: We also just had a complete network outage on
	the testing subnet..

TODO: Documentation: define tests to be run before releases.

TODO: Features: Make DRBD driver removable.

	From imdisk:

	start "" "%SystemRoot%\system32\rundll32.exe" setupapi.dll,InstallHinfSection DefaultUninstall 132 %SystemRoot%\inf\imdisk.inf

	In practice a

	rundll32.exe setupapi.dll,InstallHinfSection DefaultUninstall 132 Y:\windrbd\converted-sources\drbd\drbd.inf

	did the trick. DRBD is not stopped, but this uninstalls DRBD
	driver (after reboot drbdadm status fails because DRBD kernel
	module is not running).

	What is missing: write a cmd script that down all DRBD
	resources, stops the driver itself (how? see sepearate todo)
	and executes the setupapi thing above.

	Also create registry keys for Linbit / DRBD in
	HKLM/Software/Microsoft/Windows/Uninstall/DRBD so one can
	use control panel / uninstall software to uninstall DRBD.

TODO: Features: Make drbd service stoppable
	This probably takes some while
	Update: with the new architecture that should be possible
	one day.

	Probably some setting in the inf section. Or the way DRBD
	registers itself in DriverEntry?

TODO: Features: check if windrbd can be loaded not at boot time but later.

	Working on it .. test with demand load on a fresh installed
	windows (it blue screens on boot if there was a windrbd before
	installed).

	Update: imdisk can do it.

TODO: Installation: Make windrbd directory unaccessible for non-admins.

TODO: Code quality: Should report I/O error instead of Permission denied on disk failure

TODO: Code quality: Replace WDRBD_ERROR and the like by printk

	The log severities are wrong with these macros.

TODO: Documentation: white paper for linbit website.

	Until end of June 2018
	Update: maybe refer to the README.md.

	Update: No we need a TechGuide. Postponed to September.

TODO: Features: Test other file systems (FAT, FAT32, ...)
	FAT does not work (Invalid function when accessing DRBD device)
	FAT32 also not (something with flushing?)
	Probably there is one important IOCTL missing.

	UDF and exFAT can be mounted on Linux. FAT and FAT32 show
	empty (zeroed out) device. So we probably have 2 independent
	errors. (UDF cannot we written on Linux, this is because it
	is the DVD format).

	Update: exFAT now can be read (not written to) on Windows,
	by returning STATUS_INVALID_DEVICE_REQUEST (instead of
	STATUS_NOT_IMPLEMENTED) for unknown ioctl's.

	Update: implemented some other ioctl's without success so
	far. On formatting FAT, reads bootsector as last action
	(before terminating), maybe that's a hint.

TODO: Code quality: fix the spinlocks (see comments in drbd_windows.c).

	Windows doesn't have an equivalent of spin_lock_irq()
	(without flags) however we can assume that interrupts
	are enabled when spin_lock_irq is called and reset it
	to enabled when spin_unlock_irq is called (set it to
	PASSIVE_LEVEL).

	So no need for a tmp storage here. (Maybe put an assert
	at the beginning of spin_lock_irq that tests for IRQL
	being PASSIVE_LEVEL).

TODO: Test: Test sendbuffer full (rety on Metadata socket).

	See if supported at all (have printk's if not). Update:
	seems to be supported.
	Update: No it is not. It just never got called. Setting
	receive buffer size is supported, send buffer not.

	Unclear how to test it. Do that later.

TODO: Performance: Sync is still somewhat slow when windrbd is SyncTarget
	And: I/O is slow when connected.
	Are we waiting for TCP ACK here?

	Also need to set c-fill-target and/or c-max-rate with
	defaults it is just too slow...

	Update: Also implement no-wait sending for Send() function.

	Update: This function is only used for the first packet.
	and must remain synchronous.

	Update: Probably not the networking code, maybe I/O on
	backing device is slow? When Windows is SyncTarget it is
	faster (3 sec) than when it is SyncSource (7 sec) doing I/O

TODO: Features: implement flush_workqueue

	For example, drbdadm down takes long when connection goes
	down.

TODO: Infrastructure: install kernel manpages

	Must install from kernel source using 
	make mandocs ; sudo make installmandocs

TODO: Features: user mode helpers

	switch to ioctl() interface first.

TODO: Features: netlink transport over ioctl

	(something that can verify permissions of caller)

TODO: Code quality: eventually use drbd_rate_limit() on some printk's

TODO: Code quality: Implement function stubs created when integrating DRBD 9.0.9

TODO: Feature: on patching boot sector, inform Windows that file system is
	raw now.
	So that it disappears.

TODO: Test: how and when is flush to backing device done?
	This is important. Right now NTFS files only appear on
	Linux when sync is done manually. Should sync at least
	when becoming secondary. sync must be done while primary
	(when secondary it would fail)

	Update: is this fixed now?

	I recently didn't observe data loss on writing to an
	NTFS then doing secondary / primary on remote. However
	since Windows does caching at file level (not at block
	device level) it should fail. Maybe write a test that
	writes a large file and then immeadiately does a
	drbdadm secondary (without syncing the file).

TODO: Test: Check if windows device is really deleted on becoming secondary

	There might be references and it is only marked as pending
	delete (see IoDeleteDevice manpage)

TODO: Code quality: Rebase windrbd branch of drbd-utils to its master
	Also for drbd-headers. Then, also use the drbd-headers in
	drbd (and remove drbd-headers patches)

TODO: Bug: Make windows checkdisk (over unclean shutdown panel) work.

	It seems that this appears when backing device is used
	twice and modified, but how to make it disappear? cmdline
	chkdsk works.

TODO: Infrastructure: Linux box sometimes loses IP address.

TODO: Code quality: maybe revert the mountmanager code.

	I am not sure if this is a benefit.

TODO: Bug: refcnt is 0 on drbd_rs_complete_io
	May 31 17:10:06 192.168.56.101  U15:10:04.337|03431840(sender) drbd_rs_complete_io <3>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x0): drbd_rs_complete_io(,16384 [=0]) called, but refcnt is 0!?

	Did
		sudo drbdadm invalidate w0 ; sleep 1 ; sudo drbdadm down w0
	on Linux side.

TODO: Performance: On much VM, one CPU core (has 2 cores) goes to 100% on sync.
	I assume there is an unneccessary (?) copy somewhere.

TODO: Bug: bio_set_op_attrs <2>[0xFFFFFA80033783B0] BUG: failure

	Maybe this was introduced during code cleanup. Update: no it wasn't.
	The reason is that REQ_OP_FLUSH != REQ_OP_WRITE in windrbd,
	which has to be fixed (they also should be powers of two,
	see comment in win4lin/drbd_wrappers.h:544.

	The bug appears on testing resync.

	Update: Also happened to Devin.

TODO: Bug: test-loop hangs after about 16 iterations.

	format k: sometimes gets stuck when run from test script.

TODO: Code quality: Re-check the WIN32 / WIN64 thing in drbd_endian.h

TODO: Bug: logging to localhost (windows) seems to cause boot problems (?)
	When using 192.168.56.101 instead of 127.0.0.1

TODO: Feature: windrbd show-filesystem should check if device is used as
	a backing device.

TODO: Documentation: drbd-util: Update manpage.
	And write one for windrbd utility.

TODO: Infrastructure: Why doesn't it work on Phil's machine?

TODO: Feature: Mount to NTFS directories.

TODO: Code quality: fix the case where backing device contains a file system.
	It should not blue screen.
	(maybe later, this seems to be rather complex)
	We are now avoiding the case when there is a filesystem
	on an attached backing device. This blue screen should
	be fixed but maybe in a later release.

TODO: Feature: flush not supported by some (all?) devices: currently we
	ignore this (as reactOS also does it). Update: ext2
	file system uses CcFlushCache(): see
	reactos/reactos/drivers/filesystems/ext2/src/flush.c

	Also try to use the ZwFlushXXX function (as Mantech does it)

TODO: Feature: make debugfs work

TODO: Code quality: RCU needs change
	At least call_rcu now calls the function. I don't think
	that it is a good idea to port the linked list thing to
	windows, we want to stay thin..

	Update: talk to phil about current solution (just call
	the function). I don't think that it is a good idea to
	mimic the original intended behaviour in Windows.

	Update: We now call the cleanup / on update function 
	in the call_rcu() function, which makes the thing work.
	Double check if that works as expected.

	Update: RCU should currently cause problems on SMP machines
	only (we always tested single CPU, so this was not a problem).
	Implement Phil's algorithm.

TODO: Feature: on windrbd show/hide filesystem check if attached.

	And refuse to touch it if yes.

TODO: Feature: mandatory locking for backing device.

	This is unclear. Test how backing device is locked right now
	(formatting for example reports that it is in use).

TODO: Test: Kernel really should report an error if Bind() fails. 
	For example if the local IP address does not exist.

	Update: Test if this is fixed now.

TODO: Code quality: review TODOs in source code.

TODO: Performance: Someday we want to pass user level buffer to driver directly
	on READ requests instead of having a temp buffer (needed
	for Windows 10).

TODO: Test: spurious error 5 (ACCESS_DENIED) when reading DRBD device.
	after doing some experiments. drbdadm down / up solved the
	problem.

	Update: still there?

TODO: Test: Fix windows shutdown bug.

	Most likely this was introduced when implementing the
	cleanup() method.

	Update: Not observed lately.
	Update: just reappeared again.

	Update: still there?

TODO: Code quality: Re-port drbd_transport_tcp.c to windrbd's
	drbd_transport_wtcp.c.
	Update: currently it seems that the problem is
	somewhere else. 
	However we need those updates. Best way would be to
	git diff the original drbd transport_tcp to the version
	we had before and apply the patches manually.

	Update: we should integrate drbd_transport_tcp back to
	converted-sources.

	Update: it seems to be doable, but first change the
	wsk2.c API to match the kernel API (Send->kernel_send_msg
	and so on).

TODO: Code quality: rebase drbd_wrappers.h to upstream DRBD

TODO: Feature: when losing Quorum go into read only mode.
	(quorum means that our connected network contains > n/2 
	(n .. total number of nodes) valid nodes.
	This is currently being implemented in DRBD

TODO: Performance: I/O seems to be rather slow even when being unconnected (and primary)

TODO: Research: check out mantech wdrbd and see if it works (and why)
	Update: mantech WDRBD lacks many features we have
	in windrbd most notably: it cannot connect to a
	Linux DRBD. It does not support internal meta disk.

	If there is spare time have a look on it (at least read
	the docs, need Chrome for it (!)).

TODO: Nice to have: Cygwin should have /dev/drbd<n> mapped to
	\\Device\\Drbd<n>

	Right now, we can read/write the windrbd device via
	windrbd-test utility.

TODO: Build system: have a make depend target
	Or at least header file dependencies.

TODO: Feature: Check if it is a network share (currently blue screens)
	Update: blue screen was something else. Should check if the
	drive letter is a network share. Unfortunately they do not
	appear in the \DosDevices directory. If we create a drive
	letter (symbolic link) in the \DosDevices it will be silently
	ignored. Warn the user if it is a network share.

TODO: Feature: One day we want to have a more specific error message
	than Device does not have a disk config if the device or
	the drive letter already exists.

TODO: Code quality: cond_wait shouldn't busy loop. How is this done in Linux?

TODO: Code quality: #ifdef the Windows netlink code in drbd-utils

TODO: Code quality: fix the macro redefinition problems in drbd_windows.c
	For now we have to copy the function prototypes from MSDN.
	Not good style.

	Update: check if the prototypes are still needed.
	Update: we probably reject this.

-------------------------------------------------------------------------

Done: fix patch errors on Linux side build (conversion)
	a make clean did solve it

Done: backup on www.johannesthoma.com

Rejected: install Windows kernel headers
	Is part of EWDK.

Rejected: Download heise Linux Virus scanner CD and check image.
	I tried Desinfec't 2014 but it hangs. Now have Avira 
	inside the Windows machine.

	TO DO: This should start automatically at boot

Rejected: Maybe migrate vdi image to internal SSD

Done: Reboot Mac and see if it is still slow
	Done: Something in the VM config was slow, created a new one

Rejected: Install FreeSshD
	
Done: Install cygwin
	Done, works
	Also installed Dev (GNU toolchain)

Done: Install Visual Studio
	C headers are missing, TO DO: Uninstall and redo installation
	from scratch.	
	Done, works now

Rejected: Reorganize converted sources (have drbd and drbd-headers inside
	a dummy dir, to make it compatible to original layout.

Done: Make it compile under Windows
	Done: Fixed permission errors
	Done: Must work with /cygdrive/z/... mapping (cmd.exe does not
		support UNC names)

	Done: path to cl.exe
	Done: install EWDK (plus prerequisites like device driver
		kit)

	Done: make signing the driver work.
	Done: Make clean and remake to see if it still works.

	Must:
	1.) Run 
		make 
	on the Linux box (from $HOME/Linbit/Work/wdrbd9)

	2.) Run
		make
	on the Windows box (from $HOME/Linbit/Work/wdrbd9 (takes some while)

	3.) Run
		make install
	on the Windows box (from $HOME/Linbit/Work/wdrbd9/converted-sources/drbd)

	4.) Run (in an Administrator cmd.exe Console: to open it go to
		 C:\Windows\System32 in Explorer, Cmd-Click on cmd.exe
		 and select Run as Administrator)
		INSTALL-DRBD-admin.bat

	5.) To load the driver, do (from Adminstrator Console)
		sc start drbd
	DbgViewer will show output. To start DbgViewer go to 
	C:\drbd\DebugViewer and start DbgView.exe as Administrator

Done: Revert to original build layout
	Done: Backported work done in converted sources
	Rejected: Cross compiling coccinelle for Linux (requires ocaml)
		Does not work, Ubuntu OCaml parmap library installation
		seems to be broken.
	Done: see if there is a cygwin package for coccinelle
		No
	Rejected: install ocaml for CygWin
	Rejected: Cross compile conccinelle for CygWin
		If possible, do not try to fix too many things.
	Rejected: make should build everything under Windows

Done: make install should install the driver and activate it
	(Rethink: only install the service User should do 
	sc start drbd manually, since that could crash the
	machine rightaway)

Done: make install should also be possible in top make file

Rejected: Migrate sources to Windows C: drive and build from there
	Maybe then it is faster..but then we need to make tarball and
	the like .. Hmmm.

	Rejected because Windows crashes randomly. It is also better
	to have sources on Linux since step 1 of the build has to be
	executed under Linux.

Rejected: Remove everything with signing (signtool exits with an error)
	We leave it in, even though it does not work. Must start Windows
	with Load unsigned drivers (Press F8 at boot and select bottom
	most entry (Load unsigned drivers))

Done: Insmod
	Rejected: pnputil -a drbd.inf
	Done: currently fails with Permission denied.
		Must run cmd.exe as administrator (Cmd-Click on
		cmd.exe in /Windows/System32)
	Done: try if F8 + load unsigned drivers works.
		Yes it does.

Done: Install DRBD Linux peer VM
	Ubuntu Server? Took Ubuntu 16.04 Gnome edition
	Installed drbd from git repo
	Update: we are using the production VM since not enough
	RAM for running 3 VMs.

Done: Add volume to Windows VM for DRBD test drive.

Done: logging: syslog server (see how it is done)
	Currently checking DebugViewer (but doesn't survive blue screen)

Done: Run DRBD with provided config file
	One Windows one Linux peer, with added Volume as backing
	storage.
	However there are many issues, see KNOWN-BUGS

Done: send public key to upstream

Done: Add build instructions to repo

Done: revert (make invisible) last 3 patches from upstream

Done: git pull last commit

Done: rebase dev branch to upstream master

Done: Merge into 

Done: drbd-adm: For now, have two different entries (NT-style, UNIX style)
	have win-disk and win-meta-disk in addition to UNIX style
	disk device paths. 

Done: Reconfigure drbd-utils with sane paths (/usr/local/etc ->
	/etc) 
	Problem is that drbdadm fails because some path does not
	exist.

Done: fix the syslog printk code to print all messages
	At least partially .. print all messages to the local
	Debugging facility (use DbgView.exe to see them), when
	IRQL is higher than DISPATCH we must not sleep and cannot
	send UDP packets. 

Done: Why does DRBD crash when loaded at boot time?
	Because signature is invalid. Boot windows with 
	F8+Allow invalid signatures.

Rejected: kernel: keep track of opened HANDLEs and struct drbd_block_devices
		(but please not in VOLUME_EXTENSIONs they don't belong there)
Rejected: kernel: Use that handle for I/O on backing device
	This is probably too slow. Keep the current device stack
	approach.

Done: kernel: win4lin: see if symlinks work
	We need to resolve them (ZwQuerySymbolicLinkObject), Done

Done: drbdsetup should translate NT-style pathes to NT kernel internal
	style pathes (this is easy)

Done: drbdmeta should accept NT-style pathes
	Problem is that /dev/sda and /dev/sdb is sometimes
	swapped (see KNOWN-BUGS) 

Done: We need to use NT-style I/O functions for drbdmeta
	(ReadFile, WriteFile) in pread/write_or_die()
	and use NtOpenFile() (need to load address
	from NTDLL.DLL).

Done: Open backing device:
	Need to reboot Windows to make it work. Right now I don't see any
	possibilty to attach to the device stack without rebooting
	(maybe pnp manager can be told to reiterate disk devices somehow..)

Done: For some disk sizes, NtReadFile fails with EOF reached
	(0xc0000011)
	Root kit?
	Update: No, seems to be a NTFS kind of hack. With cygwin it
	works. Our version fails on NTFS partitions (which don't contain
	DRBD meta data anyway), so we can work around it.

	We just print a warning and terminate now.

Rejected: Have NTDLL functions in separate file?
	Without knowing struct format internals.
	We are using WIN32 API which is not that wild.

Done: D: -> \\DosDevices\\D: also in drbdmeta
	Done

Done: check if drbd-utils compiles on Linux.
	No it doesn't. Netlink port was unclean (doesn't #ifdef __CYGWIN__)
	takes some time to repair.

Done: Revert the win-disk patch later to use only 
	NT style disk device paths (win-disk becomes disk, UNIX
	disk device paths are not used any more).

	We need to patch drbdmeta for that.
	Update: Patch is there, need to revert and test.
	Reverted and tested.

Done: printk_syslog(): collect the messages in a ring buffer and send them 
	later.
	Nice-to-have, do that later.
	Done it, it is good to have it for further work.

Done: Locking for ring buffer

Done: IRQ message should go before current message.

Done: printk_syslog(): merge logging functions of
	jt/logging-fixed-and-windows-boots-with-signature-check-disabled
	into master and push

Done: IP address of logging host should be configurable (Registry?)

Rejected: fix driver signature
	Don't know how this works..we now use Windows Test Mode to 
	avoid pressing F8 all the time.

Done: integrate INSTALL-DRBD-admin.bat in Makefile.win

Done: Merge changes to master (including drbd_thread_setup non-static)
	and push.

Done: Frees in Completion routine: is the memory freed by lower level
	driver?
	No it is Paged and accessed in an IRQ routine.
	Update: Now returning MORE_PROCESSING_REQUIRED and the
	blue screen disappeared.
	See https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/constraints-on-completion-routines :
		"After calling IoFreeIrp, the completion routine must return STATUS_MORE_PROCESSING_REQUIRED to indicate that no further completion processing is needed."

Done: fix 0x4e blue screen on drbdadm detach / down
	Last message: 
drbd_bm_resize <6>drbd w0/17 minor 26, ds(Diskless), dvflag(0x2000): drbd_bm_resize called with capacity == 0
	
Done: Make it work with DRBD from September

Done: Do we really need all those IOCTLs?
	drbdcon does not exist in WinDRBD, new ioctls are not 
	needed.

Done: use gtest to write tests.
	Probably for some tests where we need to call Windows API functions.
	Maybe we can extent agruen's test suite to call mini binaries.

Done: What we would need is something that overwrites Windows' default
	behaviour of determining device sizes (when Meta data is
	internal we want to report only the payload size without
	the meta data).

	Update: With the new architecture this comes for free.

Done: Have a lower level device for drbdmeta for access of internal
	DRBD meta data while resource is up.
	Update: with new architecture this came for free.

Done: Have other device extension with only the fields we
	need.

	We now disabled mvolAddDevice (by returning NO_SUCH_DEVICE,
	else we blue screen because some verifier) so volume
	extension does not exist any more (except in non-accessible
	code). 

	Update: maybe the struct block_device should be the windows
	device extension, so we safe a intermediate data structure.

	Update: That's what we do now. While having NT kernel internal
	variables inside linux structures seems like bad design at
	first, it saves a lot of (unneccessary) work. For example
	we now have the offset and io_stat used by 
	win_generic_make_request() internally as part of the struct bio.

	Done: Next thing is to have replacment data structure so
	that attach works again (create block_device with target
	device looked up in find_target_dev). Also get I/O on
	that target dev working (used to blue screen but maybe
	it works now that we do not create a device in AddDevice())

	Update: for DRBD devices device extension is now struct
	block_device. 

	Update: after long research (and with help from a stack overflow
	kernel guru) we solved the blue screen and now do not do 
	AddDevices any more.

	Rejected: check if generic_make_request can use the ZwCreateFile
	API (instead of creating an IRP)
		I/O on the backing devices work now (again) with the
		IRP API.

	Done: remove devices in bdput destroyer.
	Implemented but cannot test it now, it is newer called from 
	drbd_destroy_device (which is also never called).
	Update: calling it now from drbd_unregister_device(). Works.

	Done: bdput in drbd_create_device on failure.

	Done: clean up code, delete commented out code.

	Done: size fix (with external meta data something destroys the
	disk size setting, so that drbdadm up / down only works once).
	Update: this doesn't happen no more.

	Done: clean up block devices created by blkdev_get_by_path().

	Done: keep an internal list of struct block_devices created
	for backing devices (so that internal meta data works again).
	and don't have more than one struct block_device per physical
	partition.

	Works now (again) with internal meta data.

Done: Redesign of architecture.

	Currently the DRBD device is stacked atop of the low level
	Disk drivers. This way all I/O goes through the WinDRBD
	driver also that of the non-drbd drives (like C:, ...).
	An Active flag controls whether I/O is routed through
	DRBD or not.
	
	One major drawback is that once the Active flag is set
	we cannot access the lower device. This is needed however
	by drbdmeta.
	
	We want an architecture that is more close to that one
	of Linux where DRBD devices and backing devices are different
	device objects, even for the Windows kernel.


Done: Try to put I/O on DRBD device.
	This will be the same device as if there was no DRBD (use
	the drive letters).

	Update: Started setting the Active flag automatically from
	within DRBD (currently only at successful attach, later
	also on connect. Somewhere else?).

Done: Unset the flag on down / detach. Or better set it on
	becoming primary, clear it on becoming secondary (let
	DRBD do the checks).

Rejected: Remove check in mvolWrite(): DRBD should do this.

	Update: Currently drbd_open() fails because of some
	auto-promote mechanism that never happens. It seems
	that the synchronisation (wait_event_interruptible()
	and the like) are broken.

	Update: We now try to have a separate Windows device for drbd
	and backing device this is more close to what DRBD under
	Linux does.

Done: Create patches for DRBD for recent changes.

Done: README.md

Done: Submit current sources.

Done: make format H: work

Done: Writing partition table should not fail.

Done: Fix sharing violation problem.
	Currently find_windows_device fails (as it should) calling
	IoGetDeviceObjectPointer() (before it can check the list
	of already open backing devices, these are currently indexed
	by exactly that pointer) because close_backing_dev is currently
	not called on detach. The reason is probably that schedule_work()
	mechanism is implemented wrong in windrbd.

	Update: drbd_destroy isn't called because the rcu mechanism
	is not implemented (or not implemented correctly) in windrbd.
	Do that after 0.2

	Update: sharing violation now fixed, however now there is
	an IO ERROR: neither local nor remote data which is new.

	Update: We now shift the backing device by one sector so
	that Windows NT does not recognize the backing device as
	NTFS (or whatever) formatted. This solution works quite
	well for us and also prevents Windows NT from replaying
	journal before the DRBD device is brought up.

Done: Fix IO ERROR
	It seems to come from an 0xc0000022 (access denied) error
	from the lower level device.

	Update: Error was not propagated to user space, this should be
	fixed now.

	Update: error c0000011 on accessing meta data (end of file
	error) when meta data is internal.

	Sectors are now shifted, see sharing violation problem.

Done: where did the volsize blue screen disappear.
	When using IRPs on an NTFS formatted partition, we had
	blue screens which do not happen any more. This is strange.

	Update: Also does not blue screen when meta data is internal,
	however apply-al does not work (error c0000011 (end of file)
	when reading meta data).

	Sectors are now shifted, see sharing violation problem.

Done: when there is NTFS on the backing device drbdadm up fails
	(with internal meta data) because it cannot access meta
	data.

	Plus there is a blue screen when changing from internal
	to external meta data. (This might be a windows internal
	bug tough).

	Update: No it was something else..Irps don't work with
	getting volsize of an NTFS partition, rewrote it to 
	use ZwXXX() API, now we have problems with sharing
	violations.

	Sectors are now shifted, see sharing violation problem.

Done: DeviceControl (there are many more but those
	are the ones called when the device is opened):

Done: implement I/O handler stubs
	Stubs done, return STATUS_OK (or STATUS_NOT_IMPLEMENTED)

Done: nc test
	Works as expected.

Done: Fix Spurious timeout error on receive.
	Was behaving as intended.

Done: hack test

Done: Make drbd run on peer Linux box
	We cannot run 3 VMs on our Macbook Air since it has only
	4 GB of RAM. Now, we are using the production Linux box
	for DRBD peer.

Done: make drbdmeta be able to read near the end of an NTFS 
	partition.
	We now hide NTFS from windows when it is a backing
	device.

Done: tcpdump nc and drbd and see if there is a difference.
	Didn't find anything yet, however there must be
	something. Look at the packets with hex?

	Update: The packets were received but on the windrbd side
	the 80 byte handshake parameter packet never is received
	(it is sent by Linux DRBD).

Rejected: schedule_timeout_interruptible not implemented correctly.

	It just does a wait on single object with a timeout object. so it
	isn't interruptible.

	If solved then also write a small test for it.
	
	Update: No it can only be interrupted by a UNIX signal
	(which does not exist on Windows) so the implementation
	is correct.

Done: Who is supposed to wake up schedule_timeout_interruptible() in
	dtt_connection_established()?

	Ask phil or lars. Don't want to dig too deep into DRBD now.

	Those two are needed to make connection work.

	Done: Nobody.

Done: Make connection work.
	It seems that kernel_recvmsg() does not receive anything
	from the windrbd side (it fails with an EAGAIN error
	reproducible).
	If DRBD on Linux is replaced by a ncat we can see the
	packets arriving on both sockets: 
ncat -l 7600 -k | hexdump -v
0000000 7483 6702 f1ff 0000 7483 6702 f2ff 0000

	Update: If connection is established in the order
	connect send connect send the first packet is received.

	Done: Write a small C program (with gcc) to test that from user
	mode. 
	It works non-interleaved (is a cygwin program)

	Now, check tcpdump output.
	TCP checksums are wrong but this is most likely due to 
	checksum offloadinng (they are correct on the wire only
	the network card displays it wrong).

	Apart from that the packets seem to be equal (sequence number?)
	Update sequence number is Wireshark connection ID.

	Update: difference is that Linux DRBD upon incoming connection
	tries to reach windrbd which fails because windrbd makes a
	bind but no listen currently. What is strange is that 
	connect() on Linux side succeeds while we see a RST in 
	the TCP packet coming from windrbd (but that is maybe
	because the socket is non-blocking on the Linux side).
	
	We now patch Linux DRBD so that connect(2) always fails and
	see if that works.
	Update: unfortunately this did not fix the error.

	netcat on the windrbd port shows that connection is
	accepted(?) but closed immedieately

	Update: No packets get lost. The initial packets are received
	and the 80 byte handshake packet is sent to windrbd.
	However there it is never received (drbd_recv_short
	is never being called by windrbd). So the whole
	thing was because receiving the handshake packet
	(80 bytes) is not implemented on the windrbd side.

	Rejected: write 2 C (user space) programs that show how this
	scenario looks like in POSIX environment (bind without listen
	and connect returning 0)

	Update: Reasons were:
		ping timeout was set incorrectly.
		peer (Linux) disk was too small.

	So in fact it always worked. Arghhhh!


Done: blkdev_put isn't called on drbdadm down

	fix this one day, this is probably a DRBD9 bug. Or maybe
	it is intentional.

	INIT_WORK and schedule_work do what they say?

	Later: Currently bdput is called from within drbd_unregister_device,
	ask phil if that is ok (it should make the device invisible, which
	is what it does).

	Update: this is something with RCUs

	Update: call_rcu now does something, is this fixed now?

	Update: Yes it is. Closed.

Done: Possible race at drbd_thread_setup() (drbdmain.c:567) with
	use-after-free.

Done: implement open and close methods.

Done: Right now, windrbd isn't listening for incoming connections.

	Connection should work nevertheless.
	Update: setting event mask correctly now, incoming
	connections work (tested with disabling outgoing connection,
	the DRBDs eventually connect anyway).

Done: eliminate bio_databuf fields.

Done: Have sshd on Windows and work remotely
	Would be convenient, however setup is a little bit
	complicated ...
	This is a nice to have.

	Yes it works. Needed to add a /etc/groups file with
	correct contents.

Done: errnos should match linux error codes
	(so that errno cmd line tool works).

Done: get cygwin chmod working.

Done: Implement multi page I/O

	Required for DRBD sync

	Currently fixing some blue screens: on multiple page I/O
	one issue was fixed (length of first MDL was wrong), now
	when doing a:

	drbdadm up
	drbdadm cstate == connected
	drbdadm down

	we crash (PFL something)
	when we do

	drbdadm up
	drbdadm cstate == connected
	drbdadm detach
	drbdadm disconnect
	drbdadm down

	everything works. So disconnecting when we have a backing
	device is what doesn't work. Also:

	drbdadm up
	drbdadm cstate == connected
	drbdadm disconnect

	Crashes on disconnect

	Update: Reason most likely a buggy implementation of
	mempool_free() in windrbd. (see drbd_bitmap.c:drbd_bm_endio
	around line 1074: if that line is commented out, no
	crash). mempool_free probably should not free the page
	itself, have reference counting on the page.

	Update: Problem fixed for now. The real problem is the
	question of who owns the memory pointed to by the MDLs.
	There seem to be other instances where the DRBD endio
	routine frees memory and also if we comment out MDL
	freeing we get a blue screen when syncing (at the end
	of format h: command).

	Update: We still have I/O errors however BSODs are gone.
	We now check if MDL has MDL_PAGES_LOCKED set (which is
	only the case for the first entry) before calling
	MmUnlockPages().

	TO DO is to check where the I/O errors come from.

	Jan 11 15:25:13 192.168.56.101  U14:24:54.369|0131bb50 __drbd_chk_io_error_ <3>drbd w0/17 minor 5, ds(Failed), dvflag(0x2c): Local IO failed in __req_mod. Detaching...

	Update: fixed. Was a wrong bi_vcnt in irp_to_bio (windrbd
	toplevel device object (H:)).

Done: windrbd-test destroyed (!) partition table?
	Yes it does (set_partition_info test). Now protected by
	an interactive query (unless --force is given).

Done: make write_whole_disk test work.
	Only fails when connected. Works when primary and disconnected.

	Update: stalls at sector 73924 when primary and disconnected.

	Update: connection fails from time to time and we need to
	reconnect.

	Update: works when unconnected (except the aforementioned stall,
	which we cannot reproduce at the moment).

Done: all I/O should fail when Secondary
	Important.
	Done. format h: however does not display an error (but
	this is a format problem, the data on disk is unchanged).

Done: Throw away lots of Mantech code.
	Mostly done.
	Get rid of PVOLUME_EXTENSION as well.
	Done

Done: Release backing device:
	drbdadm up / drbdadm down / format f:
	Not clear what this means. It works for me.
	Reopen that when it bites.

Done: test external meta data
	Currently running with external meta data

Done: write sometimes stalls when there is too much logging.
	Solved: this is a bug in VirtualBox (network is down
	and write test runs from network share).

Done: Cannot mount NTFS after sync.

	johannes@johannes-VirtualBox:~/Linbit/tmp$ sudo mount /dev/drbd26 -t ntfs mnt/
	ntfs_mst_post_read_fixup_warn: magic: 0x00000000  size: 1024   usa_ofs: 0  usa_count: 65535: Invalid argument
	Record 0 has no FILE magic (0x0)
	Failed to load $MFT: Input/output error
	Failed to mount '/dev/drbd26': Input/output error
	NTFS is either inconsistent, or there is a hardware fault, or it's a
	SoftRAID/FakeRAID hardware. In the first case run chkdsk /f on Windows
	then reboot into Windows twice. The usage of the /f parameter is very
	important! If the device is a SoftRAID/FakeRAID then first activate
	it and mount a different device under the /dev/mapper/ directory, (e.g.
	/dev/mapper/nvidia_eahaabcc1). Please see the 'dmraid' documentation
	for more details.

	Update: It seems that somebody writes to the DRBD device (what we
	did is write it while unconnected, then copy drbd device on windows
	to a file and then connect the DRBD to linux wait until sync is
	finished and then copy the Linux contents to a file and diff the
	hexdumps of both files). Either Sync is broken or somebody writes
	the device where he shouldn't. Update: windows data seems to be
	correct, so sync is broken.

	Strange: DRBD does not sync while all bits are set in bitmap.

	Update: when copiing the dumped DRBD block device from windows
	to Linux, it also fails. Maybe the Linux NTFS driver is buggy?

	Update: when using external meta data and copy the backing
	device (F:) via scp we can mount the NTFS partition with
	ntfs-3g (Update: also with mainline kernel ntfs driver)
	The backing device must be patched so that where it says
	DRBD it should read NTFS in the boot sector (can be done
	with vi).
	It is clear that copiing the DRBD device (instead of the
	backing device) does not work because Windows hides the
	last 8 sectors.

	Update: It seems that the invalid pages point to somewhere
	where windows kernel alloc tags (like WD4E, E4DW in the source
	code) are. So we have an invalid pointer (use after free?)
	problem.

	Check if all pages are transferred first and then validate
	the pointers.

	Test was made with write-test.sh not with NTFS (so NTFS
	driver isn't the problem)

	Update: Problem was that Length of I/O was only the first
	MDL entry not the total length. Should work now. TODO:
	test with NTFS.

	New blue screen: IoBuildPartialMdl was called with a
	virtual address outside the range of the source Mdl.
	When syncing.

	When restricting max number of MDLs to 16 we do not
	blue screen but data is corrupt (at offset 0x1000
	which cannot be explained by the 16 MDLs limit).

	Update: we have 3 errors here: one is that we cannot
	read more than 64K (16 Pages/MDLs) without blue screen
	one is a page fault blue screen (which does not always
	happen) and one is a data corruption between
	DrbdIoCompletion and sending the packet.

	Update: error #3 (data corruption is because 
	_drbd_send_zc_ee is wrongly patched by windrbd. 
	Undo this patch and it should work. Update: yes
	it does.

	Update: Mount works now. Error #2 (page fault blue
	screen) is most likely fixed. Error 1 is TO DO.

	Update: NTFS mounting works now, however there
	is a blue screen when reading more than 64K
	from the backing device. Making seperate TODO.

Done: BSOD sometimes when syncing

	Update: New blue screen page fault in non paged area
	(when waiting before connecting) Update: this is probably
	fixed by locking all the pages into memory. Observe
	and reopen this if it happens again. Update: happened
	again.

	Update: the page fault in non paged area BSOD reappeared
	(while Syncing).

	Update: again, while syncing (2 times in a row)

	Update: again, while syncing (and not freeing pages)

	Update: Fixed something in drbd_main.c this should
	not happen any more. Reopen when it occurs again.

Rejected: fix freeing bio without irp.
	Not to fix. DRBD sometimes allocates bios without ever
	calling generic_make_request on them.

Done: fix memleak in getting volsize.

Done: use after free blue screen after patching bio split in.

	When not freeing mdls and irps and not freeing the bio
	it disappears. Not putting the bio in upper device does
	not help. Nor does not freeing the buffers themselves
	(in __free_page()).

	Now holding reference to bio in generic_make_request this
	seems to solve the problem.

Done: Cannot read more and 64K (16 MDLs) from backing device.

	Blue screen shows STOP: 0x0000012E (0xFFFFFA80037AD980,
	0xFFFFFA80039951A0, 0xFFFFFA800669F000, 0x0000000012000)

	Update: According to:
	http://osronline.com/showThread.CFM?link=204514
	this is a known bug in some Windows versions (esp.
	Windows 7 Professional 64 bit), while it works
	in other versions. We should restrict the number of
	sectors read/written to max 128 and test this on various
	windows versions.

	Update: not possible to patch DRBD not to use more than
	128K because this is an over the wire parameter (would
	have to patch linux DRBD as well). Implement solution
	that splits the bios into smaller pieces.

	Update: its 128K (32 pages) according to our experiments.

	Update: Implemented but currently leaks IRPs.
	Update: fixed leak seem to work ok (except blue screen
	when formatting and drbd is connected). This is now a
	separate TO DO since it also happens when doing something
	(writing) to the DRBD device and the resources are connected.

Done: Network goes down while sync. When syncing an NTFS partition only.

Jan 20 12:46:05 192.168.56.101  U11:46:05.795|0393cb50 find_request <3>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x2): receive_DataReply: failed to find request 0x136c6c00, sector 26160s
Jan 20 12:46:05 192.168.56.101  [last message was in IRQ context]
Jan 20 12:46:05 192.168.56.101  U11:46:05.795|0393cb50 drbdd <3>drbd w0 pnode-id:1, cs(Connected), prole(Secondary), cflag(0x200a), scf(0x1): error receiving P_DATA_REPLY, e: -5 l: 4096!

	This seems to be fixed by the > 32 bio_vecs patch.

Done: check 2 patches using bio_databuf
	bio_databuf is gone. So are the patches.

Done: with DRBD: 500 kB/sec (unconnected) without 900 kB/sec
	500 kB was with lots of debug output. Now we have 600 kB/Sec
	a bit better.
	without DRBD: 983.71 kB/Sec
	with DRBD (unconnected): 586.25 kB / Sec

	Update: with 1Meg write requests it is very fast. So
	the problem seems to be the OS overhead (both DRBD
	and NT kernel)

Done: The functions enclosed by _WIN32_MVFL (see win4lin/src/util.c) are
	not referenced anywhere in the code. I assume that they never have been
	tested. I would like to remove them (or at least rewrite them if the
	functionality is needed) since they depend on some other stuff I would
	like to redesign.

	Update: We need the functionality if DeviceIoControl() (user level
	function) is called on the DRBD device. So leave it in for now.

	Update: We don't want any DRBD specific DeviceIoControls. Check if
	one of those are really needed and then remove the code.

	Done. We removed about 4000 lines of code.

Done: drbd w0 linbit-wdrbd: error receiving P_RS_DATA_REQUEST, e: -22 l: 0!
	Update: didn't observe lately (with 0.3.7) but I am
	pretty sure it is still in there.

	Hopefully fixed by multiple requests patch.
	Update: No it isn't. Just happened while Windows was SyncTarget.

	Update: bm_op was returning unsigned long instead of 
	ULONG_PTR. Fixed by patching DRBD.

Done: Test windows being SyncTarget
	Works now, error receiving P_RS_DATA_REQUEST was fixed.

Done: PFN list corrupted when connected and I/O is on windrbd device
	Just reappeared again when sync completed and windrbd was
	SyncTarget.

	Update: We now unlock the mdl page's memory created by
	IoBuildAsynchronousFdsRequest() right after creating the
	Irp. Furthermore we now use MmBuildMdlForNonPagedPool()
	since the page memory is from NonPagedPool. It seems to
	work now. Please reopen when blue screen happens again.

Done: IRP_MJ_SHUTDOWN (0x10) not implemented.

	Update: Implemented but does not get called if we
	never access the DRBD device. This functionality should
	be in a one time called function.

	Update: shutdown done when the root device object is
	shut down (exactly once).

Done: it seems that free_page crashes sometimes (0x1E)

	Reactivate the hack to see if it crashes there.

	Update: No free_page is ok. Crash is because there are
	still drbd resources on line while we free all buffers
	(which is generally not a good idea). For now don't do
	anything on shutdown, we should see how Linux DRBD behaves
	on forced system shutdown.

Done: logical block sizes do not match (me:512, peer:0); this may cause problems.
	Fix this (should be easy)

	Update: Reenabled assign_p_sizes_qlim() in drbd_main.c
	this should have fixed it.

Done: data corruption when doing a 

	cp /dev/urandom /cygdrive/h/random-file

	and diff it against the synced linux ntfs.

	Maybe this is a sync error.

	Update: bio->bi_sector was set wrong when splitting
	the bio in generic_make_request. Is fixed now.

Rejected: compile user space apps with MinGW
	Isn't meant for POSIX apps

Rejected: Error receiving P_STATE on Linux on split-brain.
	Phil says this is normal

Done: Test with Windows 10 (we have to do that anyway some day)

	Installing to Linbit supplied test machine.

	Driver loads (with TESTSIGNING ON) userland currently fails 
	to find POSIX root (/) dir (/etc/drbd.conf not found).

	Update: works. When accessing windrbd device (dir h:) it
	blue screens
	Update: Blue screen fixed.

	Connection currently unclear (error receiving initial packet).
	With netcat a TCP/IP connection works.

	Update: Was a split brain.

	Except for a sync instability windows 10 now works as good
	as windows 7 (including logging)

Done: Fix logging errors

Done: Have DRBD and windrbd release number in log and properties of driver

	Review. And there is a bug in printk() ring buffer which causes
	corrupt initial log messages.

	Put DRBD and windrbd version number in 1. dialog of self extracting
	exe

Done: make install package
	self extracting exe or msi file.
	Know how to do it (iexpress.exe) do it properly once
	everything else is done.

	Works almost .. we however have to compile user space utilities
	with MinGW, which would use native Windows DLLs. Currently
	bundling with cygwin fails because the POSIX root (/) cannot
	be set to the cygwin path.

	We should switch to msi based install. Or at least get rid
	of the Must reboot now panel, because userland tools are installed
	later.

	Check the GPL line feeds.
	Get rid of reboot now message (change type of driver?)
	Make userland use C:\windrbd as cygwin root (take care not
	to destroy existing Cygwin installations)

	Update: setting StartType to 3 (on demand) makes windows not
	boot. Try this with a freshly installed windows.

	Also blue screens on a virgin windows (well almost..) we
	skip this for now and try again later.

	For now, self extracting exe should be fine. But install
	userland before reboot message appears.

Done: Install userland before driver
	So we can safely reboot.

	This is now done by calling infdefaultinstall from
	within the cmd script (as last command). infdefaultinstall
	needs a path (even if it is the current working directory,
	so do infdefaultinstall .\drbd.inf

	Eventually we want to have msi.

Done: install c:\windrbd filesystem hierachy

	Had to include cygwin's unzip (plus an extra DLL) in package

Done: Remove most registry keys.

	Also do not create them on installing windrbd.

Done: In progress: reinstall windows 7 and check if last 4096 bytes in NTFS
	are still hidden.

	They seem to be under Windows 10.

	Update: Need cygwin to run tests (else WriteFile will always
	fail with error 87 Invalid Parameter, even on a newly created
	partition when running from cmd shell). However I/O returns
	5 (Access denied) when accessing an NTFS partition. So the
	answer is yes.

Duplicate: Logging Eventlog? windrbd server localhost UDP.

Duplicate: In progress: allow user to pass name of symbolic link created
	(i.e. the drive letter) via drbdadm/drbdsetup/kernel

	Update: This should be userspace-only. It should
	also be possible to mount the device upon an
	empty NTFS folder (later).

	At this point also clean up drbd-utils (separate
	files for UNIX and Windows) and integrate upstream
	changes (later).

	Update: we wait for our patched drbd-headers to
	appear on github.

	Update: Created windrbd utility that does it. For now
	users have to execute it manually (it creates drive letters
	only for the user that runs the script which might be
	confusing since drbdadm usually runs as administrator).

	Later, remove the drive letter magic from the kernel driver.

	Nice-to-have: a list-drive-letters command.

	Update: find out how to set drive letters visible to
	all users.

	Update: syntax is:

	device "l:" minor n

	which is quite intuitive

Done: Windows to Windows test: blue screen on both sides on drbdadm up

	Is when backing device contains an NTFS filesystem (which
	is normally not the case, but it shouldn't blue screen).

	Maybe it is in general not a good idea to attach to a backing
	storage containing a file system, because this means that the
	user has done something wrong. (We are patching NTFS<->DRBD,
	so a valid windrbd NTFS contains DRBD as filesystem magic)

	Update: when there is a file system on the backing device
	Windows still crashes.

	We now refuse to attach backing device when it contains
	a file system. Formatting an attached file system currently
	force detaches the device, this is not exactly what we want
	There should be a mandarory locking preventing all I/O
	(except DRBD) on the backing device. Do that later.

Done: When playing with show / hide filesystem blue screen on attach.
	1D (1E?)

	Occured again. Please fix this.

	drbdadm up w0 		# fails to attach
	windrbd hide-filesystem f:
	drbdadm attach w0
	drbdadm primary w0
	ls /cygdrive/h		# blue screens

	Windows seems to cache the file system separately (something
	like Linux' directory cache). Solution would be to unmount
	and mount again it on hide-filesystem (already tried manually
	with mountvol utility). Update: there seem to be some sort
	of reread filesystem mountvol delete does.

	Update: Obviously our patching NTFS <-> DRBD of the filesystem
	bootsector at offset 3 isn't enough .. we need to patch more
	than that. Update: no it isn't. Need to call mountvol to
	remount volume, works now with Windows 7 Windows 10 unclear.

	Reopen when it happens again.

Done: windrbd hide-filesystem <drive-letter/GUID>
	also show-filesystem and filesystem-state
	no GUID yet.

	In progress: umount / mount Volume on hide-filesystem
	to clear windows directory cache (else drbdadm
	up / drbdadm primary / accessing the windrbd device
	will blue screen)

	We now call mountvol directly, it works on Windows 7
	but not (always) on Windows 10 (but maybe this is
	another BSOD)

Done: windrbd log-server -o logfile

Done: Use Linbit certificate to sign driver.
	It should be trusted.

	We have a certificate now, but the root of this certificate
	isn't trusted by Windows 7.

	Phil is currently trying to get a proper certificate.

	Update: Works now, but build / sign process is a little
	bit clumsy. Need to copy files manually and patch
	Windows Makefile.

Done: Don't install cygwin1.dll when cygwin is found on the target.

	Now, taking cygwin1.dll from existing installation. Done:
	Test if this works.

Done: IP address of "Closing unexpected connection" printk is still wrong

Rejected: also test with 32 bit version of Windows 7
	(does it exist for Windows 10?)

Done: clean up the registry
	Except for logging IP we don't need anything IMHO

Done: windrbd.exe hide-ntfs-partition

Rejected: We want to see the syslog output when the system did boot, not
	only when we configure a DRBD device.

	This is sometimes practical.

Done: Implemented flushing for WinDRBD device.

Done: hide backing device from Windows on attach.
	This can (?) be done from user space by including
	windrbd hide-filesystem automatically on drbdadm attach
	(and maybe show-filesystem on drbdadm detach).

	Doing it from kernel does not "add value" .. it would just
	be extra effort (and might fail, since we had troubles
	with ZwCreateFile()).

Done: windrbd show/hide filesystem also with GUIDs.
	
Rejected: show filesystem on drbdadm down (not on detach).
	Instead instruct the user how he could do it.

Done: most windrbd command should also take GUIDs (show-filesystem, ...).

Done: drbdadm should call windrbd to assign the drive letter

Done: remove 'C'+minor magic from kernel
	Maybe: generate a GUID in kernel and create a Volume{GUID}
	entry. So we can assign the drive letter for all users.
	Update: create a GUID once and hardcode it in the driver /
	windrbd utility.

	Update: implement IOCTL_MOUNTDEV_QUERY_DEVICE_NAME
	to return /Device/Drbd5, and check if this is being called.

	Update: have to register device with mount manager, which
	currently fails with invalid device request.

	Update: have drbdsetup new-minor --mount-point parameter
	now, drbdadm uses the device name for the mount point.

Rejected: assign-drive-letter should assign drive letter for all users.
	Still there, but we are not using it. Now there is an extra
	field mount-point in new-minor. 

Rejected: delete drive letter also on drbdadm down.
	Problem is that on down there is no volume. Maybe we have to
	iterate over all volumes.
	Superseded by mount-point flag in new-minor.

Done: drbdmeta called before hide-filesystem and fails
	(on drbdadm up / format f: / down / up)

drbdsetup new-resource w0 2 
drbdsetup new-minor w0 5 17 --mount-point K: 
drbdsetup new-peer w0 1 --_name=ubuntu-gnome --use-rle=no --protocol=A 
drbdsetup new-path w0 1 ipv4:192.168.56.101:7600 ipv4:192.168.56.103:7600 
drbdmeta 5 v09 F: internal apply-al 
windrbd -q hide-filesystem F: 
drbdsetup attach 5 F: F: internal 
drbdsetup connect w0 1 

	should be 

windrbd -q hide-filesystem F: 
drbdmeta 5 v09 F: internal apply-al 

	Update: Done, but this is still invalid. After formatting
	the backing device, meta data gets destroyed. Need to redo
	a create-md.

Done: Cannot format virtual drive.
	Regression introduced recently (right before windrbd-0.6.0)
	
	Impletented Done: test it when we have internet again (just
	format k:, should run without error), works

Done: up / down: down fails with failed to detach
	Fixed, was problem drbd_release() when drbd_open failed before.

Done: Blue screen when opening windrbd_control (root device object)
	with WinObj

	DriverVerifier expects IRP requests to succeed (at least create
	close and cleanup)

Done: receive_DataReply: failed to find request 0x1a186c00, sector 25896s
	When writing on Windows DRBD.

Done: error receiving P_RS_DATA_REQUEST, e: -5 l: 0!

	On windows side when syncing.

	Also:

	linbit-wdrbd: error receiving P_STATE, e: -5 l: 0!
	on windows side on connection establishment.

	Update: The later is because of a split brain. For now
	resolved it by re-creating meta data in the Linux side.

	Update: this seems to be correlated with the data corruption
	bug. Update: no it isn't data corruption happened when accessing
	the backing device.

	Update: it is also (or only) on Linux side.

	Update: error receiving P_STATE on split brain should also not happen.
	But low priority.

	Update: this error is not so critical, do that later

	Update: peer has no local data:

Feb 14 16:08:05 johannes-VirtualBox kernel: [ 4722.510438] drbd w0/17 drbd26: Can not satisfy peer's read request, no local data.

	So maybe this behaves as expected.

	Was typedef char bool which caused is_write_request() to
	always return 0.

Done: blue screen on writing while connected.

	Also reported by Devin.

	Reason is (most likely (Update: yes that was it)) that
	the bi_vecs contain elements bigger than PAGE_SIZE which
        isn't supported by DRBD (when it comes to sending pages).
        On fixing this (at windrbd level, see irp_to_bio) we
	introduced a new error which causes formatting to fail.

	Update: Fixed a bug that caused formatting to fail.
    
	But not the read/write tests of our testsuite..we probably want
	to cover this case too. Formatting works now, as well as writing
	to windrbd device while it is connected (also writing on the
	remote side while being connected works).

Done: remove the #ifdef _WIN32 defines

Done: Segmentation fault on drbdadm invalidate

	drbdadm invalidate-remote works.

	Should be fixed, was easy.

Done: drbdadm del-minor should not call windrbd delete-drive-letter
	any more.

	Check if this is needed and remove that code if not.
	Done, removed. I don't think we still need this.

Done: new blue screen running (new) test.sh
	driver verifier again. Peer is not running (no connection)
	Reason was a missing IoCompleteRequest on windrbd_ioctl()
	when device was already deleted.

	Tested, no blue screen.

Done: DRBD windows to windows sync is very slow.

	Not clear if it is the network or something else.

	Update: it is not the network.

	I/O on Windows 10 is very slow also (format h: on a
	connected resource takes forever)

	Update: when connecting to windows build host it is
	faster (network is over the air), so maybe something
	with the Linbit Windows VM is wrong.

	Update: Devin (Linbit USA) also reported this.

	Update: Something between drbd-9.0.9 and drbd-9.0.13
	has been fixed to solve that (it is slow between a 
	9.0.9 and a 9.0.13 under Linux also (in one direction), 
	upgrading 9.0.9 to 9.0.13 solves that so it is fast in
	both directions). Also put

        disk {
                c-max-rate 4048000;
                c-fill-target 1048000;
        }

	into w0.res (at resource config level) on both sides.
	Then it should work. TODO: upgrade windrbd to 9.0.13

	Done, with 9.0.13 Sync is faster (14MB / sec instead of
	4 MB / sec), should be 50 MB / sec however.

	Update: between much VM (Windows 7) and Windows 10 sync
	rate is still at 200 kB which is way too less.

	Some printk's for researching slow sync show that requests are sent
	by 4k (instead of up to 1m) from the windows side (if windows is
	SyncTarget). Fix that and see if it is faster, then.

	Compared to Linux/Linux sync it is then still slower (about
	a factor of 3 or 4) maybe because Windows I/O is slower?

[ 3979.671662] KARIN cmd: 9 sector: 14336 size: 1048576
[ 3979.671665] KARIN cmd: 9 sector: 16384 size: 32768
[ 3979.780097] KARIN cmd: 9 sector: 16448 size: 32768
[ 3979.780121] KARIN cmd: 9 sector: 16512 size: 65536

	Windows sometimes stucks when replying to data requests (11ms
	pause).

	Update: Initialize max_hw_sects in queue.

	Now resync requests are sent in chunks of (up to) 1M which makes
	resync much faster (was 4K chunks, because max_hw_sects was 0).

	Right now, resync between Windows and Linux is still a bit slower
	(factor 4) than beween Linuxes, this is maybe because the I/O
	stack is slower under Windows (?).

	Update: Between win7 (much VM) and win10 sync gets stucked
	now (number is 0)

	Update: Research showed that when called via drbd_submit_peer_request()
	I/O on the backing device is very slow (reading 512kb takes over
	one minute). Dig deeper into the windrbd implementation and
	see why endio arrives so late (SyncSource was a Windows 10 box)

	Update: We found a performance leak in the Send() (wsk2.c)
	function. It completes synchrouniously, throughput is
	2 MBit/sec (4096 bytes / call). When switching to asynchronous
	completion this raises to 27MBit/sec. Problem is: how to
	free buffer memory (should be done by put_page(), however
	this is not implemented yet), and, much worse, error
	reporting (don't know yet how to solve this).

	Update: we had a version that worked (with SendPage()?) find
	it again. Update: Yes that was the working version. It performs
	well on our test setup (syncing with 100MBit/s, which is on
	the VM side the maximum). However there is a blue screen
	on PingAck didn't arrive in time (see separate TODO) plus
	one or two additional memory leaks. Performance problem
	seems to be fixed now.

Done: Memory leaks on SendPage()
	doing a put_page and MmUnlockPages()

Done: SendPage on sync always sends the same page.
	Probably there is data corruption.

	Update: No it isn't. Linux sendpage() has no callback,
	however uses get_page / put_page to keep the page allocated
	as long as it is needed. DRBD uses the page counter
	(page_count()) to detect this and does not touch pages
	with page_count > 1 (see drbd_peer_req_has_active_page()
	in drbd_int.h). windrbd's SendPage() works just the same
	(regarding get_page / put_page), so DRBD shouldn't re-use
	pages that are currently used by SendPage.

Done: Both sides are SyncSource??
w0 role:Secondary
  volume:17 disk:UpToDate
  linbit-wdrbd role:Secondary
    volume:17 replication:SyncSource peer-disk:Inconsistent
        done:0.00

	Same on other side.

	It seems that DRBD 9.0.13 fails to detect split brain
	correctly (downgrading WinDRBD to DRBD 9.0.10 detects
	the split brain). That seems to be an upstream problem.
	Report? 

	Update: No, upstream already fixed that. Upgrade to
	9.0.14.

Done: upgrade to 9.0.14
	9.0.13 fails to detect split brain correctly.

Done: Create file with version number

Done: patch_boot_sector: DRBD signature on peer.
	Should only be on backing device, never on the wire.

	Not when Syncing, only when formatting while connected?
	Yes. Make a temporary copy of the boot sector when writing
	in windrbd_generic_make_request(). Do not modify the bio's
	buffer directly, this might also be the Page Cache (or whatever
	this is called on Windows) of the file system which causes
	format to display the weird Boot sector invalid message.

	Update: implemented, weird behaviour when extra field is
	put after io_status (see separate TODO). It seems to work
	now (formatting while connected does not copy DRBD signature
	to peer).

Done: Check in install script if it runs as adminstrator.

	I just ran into that ... it fails silently.
	Update: Now we check in cmd script, but eventually it
	should check earlier. We should switch to something
	sane anyway some day (msi?)

Done: Do not display Please reboot .. when installation is finished.

	INF install already does this.

Done: Device FFFFFA8004F2D4C0 accessed after it was deleted.
	Strange.

	Because we didn't unmount (dismount) the volume on drbdadm
	down. Should be fixed now.

Done: what is PnP minor 7 code?
	It is IRP_MN_QUERY_DEVICE_RELATIONS with TargetRelations what
	we are being sent. Currently handling this (correctly, as I
	assume, copiied that from reactos kernel) gives a BSOD.

	See PnP TO DO for more on this.

Done: On formatting: error message cannot write NTFS boot sector.
	Fixed. DRBD signature was also promoted to peer, which
	also shouldn't happen (also fixed).

Duplicate: Create windrbd device on becoming primary and delete
	windrbd device on secondary.

	Update: drbd_create_device needs to assign a valid
	this_bdev. Do not create Windows device in bdget, 
	instead create it on becoming primary and delete
	it (with checking for open references) in becoming
	secondary. This way we do not support auto promote
	(because the block device cannot be opened) but
	that is not so important.

	Update: Phil wants the auto promote feature (for
	virtualization), so alternative would be to
	patch the boot sector as long it is secondary. 
	However this does not solve the read cache problem.

	Update: Right now, we return IO error if a secondary
	resource is accessed via ReadFile/WriteFile. Eventually
	we want to declare the secondary resource offline
	but not sure yet how to do this.

	Rethink this and do that later.

Done: Windows 10 would require more testing.

	Blue screen THREAD_EXCEPTION_NOT_HANDLED when writing data
	while connected (on a NTFS filesystem). Maybe because of
	extensive logging. Update: happened again last log message
	is:
Feb 20 19:04:48 10.43.8.215  U18:04:48.392|51a96700 windrbd_thread_setup <6>[0xFFFFD40351A96700] stopped.

	maybe the rcu?

	Accessing directory (reading) from windrbd device stalls
	when connected (and syncing). Writing data works (but
	that is maybe just in the cache).

	Syncing is very slow at the moment.
	This is most likely a network issue (non-windrbd issue)

	Update: The above issues should be fixed now.

Done: upgrade DRBD to 9.0.12

	So Need Access to up to date data on drbdadm down is fixed.

Done: Cannot write first sector on format h:
	Sector seems to be alright (showing DRBD on the backing device
	and NTFS on the windrbd device). Not sure where this is coming
	from.

	Fixed. Needed to copy on write before patching.

Done: Device FFFFFA80038B03F0 accessed after it was deleted.
	After formatting and drbdadm down

	Fixed. Needed to FSCTL_DISMOUNT_VOLUME it.

Done: check what _WIN32_DEBUG_OOS is really doing.
	Dumping bitmap?

	Removed.

Rejected: have dump_stack function
	We don't have symbols.

Duplicate: Also allow for mounting windrbd device to NTFS folder

Duplicate: make ssh to Windows box work

Rejected: make windrbd use existing drbd-headers.
	Update: we made patches to the protocol (mount_point) and
	hence need a separate windrbd branch of drbd-headers.

Done: BSOD From Devin: kref_debuf_destroy ASSERT FAILED:

	2018-05-17T13:30:09.567725-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) bdget <6>Created new block device \Device\Drbd0 (minor 0).
	2018-05-17T13:30:09.569841-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:ASSERT FAILED
	2018-05-17T13:30:09.569841-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:object of class: device
	2018-05-17T13:30:09.569841-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:  [1] = 1 (struct drbd_peer_device / free)
	2018-05-17T13:30:09.569910-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:

	Causes (?) BSOD later.

	Update: No, but the BSOD was due to incorrect cleanups.
	Fixed now.

Done: fix kref_debug_destroy asserts should mounting fail.
	They do not hurt, but are ugly.

Done: check if one can build windrbd branch of drbd-utils from github.
	Waiting for Roland to push.

	Roland pushed windrbd (both drbd-headers and drbd-utils) and
	it works like a charm.

Done: Inform windows about new drive.
	So that explorer opens.

Done: Cleanly unmount windows NTFS on drbdadm down (or, later,
	drbdadm secondary).

	Currently, on drbdadm primary we get a panel showing 
	unclean filesystem. Also when mounting under Linux,
	it shows a warning. Chkdsk however works, and finds no
	errors.

	Update: Done, call windrbd_umount() on state change
	Primary -> Secondary *while still primary* (so that
	I/O still happens during unmount).

	Linux now does not complain about unclean shutdown.

Done: race on umount

	Just to be sure, delete the symbolic link once volume
	is opened for sending it the umount fscntl.

Done: invalidate read cache when becoming secondary.

	Problem is that if windows is primary, becomes secondary and
	then primary again the read cache is still filled from the
	former primary.

	Should invalidate when becoming secondary: reason is
	that while secondary requests still are served from
	the read cache (they should fail).

	Update: Moving that to beta2 because we are a little bit
	short on time. Document that defect.

	Update: Implement this for the next beta, there should be
	no windrbd device unless resource is primary.

	Update: It already works with mounting on becoming primary
	and unmounting on becoming secondary. Need to restructure
	code a bit because currently the block device is the
	Device Extension of the Windows device object (and not
	referenced somewhere else).

	Update: now creating windrbd device immeadiately before
	mount it (when becoming primary) and remove the device
	right after unmounting it (when becoming secondary).

	Works now as expected.

Done: mountmanager / register device with PNP

	Drive letter (mount point) is created now.

	Right now, need to log in / log out to make windrbd drive
	visible in explorer.

	Need to have a valid DeviceNode (that is attach it somewhere
	in the PNP device tree). It does not work to attach it to
	the backing device (backing device then becomes invalid and
	BSODs)

	This seems to be a little bit more complicated than expected..
	maybe attaching the windrbd device to the root device object
	helps? (But root device object also does not have a device
	node). Update: fails with PNP BSOD.

	See Microsoft driver samples for how to do this.

	Update: Most driver samples build atop of Windows driver
	framework, we use Windows device model.

	Update: We are now getting PnP IRPs when calling
	ZwFsControlFile( ..., FSCTL_DISMOUNT_VOLUME, ..); According
	to MicroSoft documentation, PnP manager does not send
	IRP_MJ_PNP unless anybody in the system (driver / user app)
	registers for PnP events (using IoRegisterPlugPlayNotification()
	for example).

	See https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mn-query-device-relations:

	Warning A device object cannot be passed to any routine that
	takes a PDO as an argument until the PnP manager creates a
	device node (devnode) for that object. (If the driver does
	pass a device object, the system will bug check with Bug
	Check 0xCA: PNP_DETECTED_FATAL_ERROR.) The PnP manager
	creates the devnode in response to the
	IRP_MN_QUERY_DEVICE_RELATIONS request. The driver can safely
	assume that the PDO's devnode has been created when it receives
	an IRP_MN_QUERY_RESOURCE_REQUIREMENTS request.

	Update: It seems we don't need all of this. Showing the
	drive in Explorer is now implemented in drbd-utils (user
	space only).

	Update: Now it notifies applications / explorer of new drive
	via user space on becoming primary and removal of drive
	when becoming secondary.

Done: clean up left over PNP code.

Rejected: Auto-promote seems not to work as expected.

	dir h: should make device primary if possible and then
	not fail.

	Strange, but neither with read/write nor with read only we get
	a create request on the windrbd device. (tested with windrbd-test)

	Update: It seems to me that when we open \\.\K: the file system
	device object (not the storage device object, that is, we) get
	the open request. File system keeps references to the block device,
	so it doesn't reopen it. We plan to release 1.0 without Auto-promote.
	(also because we should not have a windrbd device when the
	resource is secondary, because of the caching).

	Update: We are delivering windrbd without auto-promote, for
	various reasons (don't have device object when secondary,
	for example).

Rejected: Port agruen's test suite to cygwin.
	exxe is running. Ask phil about how to install it.
	Depends on chmod working (else cannot install
	opensshd).

	Update: chmod works now.

	Update: We probably don't do this, according to phil,
	it takes at least one month to complete.

Rejected: Do not have a root device.
	It is useless.

	Update: Windows requires it. We can use it (later) for
	debugfs or for the netlink ioctl.

Done: Understand what windows means by mounting / dismounting.

	Much like linux with udev always automounting everything. Also
	ofter refers to assigning a drive letter to a volume, but also
	the process of detecting a file system and initializing it is
	part of the mount process. Mounting and unmounting (dismounting)
	now works as expected.

Done: check out drbd-utils from github and see if that works.
	(once it is pushed)

	Yes it works (windrbd branch)

Done: How is sync done? 
	Data appears delayed on backing device (about 10 - 20 
	seconds later).

	This is not part of DRBD (also not on Linux) it is the
	responsibility of the application to send sync requests.
	If it doesn't there is nothing DRBD (and hence also windrbd)
	can do.

	What it does, however is to cleanly dismount (unmount) the
	volume on becoming secondary now.

Duplicate: test if loading drbd driver later (not at boot) works.

Done: read error: Volume dismounted
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 DrbdIoCompletion <4>[0xFFFFFA800131B040] DrbdIoCompletion: I/O failed with error c000026e
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 drbd_report_io_error <4>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x208): local READ IO error sector 0+1 on

	Does this still happen? If yes then please reopen, a lot has
	changed meanwhile.

Done: Redo installation of sshd on Windows VM

Done: remove more dead code.

	This is always fun.
	Saved about 1600 lines.

Done: kzalloc should call kmalloc not the other way around.

Done: Review patches if they are still needed.
	Especially kmalloc(,, Tag) which is not neccessary.

	Update: The Tag thing is a perl script which actually
	works quite well (unusual for a perl script ...), leave
	it in, maybe someday one wants to use windows debugger.

	Some features are hard-patched out (discard, biosets, debugfs,
	online verify (!), RB_CONGESTED_REMOTE, write same, disk stats)
	maybe we want to implement them one day.

Done: patches for lars (kref debug in failure path)

Done: More clean up in drbd_create_device (init_submitter)

Done: check if windows device is accessed when it shouldn't

	(grep syslog)

	Right now, this didn't happen.

Done: Error reporting of SendPage()
	Don't know how to do this .. DRBD seems to implement a mechanism
	that works without having sendpage reporting errors, since Linux
	also doesn't report errors on sendpage. Ask Lars.

	Update: SendPage should return error if there is an error
	in Completion function (of an earlier SendPage()), else success. 
	According to Lars, SendPage() (and also Send()) in Linux
	just queues the buffer, however it seems to report errors
	if the socket is in an error state (else that wouldn't make
	sense, at least not to me).

	Update: Now detects connection close of the peer correctly.
	Update: After a fixing a silly bug this works now. 

	Check if timeout works (separate TODO)

Done: other BSOD from Devin: Handle Send errors correctly.

	2018-05-17T13:37:08.904002-07:00 legolas.us.linbit  U20:37:08.888|8e3a8040(sender) SendPageCompletionRoutine <3>SendPage completed with status c000020d

	But not reported to DRBD.

	Update: now reporting errors on send.

Duplicate: On network failure (unplug cable) stays in NetworkFailure state.

Done: Test network timeout on syncing.

	Test timeout with iptables on linux side (must DROP the TCP/IP
	packets from Windows, else there is some other error).

	Update: "New" API correctly detects timeout by giving
	a STATUS_IO_TIMEOUT in the completion (after approx. 22
	seconds). ("Old" API was patched to have infinite timeout)

	Make WinSocket timeout configurable in WinSocket layer
	(SO_SNDTIMEO, SO_RCVTIMEO): Update: not possible, see below.

	Port Send (and also receive?) to new API. Update: receive
	no, here we need the timeout set by tr_ops->set_rcvtimeo()

	Update: What happens to send buffers? Same as with Pages?

	Update: also don't port Send() to non-blocking, it is only
	used to send the first packet during DRBD handshake (there
	the buffer is on the stack so we have to wait for completion).

	Receive with MSG_PEEK used somewhere in DRBD?
	Update: MSG_PEEK no but MSG_DONTWAIT is used. Need to implement
	this.

	What about CALLER_BUFFER, GROW_BUFFER support in recv()?
	Update: Those are DRBD specific and implemented already.

	WinSocket kernel API does not support setting SO_SNDTIMEO
	and SO_RCVTIMEO, since the API functions are always non-blocking.
	There is a system defined send timeout after which WinSocket
	kernel API reports an STATUS_IO_TIMEOUT and completes the IRP
	(without having it sent), which cannot be set programmatically
	(at least not over WskControlSocket which roughly matches
	setsockopt()). The value for Windows 7 is 22 seconds (measured)
	which seems reasonable.

	For now, we now do not support setting send timeout via config,
	if we did we would need to use (Linux) timers to cancel the
	IRP before it completes and set an error state. Doable but
	not now.

	Update: Behaves good if there is traffic (such as a sync), now
	test with timeouts set and no traffic.

Rejected: report socket error state also in Send() and Receive()

	Not now. The Windows socket functions will report the error
	as soon as it happens (such as STATUS_IO_TIMEOUT), thereby
	also interrupting ongoing receives.

Rejected: receive should also fail if error_status is set.

	See other rejected TODO

Done: activate Ctrl-Alt-Del on Windows Server 2016 VM for VNCViewer

	See https://community.spiceworks.com/how_to/19223-how-to-enable-the-software-secure-attention-sequence-policy-workgroup-procedure

Done: /cygdrive/c/windrbd/var/lib/drbd should exist.

Done: renew the sysroot.zip

Done: New BSOD under Windows 10

	drbdadm up w0
	Invalid configuration request
	drbdadm down w0
	BSOD

	Update: this is a bug in beta-3 and fixed meanwhile.

	Obviously I've installed WinDRBD beta-3 (which is signed)
	and cannot install an unsigned windrbd (test) version over
	it. See TODO about when installing a signed DRBD driver,
	installing an unsigned DRBD driver fails silently.

	Always create snapshots (either VM or clonezilla) before
	installing signed drivers on test machines.

	For now, sign the driver and install it on Windows 10
	machine and repeat test.

Done: review code for kmalloc()

	Replaced by kzalloc where needed.

Done: On ping timeout reached, goes and stays in NetworkFailure.

	Tested with iptables-drop.sh on Linux side while connected
	(not syncing)

	Problem was MSG_DONTWAIT blocking. Fixed now.

Done: Implement MSG_DONTWAIT for recv().

	Later.

	Update: now implemented fixed NetworkFailure stuckness on
	connection loss while idle.

Done: clean up SIGCHLD, printk's

Done: Clean up wsk2.c
	Remove unneccessary code.

Done: logging: printk's without terminating \n not displayed.

	Also: if there are some special characters (\0?) the
	line is not displayed.

	Update: Please fix this, it is annoying, I just ran into
	it.

	Update: again.

Rejected: remove all tags from alloc() routines
	and revert patches.

	Update: there's a perl script that does it for us .. leave
	it in, maybe someone will need this one day.

Done: Have a function that initialized all (global) spinlocks
	and replace the racy solution (with an flag indicating
	wheter it is initialized) we have now.

Rejected: (maybe) support setting send timeout.

	This works differently in Windows socket implementation,
	since the send function is asynchronous. There is a
	(fixed) timeout after which we get an error.

Done: make clean target under Windows should do what one would expect.
	also remove *.pdb and *.ilk files in addition to *.obj

Done: blue screen when backing device fails.

	Not observed lately.

Done: I/O error reading past the device.
	Which is correct, however there is a disconnect. And the
	disk should not fail.

	Reading past the device can be used for I/O error handling
	testing.

	Update: works only if there is no file system on the device,
	else upper layers will filter the I/O requests (windrbd does
	not get an I/O request).

	Update: Disconnect is because of protocol error (sector
	out of range), this is probably intentional (remote goes
	into ProtocolError state and disconnects). Can recover
	by connecting again.

	I/O error handling seems to work as expected. Maybe also
	test this with an USB stick.

Done: Fault injection on backing device.

	If we were saints we also would test with split I/O requests.

Rejected: From Devin: make winsat run.

	It uses undocumented APIs (ioctl 0x2d5190). There are lots
	of other tools, for example CrystalDiskMark.

Done: random read/writes (reported by CrystalDiskMark) are very slow

	Device is unconnected.
	Update: also slow when writing directly to backing device.
	Probably a VirtualBox issue.

Done: Test with fault injection and split I/O requests

	With writing 1meg requests.

Done: Protect against sector out of range by checking in windrbd device entry.

Done: Fix error codes returned by irp_to_bio

Rejected: support I/O vectors in windrbd device (irp_to_bio)
	and clean up code (see TODOs in source code)

	Also have a test that does WriteFileGather and ReadFileScatter.

	Update: Have test, but windows copies the data to have it
	linear in memory (getting one MDL element describing a
	linar buffer for all the vector elements).

	For now, leave that alone, it seems not be used by applications.

Done: test no I/O when disk is failed.

	We now allow I/O since DRBD will serve I/O requests from
	a Primary peer of the local disk fails. This works well.

Done: review README.md: some info is outdated.

Done: Blue screen: Windows 2016 server: cannot format volume

	Strange behaviour. Blue screen on format f: (windrbd device)

	Fix networking first (we cannot reach Linux machine from
	Windows 2016 server at the moment)

	Update: fixed, can now test quite good on much vm's.

	Problem was that MAX_MDL_ELEMENTS is just a guess of what
	a Windows block driver can handle. It is 32 for Windows 7
	(found by trial and error), however Windows 2016 Server
	(and as I suppose also Windows 10) have problems with that
	setting. When setting it to 1, no blue screen so far, however
	it is just too slow. Update: it is slow but not so slow
	(had lots of printk's in the I/O path).

	Maybe we can patch DRBD so it can handle biovec elements
	greater than 4K in size (seperate TODO).

	Blue screen fixed by setting MAX_MDL_ELEMENTS to 1.

Done: Code quality: io_status should not be in struct bio, see comments in
	drbd_windows.h

	Seems to work. Maybe do some more tests (see TODO's in source).

Done: Infrastructure: Get Windows 10 drbd installation working again.

	There's a signed driver installed cannot install
	unsigned drivers over it.

	Update: use rundll32 setupapi ... from uninstall todo
	that should do the trick.

	Update: yes it did. Newer windrbd kernel already installed.

Rejected: when installing a signed DRBD driver, installing an unsigned
	DRBD driver fails silently.

	It is unclear how this really works. When installing a
	signed driver it seems to be not possible any more to
	install an unsigned driver over it. Test signed drivers
	is separate virtual machines.

	Update: we now can uninstall DRBD (currently with a
	command line command, see TODO about uninstall). We
	won't research this in more detail.

Duplicate: One day we want to not blue screen when backing device contains a file system.

Done: lots of more tests (corner cases like reading near the
	end of the device)

Rejected: have windrbd-test execute drbdadm as needed.
	This is a nice to have.

Duplicate: We should really lock the backing devices using NT kernel
	mechanisms.

	Maybe use the mechanically locked IOCTL? Then one would
	have to drbdadm down <res> --force

Done: windrbd hide-filesystem does not work on a DRBD device.

	For now use windrbd-test with do_read_write test.

	If we think a little then we find that this is as it
	should be: hide-filesystem writes DRBD into the boot
	sector. This gets written on the backing device. However
	when reading the backing device, the windrbd driver
	converts the DRBD signature to NTFS, so it looks as
	DRBD never got written. There is no way how we can
	distinguish a (possibly intentional) DRBD signature
	from a NTFS signature on the windrbd device.

Rejected: remove drive letter from volume on attach.
	And not reassign it on detach: Users shouldn't modify
	data on a backing device even when the device is down,
	unless they really want it.

	Print a howto showing:
		how to change from drive letter to GUID in drbd.conf
		how to recover the drive letter later (in case
			DRBD is never needed again, or if it was
			the wrong drive letter).

	Update: are we doing this?

	Update: currently it works quite well .. we recommend
	users to use GUIDs and not assign drive letters. If
	we remove drive letters from backing devices, users
	might get confused (plus there might be a lot of
	race conditions).

Done: Test: test network failure with real network cable.

Done: Test: drbdadm status fails after unplug cable when syncing.

	Still there? I suppose no but test it on physical Windows 10
	machine.

	Update: yes it is. No bluescreen however so far.

	Update: Reason was logging. Windows seems to stall drivers
	that send UDP packets. (maybe this is also connected to the
	problem of having interface address instead of loopback as
	syslog_ip).

	Works now, however after plugging network cable again, no
	connection can be established (with errors like sock_recvmsg
	returned -11, Timeout waiting for feature packet).

	Update: I accidentially re-enabled Windows firewall, deactivating
	it solved the problem.

	On no I/O everything works fine.
	On I/O we stall in sync at 99.85 percent after reconnect.

	After a while that goes to 100 percent.

Done: Test: BSOD on network failure
	Check if still there.

	Update: as far as I can tell, no.

Done: Test: Test lower case drive letters for windrbd device.

	Works.

Done: Test: New blue screen on connecting Windows 10 to buildhost Windows 7
	(I think it was D1).

	This might be because of wrong rcu handling (must sleep
	before cleaning up)

	Update: still there?

	Update: Not observed recently, closing this for now.

Rejected: msi installer instead of self extracting exe.

	Not clear yet .. imdisk for example comes also with a
	homegrown install script.

	Please reopen upon customer request.

Done: Test: test I/O error with USB stick.

	Simple test succeeded (no I/O during unplugging).
	When unplugging while I/O is running (over NTFS),
	BSOD.

	Done, and some things fixed.

Done: Bug: on passive side, on BSOD stays in NetworkFailure

	Also on Diskless Primary (peer) and unplugging cable (without
	BSOD)

	After Down/Up when Sync starts (must attach disk on peer)
	BSOD (see separate TODO).

	Update: Found it:

	Problem was that recv_pages didn't return -EINTR when a
	signal was delivered and data was there (which is probably
	right according to recv manpage, even when MSG_WAITALL is
	given). Right now we have a followup BSOD, probably in
	DRBD, because this apparently never worked.

	Update: Linux hasn't got this problem (it seems that -EINTR
	is returned even if there is data).

Done: Bug: From Devin: Registering mount point failed status = c0000035
	This seems to be something that only happens on Windows Server 2016.
	The mount_point buffer is NULL at end of the windrbd_mount
	function:

	2018-05-17T13:47:08.666486-07:00 legolas.us.linbit  U20:47:08.638|da4db040(drbdcmd) windrbd_mount <6>Assigned device \Device\Drbd0 the mount point (null)
	However, all checks before that succeed.

	Get a Windows 2016 Server and test on it.

	Update: Also happens on Windows 10 with beta 3

	Update: Tested with Windows 2016 server, didn't happen so
	far.

	Update: This happens when drive letter is in use. Report error
	to userspace.

	In case we cannot mount on becoming primary, we do not fail with
	an error (since it is not DRBD's fault), but rather print a
	warning. In most cases users want to review their config,
	then. Fixed (to be fixed by user).

Done: Bug: If windrbd drive letter is used as real drive letter, windows
	accesses the real drive silently.

	Update: in that case, mounting fails with c0000035, this should
	be reported to user space as an error.

	Update: We do not fail (would have to revert becoming primary,
	but print a warning:

	In case we cannot mount on becoming primary, we do not fail with
	an error (since it is not DRBD's fault), but rather print a
	warning. In most cases users want to review their config,
	then.

Done: code quality: experiment with MAX_MDL_ELEMENTS

	Make it a variable, increase and wait for blue screen.

	Update: Done, Here's the results:

	Windows 10 and Windows 2016: maximal 16 MDL elements.
	Windows 7: maximal 32 MDL elements.

	Test was on a (virtual) SCSI disk, other device classes
	(USB stick) may have lower limits.

Done: Infrastructure: Windows 2016 powers off on (some) blue screens.

	Simon will write a script that restarts it over libvirt.

Done: Test: Test protocol B, C

	B seems to work .. if one has A and the other node B then
	B wins (also in upstream).
	C also seems to work.

Done: Test: More tests with Windows 2016

Done: Documentation: Describe BSODs in release description

Done: Documentation: Describe restrictions in release description

Done: Installation: Include inf file in package.

	And document how to uninstall on command line.

Done: Features: 3 node setup does not work.

	If node with node-id 1 is missing, node 2 thinks that node
	3 is node 1 during connection establishment:

Jun 26 17:13:17 wintestubuntu kernel: [ 4658.372463] drbd w0 tcp:win7-64: Closing unexpected connection from 10.43.8.188

	(but 10.43.8.188 is WIN-F11R93CP9KI).

	Sometimes connection can be established however we get a
	BSOD then.

	Connection between 2 nodes (Linux and Windows VirtualBox)
	works, but 3rd node (Windows 10 physical machine) BSOD's.

	Update: Now managed to have stable 3-node setup between
	Windows 7 VM, Linux VM and Windows 10 PhysM.

