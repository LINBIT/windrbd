Milestone: windrbd merged into drbd-utils and drbd-headers
Planned: Oct 1 2018
Postponed to: Oct 20 2018
Real: Nov 13 2018
-----------------------------------------------------------------------

Milestone: Beta 5
Planned: Nov 1 2018
Real: Dec 3 2018
-----------------------------------------------------------------------

Milestone: Release 0.9.2
Planned: Feb 28 2019
Real: Apr 10 2019
-----------------------------------------------------------------------

TODO: Bug: BSOD 0x000000f4 on booting diskless

	Meaning critical process died (similar to Attempt to kill
	init on Linux) Sometimes no BSOD but Windows disconnects
	and is not pingable any more.

TODO: Bug: Out of memory very soon on boot

	This might have been the leak in add_spinlock(), for testing
	purposes we removed the corresponding kfree in remove_spinlock().

	There are other memory leaks (lots of pages (8000) allocated,
	don't know yet if those are real leaks. They exist after
	taking all devices down, so probably this is wrong.

	Update: No those pages (64MB) are mempools which also exist
	when there are no resources.

	Update: With 1.5GB of RAM, Diskless client runs quite stable.
	It seems to be a memory allocation done in the page out
	path (which fails, which in turn causes Windows to hang).

	Update: Disabled pagefile, it now runs very stable (could
	install Firefox, CygWin and Ewdk (still downloading)).
	So, bug is probably in the page out path (TODO: try
	booting several times without pagefile).

TODO: Bug: Cannot shut down Diskless client

	Hangs. DRBD device is disconnected, hang is most likely
	in wait_for_primary. Host is not pingable either so
	this is probably after the network was shut down.
	(it does not hang always)

TODO: Bug: w0 is read-only

	This does not have a MBR on it. To work around it make it primary
	set it offline with partition manager and set it online
	again.

TODO: Bug: w0 not accessible after up/down/up/primary

	It does not show up in partition manager and also no drive
	letter is assigned. It shows up in device manager, however
	also the device object \Devices\Drbd5 exists.

	On drbdadm down the device object is not deleted.

TODO: Feature: become Primary automatically after reconnect

	Right now there is no recovery when the boot device
	is disconnected. It should be done such that Windows
	never sees an I/O error.

TODO: Feature: allow to pass DRBD minor to cgi-script

	DRBD_MINOR parameter (need to parse QUERY_STRING,
	this is dangerous)

TODO: Feature: set netboot flag via iPXE

	Windows defines some services as boot critical when
	booting from network. It must be told that it is
	currently netbooting in order to load that drivers
	(currently we patch the Registry)

TODO: Performance: make keep-alive work with cgi-script

TODO: Feature: Pass DRBD parameters of root device to kernel

	Hopefully this can be done via the --filename option
	of sanboot. In Windows read and use those parameters 
	(they are currently hard coded)

	(old entry: Get WinDRBD parameters somehow (via http / JSON?).
	Storing it in Registry of the image is not a good idea (also BCD
	is a registry hive).)

TODO: Feature: Create a WinPE image with network and WinDRBD.

	And see if we can install on top of the WinDRBD device
	It would be nice if we could pass the WinDRBD device
	parameters also via DHCP so the user does not need
	to enter them again.

TODO: Bug: can't create mount point?
	We will later allow the user to choose between disk
	(where Windows manages the drive letters) and volume
	(where we have to do that, most likely) device objects.
	The last is meant for non-sysroot devices only. Not sure
	yet if we need those but then we probably want to fix
	the driver letter thing (again)

TODO: Bug: Can also write when secondary.

	DRBD seems to use Linux' mechanism (via open(2)) to check
	for writability and doesn't check when receiving bio's.

TODO: Code quality: better solution for double REMOVE_DEVICE

	Setting a pointer to (void*) -1 is not a production ready
	solution.

TODO: Bug: handle the case where DRBD device size drops to 0 again

	If we loose connection we need to block I/O's again. It
	seems that DRBD does not call drbd_set_my_capacity() on
	that event (though this is what I would expect).

TODO: Feature: Test if it works with Windows 10 and Server 2016 also

TODO: Feature: Windows should take IP address from DHCP on boot

	Right now, we assign a static address.

TODO: Improve boot speed.

	Right now it takes more than 5 minutes until the system is
	usable

TODO: Feature: Make C:\ as Primary Diskless work

	TODO: a lot. What currently works is:

	*) Create a (Diskless) WinDRBD device on boot. As soon there is

	network the device connects. This is not the System partition.
	Parameters are currently hard coded.

	*) Boot a WinPE on a Linux block device via ipxe sanboot over http. 
	This has currently a (slightly less than) 8GB size limit since it
	uses BIOS interface (int 0x13). Update: no Windows loads via
	BIOS extension (function 0x41/0x42) which supports 64-bit
	block numbers.

	*) Make booting real Windows image work (currently fails with
	   file not found): reason is

	Range is bytes=-967835648--967834625
	(see http_format_range() %zd is 32-bit signed in 32-bit arch)

	Update: Fixed (with a hack), TODO: support %lld
	Update: %lld works now, so does loading directly (without
	cgi) from a file based image.

	We now have a limit at about 8GB

	Maybe submit to upstream ipxe if wanted.

	Update: When using 64-bit ipxe it works with 32GB image:

	make bin-x86_64-pcbios/ipxe.pxe

	*) Fix 8GB size limit (see above)

	With 64 bit iPXE there is no such limit.

	Update: With patches, also works with 32 bit now.

	Patches tested and submited, waiting for response

	Update: response came asking to clarify length parameter widening.

	Update: patch without len parameters patched submitted.

	*) Use drbd device as source device for cgi script.

	Done, works.

	*) Test if read access is possible if there are no Primaries.

		Yes it is. CGI script can serve DRBD device while it
		is Secondary (and there are no Primaries)

	*) Make windrbd device open() function wait for primary
	(this is also interesting for auto promote)

	*) Setup a iscsi boot environment
		We now set up a working WinAoE (http://winaoe.org, also
		now in my github with some patches to make it work
		with 2019's vblade and Windows 7)
		This is open source (gpl v3) and we took the relevant
		parts to make Windows boot via DRBD (we are now a 
		SCSI port driver, just as winaoe is).

	*) Partitioning: Windows expects a disk not a volume
		Yes. With the SCSI-port PnP driver architecture,
		Windows treats the WinDRBD device as disk. This
		disk can also be partitioned via Windows Partition
		manager (and hopefully also via the WinPE partition
		manager), since PARTMGR.SYS is stacked over it.

	*) Somehow trick windows into accepting windrbd device as
	System volume (via BCD?)
		This is now done via the disk.sys driver. WinDRBD
		device (under disk and partmgr) is treated as
		regular system volume. We don't need to touch
		BCD (for now) since the device is the first disk
		in the system (which is usually the boot disk).

	Left to do: see seperate TODO's.

-----------------------------------------------------------------------
TODO: Bug: Allow rcu_read_lock() being called recursively.

	This should fix the system lockup we observed on
	Server 2016.

TODO: Implement: fix the wait_event_interruptible implementation and interface

	All timeouts are currently set to 0, which is most likely
	wrong.

	Update: The whole wait_event and schedule and workqueue
	implementation is broken and should be redesigned and
	reimplemented. Do that for 0.9.4. It should also fix
	the stablity problem that Disconnect sometimes BSODs.

TODO: Code quality: windrbd show-drive-in-explorer might take longer than 5 seconds

TODO: Code quality: drbdsetup disconnect might take longer than 5 seconds

	This makes some tests fail with false negatives.

TODO: Performance: Sync is still somewhat slow when windrbd is SyncTarget
	And: I/O is slow when connected.
	Are we waiting for TCP ACK here?

	Also need to set c-fill-target and/or c-max-rate with
	defaults it is just too slow...

	Update: Also implement no-wait sending for Send() function.

	Update: This function is only used for the first packet.
	and must remain synchronous.

	Update: Probably not the networking code, maybe I/O on
	backing device is slow? When Windows is SyncTarget it is
	faster (3 sec) than when it is SyncSource (7 sec) doing I/O

	Update: Now we reworked the local I/O path a bit, did that
	help?

	Update: Probably will be fixed once we use 1Meg pages on
	Sync.

TODO: Bug: storing function and line patch for spinlock debug currently BSODs

	Have to go home now.

	Also happens with dcbd4227a9f. 7bbb196338?

	Update: Not with 7bbb196338, however this test was without
	connecting. Maybe this is the same bug as Windows 10 BSOD
	on disconnect.

	Update: 'bisect' showed that the bug was introduced with
	6ca3f51f (support printk blocking again), so it is not
	related to spinlock patches.

	Update: reverting the wait_for_sendbuf function (see
	cb56c9c3b9) seems to fix the problem (although
	my_wait_interruptible is still being used for printk()).

	One day we want to fix this and use it for other functions
	too (receive, connect, ...)

	Update: happened again (with cb56c9c3b).

	Update: please see good-bad. BSOD is now at disconnect,
	somewhere in two phase commit.

	Update: printk's showed that crash is in
	wait_event_interruptible_timeout(): see conn_try_disconnect in
	drbd_nl.c, printk before is seen, after is not (and also
	not in the memory dump, so it really doesn't happen)

	Update: Do not deliver with spinlock debugging enabled, it
	changes timings and makes BSOD more frequent.

TODO: Bug: freeze on disconnect-connect-waitconnect loop

	Both nodes Secondary, Windows 7 doing
	disconnect-connect-waitconnect.

	Introduced with cb56c9c3b987 (also observed with fbc556)?
	Same as System freeze on Windows 2016 Primary?

TODO: Bug: kmalloc errors on Win7 VM (on my Macbook)

	When running
		drbdadm invalidate-remote ; drbdadm wait-sync
	in a loop.

	Didn't crash but detached. Probably this is what it is
	supposed to do...

TODO: Bug: BSOD on Secondary Windows 7 in 4 node setup

	Primary (Windows 10) I/O, 4 nodes connected (mesh).
	After about 4-5 hours BSOD, last log line is:

Feb  8 23:28:02 10.43.10.10  U22:28:02.402|06ef9a60(drbd_a_vamp-4nodes) kernel_recvmsg Timed out, but there is data (16 bytes) returning it.

	(appears every minute or so) but BSOD was later than that.

	Now retrying with only 2 nodes.

	Update: Also BSOD with 2 nodes.

	Update: Also (?) on Windows 10 (Secondary) when Windows 7 VM
	is Primary and does I/O (Happend during disconnect/connect
	loop).

Feb 14 15:25:41 10.43.10.13  U14:25:40.802|b80f3370(drbd_a_vamp-4nodes) kernel_recvmsg receive completed with error c000020d
Feb 14 15:25:41 10.43.10.13  U14:25:40.802|b80f3370(drbd_a_vamp-4nodes) kernel_recvmsg setting error status to 0
Feb 14 15:25:41 10.43.10.13  U14:25:40.802|b80f3370(drbd_a_vamp-4nodes) drbd_ack_receiver <3>drbd vamp-4nodes pnode-id:4, cs(Disconnecting), prole(Unknown), cflag(0x212e), scf(0x0): sock_recvmsg returned -104
Feb 14 15:25:41 10.43.10.13  U14:25:40.802|b80f3370(drbd_a_vamp-4nodes) drbd_ack_receiver <6>drbd vamp-4nodes pnode-id:4, cs(Disconnecting), prole(Unknown), cflag(0x212e), scf(0x0): ack_receiver terminated
Feb 14 15:25:41 10.43.10.13  U14:25:40.802|b80f3370(drbd_a_vamp-4nodes) drbd_thread_setup <6>drbd vamp-4nodes pnode-id:4, cs(Disconnecting), prole(Unknown), cflag(0x212e), scf(0x0): Terminating ack_recv thread
Feb 14 15:25:41 10.43.10.13  [last message was in IRQ context]
Feb 14 15:25:41 10.43.10.13  U14:25:40.818|b80f3b50(drbd_r_vamp-4nodes) kernel_recvmsg receive completed with error c000020d
Feb 14 15:25:41 10.43.10.13  U14:25:40.818|b80f3b50(drbd_r_vamp-4nodes) kernel_recvmsg setting error status to 0
Feb 14 15:25:41 10.43.10.13  U14:25:40.818|b80f3b50(drbd_r_vamp-4nodes) drbdd <3>drbd vamp-4nodes pnode-id:4, cs(Disconnecting), prole(Unknown), cflag(0x212e), scf(0x0): error receiving P_DATA, e: -5 l: 1048576!

	But maybe this is the connect/disconnect loop.
	(Update: it probably is, see seperate bug)

	Update: Tested with 0.9.1 release. Also a BSOD on Secondary,
	in that case also on Primary (but this is probably because
	of the network timeout BSOD we've already fixed). We now
	try to fix the spinlocks and then try again.

	Update: It was probably the Intel network driver (or a
	combination of network driver emulation in qemu and the
	driver). We are now redoing the test with the Realtek
	driver and NIC emulation, so far no BSOD (but let's wait
	until tomorrow).

	Update: When using the Realtek driver and NICs, it
	stopped now working, no BSOD but we could not
	start any more processes. Opening explorer for example
	showed a panel saying out of system resources. May have
	several reasons: most likely we cannot start kernel
	threads or we are out of IRPs (but then printk wouldn't
	work either, but it does ...). So it seems to be some
	resource leak (which also makes sense because it always
	takes around 1500 iterations of write-fs-loop.sh which
	equals around 80GB of data). According to task manager
	it is not the physical RAM.

	Update: We now converted printk back to blocking operation.
	It seems that printk's get lost when some resource isn't
	available. We hope that this does not happen in blocking
	mode.

	Update: Now BSODs on network error (no more printk's after
	receive returned error). We now try with ChargeQuota set
	to TRUE on IoAllocateIrp. Another idea would also be
	to associate the Mdl with the Irp (see InitWskData()).

	Update: We definately lose (up to 20) printk's when
	resource X (yet unknown) is short, as a test showed.
	We need to see them (resend them when ack-receiver
	thread is terminated).

	Update: need to debug via serial console, since we
	destroy something in the networking stack.

	Update: Maybe grepping the memory dump (of a BSOD)
	is sufficient.

TODO: Bug: BSOD on Disconnect on Secondary (Windows 10)

	Primary (Windows 7) doing I/O.

Feb 14 15:47:55 10.43.10.13  U14:47:47.251|d012dee0(drbd_a_vamp-4nodes) kernel_recvmsg receive interrupted by signal
Feb 14 15:47:55 10.43.10.13  U14:47:47.251|d012dee0(drbd_a_vamp-4nodes) drbd_ack_receiver <6>drbd vamp-4nodes pnode-id:4, cs(Disconnecting), prole(Unknown), cflag(0x12e), scf(0x0): ack_receiver terminated

	Happens quite soon (1-10 attempts).

	Update: Implemented -EINTR on signal for wait_for_sendbuf,
	BSOD after ~25 disconnect / connects.

	Found:

Feb 15 16:39:23 10.43.10.13  U15:39:23.579|3e3eb560(not_drbd_thread) static_inline_expect_fn_peer_device <3>drbd vamp-4nodes/1 minor 1 pnode-id:4, pdsk(UpToDate), prpl(SyncTarget), pdvflag(0xc00): ASSERTION __dec_unacked(peer_device) >= 0 FAILED in e_end_block

	(also in original log). Is this a new upstream bug?
	(Test with Linux/Linux)

	Update: Now testing with Linux/Windows (Linux doing up-down loop,
	Windows being Primary and doing I/O). No BSOD so far.

	Update: Maybe this is the same as storing function and line patch ...
	(BSOD in wait_event_interruptible_timeout on Disconnet).

TODO: Bug: System freeze on Windows 2016 Primary on SyncSource (with spinlock patches).

	There's a (probably new) bug that freezes the System: Secondary
	(Linux) doing Up/Down loop Primary (Server 2016) doing a
	write-fs-loop.

	Now redoing the test with 82df601 on Server 2016

	Update: Test ran for 20 hours, no freeze. Also currently
	testing with 5df572, so far no freeze (1 hour). Maybe
	this was something else ... can't reproduce at the moment.

	Update: Freeze after 6 hours of running the test. We now
	fixed the (proably last) spin_lock bug (in lock_all_resources)
	and hope that the hang does not happen again.

	Update: Freeze with 70bdf4e (after 2-3 hours with sync
	interrupted on peer).

	Now trying with 0.9.1-1 ... no freeze so far. Also trying
	with current (0a978d01) DRBD between Linux and Linux
	(same test).

	Update: system lockup also with 0.9.1-1, so this is definately
	an 'old' bug. Also not in the DRBD part, since Linux/Linux
	test is still running (after 3 days).

	Update: we've implemented a spin lock monitor, however in
	Windows kernel (at least Windows 7) the spinlocks are really
	'big kernel locks' that lock the whole machine. Try this with
	Windows 10 and see if it changed.

	Update: We now analize the memory dump (Windows 10 has a
	watchdog facility which BSODs instead of just locking
	the machine) and found that rcu_read_lock is called
	twice in a thread (sender thread), so recursively.

	This might be valid with Linux implementation, however current
	Shared/Exclusive spinlock WinDRBD implemenation doesn't allow
	this.

	Update: also happened with 4c8c46a4a (0.9.2-rc1). On disconnecting
	after long running I/O test (24 hours).

TODO: Code quality: review TODOs in source code.

	Currently 136 total.

	For now (0.9.2), fix the TODOs in winsocket layer.

TODO: Bug: various memory leaks

Jan 31 23:12:37 192.168.56.101  U22:12:36.089|05bea560(not_drbd_thread) dump_memory_allocations kmalloc_debug: Warning: memory leak of size 104, allocated by function fifo_alloc at drbd_sender.c:549.
Jan 31 23:12:37 192.168.56.101  U22:12:36.089|05bea560(not_drbd_thread) dump_memory_allocations kmalloc_debug: Warning: memory leak of size 56, allocated by function alloc_disk at ../../win4lin/src/drbd_windows.c:2425.
Jan 31 23:12:37 192.168.56.101  U22:12:36.089|05bea560(not_drbd_thread) dump_memory_allocations kmalloc_debug: Warning: memory leak of size 72, allocated by function blk_alloc_queue at ../../win4lin/src/drbd_windows.c:2415.
n 31 23:12:37 192.168.56.101  U22:12:36.089|05bea560(not_drbd_thread) dump_memory_allocations kmalloc_debug: Warning: memory leak of size 104, allocated by function sock_create_linux_socket at ../../win4lin/src/windrbd_winsocket.c:1188.

TODO: Implement: Log rotate

	From Devin: Logfile became 9GB big.

	We should fix this for the next release.
	Maybe ship WinDRBD with net logging disabled and no log-server?

TODO: Implement: Other mechanism to specify syslog_ip.

	Should be able to change it without rebooting.

	Have a windrbd log-to-ip <...> command. Before this command
	is given, only log to ring buffer internally (or maybe still
	have the key?).

	Update: No it makes sense to remove the registry key. Users
	should either start windrbd log-server (which sets the IP
	internally) or windrbd log-to-ip. Ring buffer is big enough :)

	Update: Best is probably to have a /cygdrive/c/windrbd/etc/windrbd.conf
	file for the IP or logfile, so that we don't have to touch
	the config file format.

	The problem is that on uninstall and reinstall WinDRBD the
	registry entries get lost, so probably better to have
	it in config file (drbd.conf global section?)

TODO: Code quality: eventually use drbd_rate_limit() on some printk's

TODO: Bug: Connection loss on drbdadm detach on secondary

	Primary (Win10) has I/O, secondary (Win7 VM)  is connected and
	diskful. On executing drbdadm detach following happens:

Feb 14 14:58:01 10.43.10.10  U13:57:59.490|083959c0(drbd_a_vamp-4nodes) got_peer_ack <3>drbd vamp-4nodes pnode-id:3, cs(Connected), prole(Primary), cflag(0xe), scf(0x0): peer request with dagtag 14328667212 not found
Feb 14 14:58:01 10.43.10.10  U13:57:59.490|083959c0(drbd_a_vamp-4nodes) drbd_ack_receiver <3>drbd vamp-4nodes pnode-id:3, cs(Connected), prole(Primary), cflag(0xe), scf(0x0): FFFFF88005207C60f failed

	Most likely an upstream bug (try Linux/Linux). Not severe,
	connection is re-established rightafter.

TODO: Feature: Allow drbdadm status for non-Administrator

	Implement with a second control device which is accessible
	to (almost) all.

TODO: Feature: Resource agent for Microsoft cluster manager

	In progress: Install Server 2016 machines (again)

	Done, when there is time, start working on that again.

	From Phil: IBM uses MSCM: see

	https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_9.1.0/com.ibm.mq.con.doc/q017940_.htm

	Quote: "Assign a storage device for exclusive use by the queue manager. This device needs to be created as a resource instance before it can be assigned."

TODO: Feature: Autopromote

	If Windows poll the devices read-only, this would make sense
	(DRBD only attempts to promote if device is opened writable)

TODO: Code quality: restructure directory structure

	have include and src directories.

TODO: Bug: FIXME in bitmap code

	On testing 4 node setup:

Feb  5 14:01:17 10.43.10.11  U13:01:17.453|4260bc80(drbd_a_vamp-4nodes) bm_print_lock_info <3>drbd vamp-4nodes/1 minor 1, ds(Inconsistent), dvflag(0x0): FIXME drbd_a_vamp-4nodes[8] op clear, bitmap locked for 'receive bitmap' by drbd_r_vamp-4nodes[7]

	Upstream bug?

TODO: Bug: printk eats boot messages

TODO: Bug: Diskless Primary BSOD when connection failed

	After failure (still I/O) BSOD after approx. 45 Minutes of
	I/O while Diskless Primary Unconnected

Dec 15 21:14:50 10.43.10.11  U20:14:50.359|613a95a0(not_drbd_thread) drbd_send_and_submit <3>drbd lindrive2016/1 minor 13, ds(Diskless), dvflag(0x2): IO ERROR: neither local nor remote data, sector 324376+8
Dec 15 21:14:50 10.43.10.11  [last message was in IRQ context]
Dec 15 21:14:50 10.43.10.11  U20:14:50.359|613a95a0(not_drbd_thread) bio_endio <6>[0xFFFFD38A23FB6080] thread(not_drbd_thread) bio_endio error with err=-5.
Dec 15 21:14:50 10.43.10.11  U20:14:50.359|613a95a0(not_drbd_thread) windrbd_bio_finished <3>I/O failed with -5

TODO: Bug: BarrierAck sequence mismatch

Dec 15 20:29:51 10.43.10.11  U19:29:48.137|1df99db0(drbd_s_lindrive2016) dtt_send_page <4>drbd lindrive2016 tcp:wintestubuntu: dtt_send_page: size=24 len=24 sent=-110
Dec 15 20:29:51 10.43.10.11  U19:29:51.293|1e0398a0(drbd_a_lindrive2016) tl_release <3>drbd lindrive2016 pnode-id:2, cs(Connected), prole(Secondary), cflag(0x2060e), scf(0x0): BAD! BarrierAck #4348980 received, expected #4348979!
...
Dec 15 20:29:51 10.43.10.11  U19:29:51.356|613a95a0(not_drbd_thread) drbd_send_and_submit <3>drbd lindrive2016/1 minor 13, ds(Diskless), dvflag(0x2): IO ERROR: neither local nor remote data, sector 324368+8
Dec 15 20:29:51 10.43.10.11  [last message was in IRQ context]
Dec 15 20:29:51 10.43.10.11  U19:29:51.356|613a95a0(not_drbd_thread) bio_endio <6>[0xFFFFD38A23C7A080] thread(not_drbd_thread) bio_endio error with err=-5.
Dec 15 20:29:51 10.43.10.11  U19:29:51.356|613a95a0(not_drbd_thread) windrbd_bio_finished <3>I/O failed with -5
Dec 15 20:29:52 10.43.10.11  U19:29:52.325|1df91e70(drbd_r_lindrive2016) Disconnect <6>[0xFFFFD38A223ED480] Timeout... Cancel Disconnect socket:FFFFD38A1CCA6A28
...
Dec 15 20:29:53 wintestubuntu kernel: [3202762.201483] drbd lindrive2016/1 drbd13 WIN-F11R93CP9KI: Downgrading local disk to D_OUTDATED since current UUID differs.

	Upstream bug?

TODO: Installation: Driver unload sometimes hangs when explorer window is open

	Holds a ref (Server 2016, Windows 10): Hangs in STOP_PENDING.
	Stops once explorer Window is closed (also was: Timeout on
	windrbd remote-drive-in-explorer).

TODO: Implement: Make online resize work.

	Some day ..

TODO: Test: IPv6

	Doesn't work, but this might be an Ubuntu issue.

TODO: Implement: online verify does not work currently

	It reports all blocks out of sync (which isn't true)

TODO: Performance: lindrive (Diskless Primary) is somewhat slow.

TODO: Implement: Test other file systems (FAT, FAT32, ...)
	FAT does not work (Invalid function when accessing DRBD device)
	FAT32 also not (something with flushing?)
	Probably there is one important IOCTL missing.

	UDF and exFAT can be mounted on Linux. FAT and FAT32 show
	empty (zeroed out) device. So we probably have 2 independent
	errors. (UDF cannot we written on Linux, this is because it
	is the DVD format).

	Update: exFAT now can be read (not written to) on Windows,
	by returning STATUS_INVALID_DEVICE_REQUEST (instead of
	STATUS_NOT_IMPLEMENTED) for unknown ioctl's.

	Update: implemented some other ioctl's without success so
	far. On formatting FAT, reads bootsector as last action
	(before terminating), maybe that's a hint.

	Also make it work with ReFS (windows server 2016, windows 10).

TODO: Test: Test with MS SQL server

TODO: Implement: We want to have some sort of a regression test suite.

	Do not use agruen's it is too complicated. Maybe write a simple
	new one from scratch (or reuse parts of the old DRBD 8 python
	test suite with ssh support).

	Update: maybe best is to write a simple new one in bash.
	(see test-io-larger-than-1m.sh).

	Update: Phil probably rejects a seperate testsuite for
	WinDRBD (which makes sense to me). Since drbdsetup events2
	is working now, it got easier to get agruen's testsuite
	working. What is definately missing is a replacement for
	lvm and (probably) netfilter (we also need lvm replacement
	for porting LinStor to Windows later).

	Update: Do that right after beta5

	Update: Yes we will use the agruen test suite. Phil is doing
	most of the tests so ask him for a primer.

	Update: working on fake-lvm, which will be able to understand
	lvcreate and lvremove (only the needed options, no thin
	provisioning).

TODO: Implement: drbd-proxy-ctl should ignore WinDRBD devices

	From Devin.

TODO: Upstream: NO_ERROR -> DRBD_NO_ERROR

TODO: Upstream: Feature: show reason for going into StandAlone on status

	So one knows if it is split brain or something else.

TODO: Upstream: Feature: skip initial sync command.

	something like drbdmeta option?

TODO: Installation: Offer to remove C:\windrbd completely

	Currently there is a panel, which is sometimes not seen
	(when rebooting)

TODO: Bug: Sometimes permissions of userland binaries are wrong
	(causing service registration to fail)

TODO: Feature: Does it work with Volumes spanning several HDDs?

TODO: Code quality: have refcount on struct socket

	Not sure if we do a sock_release() while in SendPage().
	(right now, no BSOD's but probably one day ...)

TODO: Bug: On re-attach after Primary Diskless stuck in Negotiating

	and blocked: upper
	When there is I/O
	I/O hangs
	Remote shows Disk as UpToDate
	According to Phil/Lars Negotiating stuck is the cause for
	blocked: upper (and not vice versa).
	(dead lock cannot do drbdadm down and driver unload)

	Update: still there?

TODO: Bug: Windows Server 2016 complains about unclean shutdown of file system.

	On clicking repair, nothing happens.

	Update: still there?

TODO: Upstream: Fix 2 cygrunsrv bugs

	Handle whitespace in PATH components correctly.
	Find local installation even if moved to another dir.

TODO: Performance: Teach sync code to handle 1Meg pages.

        For performance reasons. Right now data is split into
        4K request (lots of them) which makes sync slow.

TODO: Upstream: Quorum no on Linux with 2 node setup

	Bug?

	johannes@wintestubuntu:~$ drbdadm status
	w0 role:Secondary
	  volume:1 disk:UpToDate quorum:no
	  WIN-F11R93CP9KI role:Primary
	    volume:1 peer-disk:UpToDate

TODO: Implement: Have a ioctl to set user mode helper program

	And other modparams.

	Update: We now can use the drbdadm from where the windrbd
	binary lives (without ioctl, it is sufficient for now to
	do that in user space).

TODO: Implement: Make drbd-utils relocateable

	Currently hardcoded to C:\windrbd (in kernel and install scripts)
	and configure parameter in userland.

TODO: Upstream: drbdadm invalidate while primary and connected uptodate/uptodate does nothing.

	And also does not return an error.

TODO: Research: Hyper-V plugin for Linstor

TODO: Documentation: drbd-util: Update manpage.

	And write one for windrbd utility.

TODO: Upstream: add .\*.d and the like to .gitignore

TODO: Upstream: Possible race at drbd_thread_setup() (drbdmain.c:567) with
	use-after-free.

	Ask phil. IMHO the resource object containing the drbd_thread
	might get deleted before the spinlock is freed.

TODO: Upstream: Possible race in drbd_send_zc_copy()

	page may be freed by a concurrent thread.

TODO: Feature: Check if it is a network share (currently blue screens)
	Update: blue screen was something else. Should check if the
	drive letter is a network share. Unfortunately they do not
	appear in the \DosDevices directory. If we create a drive
	letter (symbolic link) in the \DosDevices it will be silently
	ignored. Warn the user if it is a network share.

TODO: Upstream: drbdsetup generic_get() handles multiple packets wrong.

	If the DONE packet is not the first packet, it is not detected.

	Probably nobody noticed because recvmsg() always returned only
	one packet (socket is a DGRAM socket).

TODO: Implement: Make windrbd directory unaccessible for non-admins.

	Non-admins can read the dirs and files but not write them.
	This is ok for now, later we probably want to deny read access
	(in case there are shared secrets).

TODO: Implement: fix the wait_cond_interruptible busy loop.

	DRBD does a wake_up() call whenever the condition might change.

TODO: Features: implement flush_workqueue

	For example, drbdadm down takes long when connection goes
	down. Update: when touching this also refactor workqueue
	code (use Linux locking primitives, don't have helper struct,
	...).

TODO: Code quality: Implement function stubs created when integrating DRBD 9.0.9

TODO: Code quality: Reenable Windows Compiler Warnings and fix them.

TODO: Implement: get drbdmon (and drbdsetup events2) working.

	Probably this works only with WSL .. CygWin does not have
	epoll as well as some other required syscalls (kill,
	sigaddset, sigemptyset, pipe2).

	Maybe Robert does this.

	Update: Prepared a Windows VM for him to develop on.

TODO: Code quality: use zero-sized arrays at the end of structs

	MS compiler seems to accept them (ask why this patch was neccessary).

TODO: Code quality: List C files to compile in Makefile

	Instead of just using globbing (*.c)

TODO: Code quality: Replace WDRBD_ERROR and the like by printk

	The log severities are wrong with these macros.

TODO: Implement: forward port drbd_polymorph_printk.h (again).

	Or even better use the original file which should also
	work (currently exit code of user mode helper is not 
	displayed when non-zero). 

TODO: Bug: BSOD on pri-on-incon-degr user mode helper.

	Most likely if and when there is no daemon running, because
	of the 10 seconds delay .. there some strange things can
	happen. Most likely also has to be fixed upstream (check
	if this is a problem on Linux, just do a sleep 10 as
	handler).

TODO: Implement: drbdadm adjust changing mount point doesn't work now.

	Update: Yes. Meaning it doesn't work (as I expected). Do that
	later.

TODO: Feature: Mount to NTFS directories.

	For now, at least prepare user space to support that.

TODO: Research: Understand IRP cancellation

TODO: Test: Somehow test if referencing overlay thread works as intended.

TODO: Build system: have a make depend target
	Or at least header file dependencies.

	Working on it .. make deps creates the Makefile.deps
	Generate it if it does not exists and include it.

	Update: we just found that it works. Be nice and warn user
	if Makefile.deps does not exist (or make deps if it does not
	exist).

	Update: Now generate dependencies and use them rightaway
	if they don't exist (need gcc on Windows build host for that,
	however).

	Update: Currently always exectutes make deps, not what we
	want. Ask Robert or Lars.

TODO: Test: Test under memory pressure.

	We had a leak that caused all non-paged memory to be consumed,
	followed by a CC BSOD.

	Update: with the kmalloc debugger it will be possible to do
	something like:

	windrbd inject-oom drbd_windows.c:1234 10

	to make kmalloc at drbd_windows.c line 1234 fail after being
	called 10 times.

TODO: Bug: Out of memory handling in windrbd device is broken (BSOD).

TODO: Bug: Assertion triggered:

Jul  9 15:28:24 johannes-VirtualBox kernel: [ 4399.169792] drbd w0/17 drbd26 linbit-wdrbd: ASSERTION (n_oos - peer_device->rs_failed) == 0 FAILED in drbd_resync_finished

	on Linux side when injecting faults at request.

TODO: Bug: On re-attach USB stick after failure, WinDRBD hangs.

	When there is I/O ongoing and DRBD is connected. Once we
	force disconnect on the peer side, DRBD continues.

	Update: It now syncs but is quite unresponsive.

TODO: Research: See if it works under ReactOS

	Bonus would be that we could create legally 26 more
	VMs to test 32 node setup..also ReactOS can be patched
	to show printk's (via our printk-to-syslog utility)
	right before BSOD's (maybe it can also Stack dump in
	a sane way ...).

	Oops, ReactOS is 32-bit only .. this would require some
	adaption. First, compile ReactOS from scratch to see if
	that make sense at all. Then (try to) compile windrbd with
	the ReactOS compiler (can do that under Linux...)

TODO: Upstream: blue screen on drbdadm detach --force (when needing uptodate
	data) and then drbdadm status.

	Cannot reproduce at the moment.

	Update: Yes this still happens (when I/O is on the windrbd
	device). BSOD on drbdadm detach --force (no need for drbdadm
	status). Happened on Windows 10.

	Does not happen on Windows 7, however on Windows 7 there is
	no error reported to user space (I/O application hangs and
	is not killable).

	Update: Does it happen on Linux? Then, maybe an upstream bug.

	Update: Yes it is. Somewhere in the I/O path. We don't even
	get an Oops in syslog, kernel just hangs (no mouse pointer, ...)

	Update: According to Lars this is a known issue and is
	kind-of intentional (at least it is known). One should do
	drbdadm suspend-io before drbdadm detach --force instead.
	Changed to Upstream, low priority since this is also a defect
	on Linux.

TODO: Bug: On Primary diskless (after backing dev failure) BSOD when unplugging Network cable.

	Check if also on 'normal' diskless.
	Update: No (did 1 test), but peer stuck in NetworkFailure

	Update: Does it happen on Linux? Then, maybe an upstream bug.

TODO: Bug: BSOD on passive remote side on reconnect to failed peer.

	This happened after restarting the peer after it had a
	BSOD on backing device failure.

	Update: There appears to be more than one problem. One last line
	is:

Jun 29 19:02:29 192.168.56.101  U17:02:24.344|0d994fa0(sender) w_e_end_rsdata_req <3>drbd usb-stick/1 minor 6 pnode-id:2, pdsk(Inconsistent), prpl(Established), pdvflag(0x600): Sending NegRSDReply. sector 32832s.

	but also

Jun 29 19:02:29 192.168.56.101  U17:02:24.329|171bcfa0(receiver) windrbd_generic_make_request <3>[0xFFFFFA800237AB50] IoBuildAsynchronousFsdRequest: cannot alloc new IRP

	before that line (which is most likely some invalid argument, not
	out of memory).

	Another last line is:

Jun 29 17:29:25 192.168.56.101  U15:29:08.370|133befa0(receiver) drbd_md_sync_page_io <7>drbd usb-stick/1 minor 6, ds(Inconsistent), dvflag(0x0): meta_data io: receiver [64726384]:drbd_md_sync_page_io(,15728632s,WRITE) FFFFF88001ADAD1CS

	This happens always after Down/Up after stuck in NetworkFailure.

	Update: After fixing the NetworkFailure bug, this unfortunately
	still happens (when reconnecting and syncing). Can't test at the
	moment.

	Update: Happened again:

Jul 10 16:29:18 192.168.56.101  U14:29:17.012|25dcafa0(receiver) bio_set_op_attrs <2>[0xFFFFFA8005C13760] BUG: failure
Jul 10 16:29:22 192.168.56.101  U14:29:20.684|25dcafa0(receiver) drbd_submit_peer_request bio->bi_end_io = drbd_peer_request_endio
Jul 10 16:29:22 192.168.56.101  U14:29:20.684|25dcafa0(receiver) submit_one_flush bio->bi_end_io = one_flush_endio
Jul 10 16:29:22 192.168.56.101  U14:29:20.684|25dcafa0(receiver) bio_set_op_attrs <2>[0xFFFFFA8005C13760] BUG: failure
Jul 10 16:29:22 192.168.56.101  U14:29:20.684|25dcafa0(receiver) drbd_submit_peer_request bio->bi_end_io = drbd_peer_request_endio
Jul 10 16:29:22 192.168.56.101  U14:29:20.684|25dcafa0(receiver) submit_one_flush bio->bi_end_io = one_flush_endio
Jul 10 16:29:22 192.168.56.101  U14:29:20.684|25dcafa0(receiver) bio_set_op_attrs <2>[0xFFFFFA8005C13760] BUG: failure

	BSOD is 0xD1

	Update: Does it happen on Linux? Then, maybe an upstream bug.

TODO: Bug: BSOD on unplugging network cable in 3 node setup

	Was most likely something with 3 node setup (freezes when
	network cable is unplugged). Logging was local (BSOD when
	it is remote). Update: after several minutes BSOD also
	when freezed (WATCHDOG_VIOLATION).

	Update: Does it happen on Linux? Then, maybe an upstream bug.

TODO: Test: Test sendbuffer full (rety on Metadata socket).

	See if supported at all (have printk's if not). Update:
	seems to be supported.
	Update: No it is not. It just never got called. Setting
	receive buffer size is supported, send buffer not.

	Unclear how to test it. Do that later.

	Update: we now implemented send buffer limit, test this
	somehow.

TODO: Feature: on patching boot sector, inform Windows that file system is
	raw now.
	So that it disappears.

TODO: Test: how and when is flush to backing device done?
	This is important. Right now NTFS files only appear on
	Linux when sync is done manually. Should sync at least
	when becoming secondary. sync must be done while primary
	(when secondary it would fail)

	Update: is this fixed now?

	I recently didn't observe data loss on writing to an
	NTFS then doing secondary / primary on remote. However
	since Windows does caching at file level (not at block
	device level) it should fail. Maybe write a test that
	writes a large file and then immeadiately does a
	drbdadm secondary (without syncing the file).

TODO: Test: Check if windows device is really deleted on becoming secondary

	There might be references and it is only marked as pending
	delete (see IoDeleteDevice manpage)

TODO: Bug: Make windows checkdisk (over unclean shutdown panel) work.

	It seems that this appears when backing device is used
	twice and modified, but how to make it disappear? cmdline
	chkdsk works.

TODO: Code quality: maybe revert the mountmanager code.

	I am not sure if this is a benefit.

TODO: Bug: refcnt is 0 on drbd_rs_complete_io
	May 31 17:10:06 192.168.56.101  U15:10:04.337|03431840(sender) drbd_rs_complete_io <3>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x0): drbd_rs_complete_io(,16384 [=0]) called, but refcnt is 0!?

	Did
		sudo drbdadm invalidate w0 ; sleep 1 ; sudo drbdadm down w0
	on Linux side.

TODO: Performance: On much VM, one CPU core (has 2 cores) goes to 100% on sync.
	I assume there is an unneccessary (?) copy somewhere.

TODO: Bug: test-loop hangs after about 16 iterations.

	format k: sometimes gets stuck when run from test script.

TODO: Code quality: Re-check the WIN32 / WIN64 thing in drbd_endian.h

TODO: Feature: flush not supported by some (all?) devices: currently we
	ignore this (as reactOS also does it). Update: ext2
	file system uses CcFlushCache(): see
	reactos/reactos/drivers/filesystems/ext2/src/flush.c

	Also try to use the ZwFlushXXX function (as Mantech does it)

TODO: Feature: make debugfs work

TODO: Feature: mandatory locking for backing device.

	This is unclear. Test how backing device is locked right now
	(formatting for example reports that it is in use).

TODO: Test: Kernel really should report an error if Bind() fails. 
	For example if the local IP address does not exist.

	Update: Test if this is fixed now.

	Update: I've read about an Upstream patch concerning this.

TODO: Performance: Someday we want to pass user level buffer to driver directly
	on READ requests instead of having a temp buffer (needed
	for Windows 10).

	        pDevObj->Flags |= DO_BUFFERED_IO;

	(found in loopback sample driver)?

TODO: Test: spurious error 5 (ACCESS_DENIED) when reading DRBD device.
	after doing some experiments. drbdadm down / up solved the
	problem.

	Update: still there?

TODO: Test: Fix windows shutdown bug.

	Most likely this was introduced when implementing the
	cleanup() method.

	Update: Not observed lately.
	Update: just reappeared again.

	Update: still there?

TODO: Code quality: Minimize / Sqash patches to DRBD

TODO: Code quality: rebase drbd_wrappers.h to upstream DRBD

TODO: Feature: when losing Quorum go into read only mode.
	(quorum means that our connected network contains > n/2 
	(n .. total number of nodes) valid nodes.
	This is currently being implemented in DRBD

	Update: We leave checking to DRBD, is there something
	we need to do in WinDRBD emulation layer? I suppose no.

TODO: Performance: I/O seems to be rather slow even when being unconnected (and primary)

	We now patched request to be 1M (instead of 4K). Is it still
	there?

TODO: Research: check out mantech wdrbd and see if it works (and why)
	Update: mantech WDRBD lacks many features we have
	in windrbd most notably: it cannot connect to a
	Linux DRBD. It does not support internal meta disk.

	If there is spare time have a look on it (at least read
	the docs, need Chrome for it (!)).

	Update: Installed WDRBD and made it crash with a nc from remote.

TODO: Upstream: Cygwin should have /dev/drbd<n> mapped to
	\\Device\\Drbd<n>

	Right now, we can read/write the windrbd device via
	windrbd-test utility.

TODO: Code quality: fix the macro redefinition problems in drbd_windows.c
	For now we have to copy the function prototypes from MSDN.
	Not good style.

	Update: check if the prototypes are still needed.
	Update: we probably reject this.

TODO: Upstream: submit ?: usage patches (gcc extension)

TODO: Upstream: void pointer arithmetic: submit to upstream

TODO: Code quality: free_page should take a ULONG_PTR?

TODO: Code quality: MSG_DONTWAIT into Receive?

TODO: Code quality: sk_connecttimeo weg (was stattdessen)?

	According to Lars, some combination of sndtimeo / rcvtimeo
	should be used (they have both the same value).

TODO: Code quality: maybe submit: kernel_setsockopt(..., SO_REUSEADDR, ...)

TODO: Implement: tcp stats

TODO: Test: dtt_hint

TODO: Implement: remaining patched out features of TCP transport

	TCP_CORK
	TCP_QUICKACK
	SO_KEEPALIVE
	sk_allocation
	sk_priority
	debugfs

-------------------------------------------------------------------------

Done: fix patch errors on Linux side build (conversion)
	a make clean did solve it

Done: backup on www.johannesthoma.com

Rejected: install Windows kernel headers
	Is part of EWDK.

Rejected: Download heise Linux Virus scanner CD and check image.
	I tried Desinfec't 2014 but it hangs. Now have Avira 
	inside the Windows machine.

	TO DO: This should start automatically at boot

Rejected: Maybe migrate vdi image to internal SSD

Done: Reboot Mac and see if it is still slow
	Done: Something in the VM config was slow, created a new one

Rejected: Install FreeSshD
	
Done: Install cygwin
	Done, works
	Also installed Dev (GNU toolchain)

Done: Install Visual Studio
	C headers are missing, TO DO: Uninstall and redo installation
	from scratch.	
	Done, works now

Rejected: Reorganize converted sources (have drbd and drbd-headers inside
	a dummy dir, to make it compatible to original layout.

Done: Make it compile under Windows
	Done: Fixed permission errors
	Done: Must work with /cygdrive/z/... mapping (cmd.exe does not
		support UNC names)

	Done: path to cl.exe
	Done: install EWDK (plus prerequisites like device driver
		kit)

	Done: make signing the driver work.
	Done: Make clean and remake to see if it still works.

	Must:
	1.) Run 
		make 
	on the Linux box (from $HOME/Linbit/Work/wdrbd9)

	2.) Run
		make
	on the Windows box (from $HOME/Linbit/Work/wdrbd9 (takes some while)

	3.) Run
		make install
	on the Windows box (from $HOME/Linbit/Work/wdrbd9/converted-sources/drbd)

	4.) Run (in an Administrator cmd.exe Console: to open it go to
		 C:\Windows\System32 in Explorer, Cmd-Click on cmd.exe
		 and select Run as Administrator)
		INSTALL-DRBD-admin.bat

	5.) To load the driver, do (from Adminstrator Console)
		sc start drbd
	DbgViewer will show output. To start DbgViewer go to 
	C:\drbd\DebugViewer and start DbgView.exe as Administrator

Done: Revert to original build layout
	Done: Backported work done in converted sources
	Rejected: Cross compiling coccinelle for Linux (requires ocaml)
		Does not work, Ubuntu OCaml parmap library installation
		seems to be broken.
	Done: see if there is a cygwin package for coccinelle
		No
	Rejected: install ocaml for CygWin
	Rejected: Cross compile conccinelle for CygWin
		If possible, do not try to fix too many things.
	Rejected: make should build everything under Windows

Done: make install should install the driver and activate it
	(Rethink: only install the service User should do 
	sc start drbd manually, since that could crash the
	machine rightaway)

Done: make install should also be possible in top make file

Rejected: Migrate sources to Windows C: drive and build from there
	Maybe then it is faster..but then we need to make tarball and
	the like .. Hmmm.

	Rejected because Windows crashes randomly. It is also better
	to have sources on Linux since step 1 of the build has to be
	executed under Linux.

Rejected: Remove everything with signing (signtool exits with an error)
	We leave it in, even though it does not work. Must start Windows
	with Load unsigned drivers (Press F8 at boot and select bottom
	most entry (Load unsigned drivers))

Done: Insmod
	Rejected: pnputil -a drbd.inf
	Done: currently fails with Permission denied.
		Must run cmd.exe as administrator (Cmd-Click on
		cmd.exe in /Windows/System32)
	Done: try if F8 + load unsigned drivers works.
		Yes it does.

Done: Install DRBD Linux peer VM
	Ubuntu Server? Took Ubuntu 16.04 Gnome edition
	Installed drbd from git repo
	Update: we are using the production VM since not enough
	RAM for running 3 VMs.

Done: Add volume to Windows VM for DRBD test drive.

Done: logging: syslog server (see how it is done)
	Currently checking DebugViewer (but doesn't survive blue screen)

Done: Run DRBD with provided config file
	One Windows one Linux peer, with added Volume as backing
	storage.
	However there are many issues, see KNOWN-BUGS

Done: send public key to upstream

Done: Add build instructions to repo

Done: revert (make invisible) last 3 patches from upstream

Done: git pull last commit

Done: rebase dev branch to upstream master

Done: Merge into 

Done: drbd-adm: For now, have two different entries (NT-style, UNIX style)
	have win-disk and win-meta-disk in addition to UNIX style
	disk device paths. 

Done: Reconfigure drbd-utils with sane paths (/usr/local/etc ->
	/etc) 
	Problem is that drbdadm fails because some path does not
	exist.

Done: fix the syslog printk code to print all messages
	At least partially .. print all messages to the local
	Debugging facility (use DbgView.exe to see them), when
	IRQL is higher than DISPATCH we must not sleep and cannot
	send UDP packets. 

Done: Why does DRBD crash when loaded at boot time?
	Because signature is invalid. Boot windows with 
	F8+Allow invalid signatures.

Rejected: kernel: keep track of opened HANDLEs and struct drbd_block_devices
		(but please not in VOLUME_EXTENSIONs they don't belong there)
Rejected: kernel: Use that handle for I/O on backing device
	This is probably too slow. Keep the current device stack
	approach.

Done: kernel: win4lin: see if symlinks work
	We need to resolve them (ZwQuerySymbolicLinkObject), Done

Done: drbdsetup should translate NT-style pathes to NT kernel internal
	style pathes (this is easy)

Done: drbdmeta should accept NT-style pathes
	Problem is that /dev/sda and /dev/sdb is sometimes
	swapped (see KNOWN-BUGS) 

Done: We need to use NT-style I/O functions for drbdmeta
	(ReadFile, WriteFile) in pread/write_or_die()
	and use NtOpenFile() (need to load address
	from NTDLL.DLL).

Done: Open backing device:
	Need to reboot Windows to make it work. Right now I don't see any
	possibilty to attach to the device stack without rebooting
	(maybe pnp manager can be told to reiterate disk devices somehow..)

Done: For some disk sizes, NtReadFile fails with EOF reached
	(0xc0000011)
	Root kit?
	Update: No, seems to be a NTFS kind of hack. With cygwin it
	works. Our version fails on NTFS partitions (which don't contain
	DRBD meta data anyway), so we can work around it.

	We just print a warning and terminate now.

Rejected: Have NTDLL functions in separate file?
	Without knowing struct format internals.
	We are using WIN32 API which is not that wild.

Done: D: -> \\DosDevices\\D: also in drbdmeta
	Done

Done: check if drbd-utils compiles on Linux.
	No it doesn't. Netlink port was unclean (doesn't #ifdef __CYGWIN__)
	takes some time to repair.

Done: Revert the win-disk patch later to use only 
	NT style disk device paths (win-disk becomes disk, UNIX
	disk device paths are not used any more).

	We need to patch drbdmeta for that.
	Update: Patch is there, need to revert and test.
	Reverted and tested.

Done: printk_syslog(): collect the messages in a ring buffer and send them 
	later.
	Nice-to-have, do that later.
	Done it, it is good to have it for further work.

Done: Locking for ring buffer

Done: IRQ message should go before current message.

Done: printk_syslog(): merge logging functions of
	jt/logging-fixed-and-windows-boots-with-signature-check-disabled
	into master and push

Done: IP address of logging host should be configurable (Registry?)

Rejected: fix driver signature
	Don't know how this works..we now use Windows Test Mode to 
	avoid pressing F8 all the time.

Done: integrate INSTALL-DRBD-admin.bat in Makefile.win

Done: Merge changes to master (including drbd_thread_setup non-static)
	and push.

Done: Frees in Completion routine: is the memory freed by lower level
	driver?
	No it is Paged and accessed in an IRQ routine.
	Update: Now returning MORE_PROCESSING_REQUIRED and the
	blue screen disappeared.
	See https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/constraints-on-completion-routines :
		"After calling IoFreeIrp, the completion routine must return STATUS_MORE_PROCESSING_REQUIRED to indicate that no further completion processing is needed."

Done: fix 0x4e blue screen on drbdadm detach / down
	Last message: 
drbd_bm_resize <6>drbd w0/17 minor 26, ds(Diskless), dvflag(0x2000): drbd_bm_resize called with capacity == 0
	
Done: Make it work with DRBD from September

Done: Do we really need all those IOCTLs?
	drbdcon does not exist in WinDRBD, new ioctls are not 
	needed.

Done: use gtest to write tests.
	Probably for some tests where we need to call Windows API functions.
	Maybe we can extent agruen's test suite to call mini binaries.

Done: What we would need is something that overwrites Windows' default
	behaviour of determining device sizes (when Meta data is
	internal we want to report only the payload size without
	the meta data).

	Update: With the new architecture this comes for free.

Done: Have a lower level device for drbdmeta for access of internal
	DRBD meta data while resource is up.
	Update: with new architecture this came for free.

Done: Have other device extension with only the fields we
	need.

	We now disabled mvolAddDevice (by returning NO_SUCH_DEVICE,
	else we blue screen because some verifier) so volume
	extension does not exist any more (except in non-accessible
	code). 

	Update: maybe the struct block_device should be the windows
	device extension, so we safe a intermediate data structure.

	Update: That's what we do now. While having NT kernel internal
	variables inside linux structures seems like bad design at
	first, it saves a lot of (unneccessary) work. For example
	we now have the offset and io_stat used by 
	win_generic_make_request() internally as part of the struct bio.

	Done: Next thing is to have replacment data structure so
	that attach works again (create block_device with target
	device looked up in find_target_dev). Also get I/O on
	that target dev working (used to blue screen but maybe
	it works now that we do not create a device in AddDevice())

	Update: for DRBD devices device extension is now struct
	block_device. 

	Update: after long research (and with help from a stack overflow
	kernel guru) we solved the blue screen and now do not do 
	AddDevices any more.

	Rejected: check if generic_make_request can use the ZwCreateFile
	API (instead of creating an IRP)
		I/O on the backing devices work now (again) with the
		IRP API.

	Done: remove devices in bdput destroyer.
	Implemented but cannot test it now, it is newer called from 
	drbd_destroy_device (which is also never called).
	Update: calling it now from drbd_unregister_device(). Works.

	Done: bdput in drbd_create_device on failure.

	Done: clean up code, delete commented out code.

	Done: size fix (with external meta data something destroys the
	disk size setting, so that drbdadm up / down only works once).
	Update: this doesn't happen no more.

	Done: clean up block devices created by blkdev_get_by_path().

	Done: keep an internal list of struct block_devices created
	for backing devices (so that internal meta data works again).
	and don't have more than one struct block_device per physical
	partition.

	Works now (again) with internal meta data.

Done: Redesign of architecture.

	Currently the DRBD device is stacked atop of the low level
	Disk drivers. This way all I/O goes through the WinDRBD
	driver also that of the non-drbd drives (like C:, ...).
	An Active flag controls whether I/O is routed through
	DRBD or not.
	
	One major drawback is that once the Active flag is set
	we cannot access the lower device. This is needed however
	by drbdmeta.
	
	We want an architecture that is more close to that one
	of Linux where DRBD devices and backing devices are different
	device objects, even for the Windows kernel.


Done: Try to put I/O on DRBD device.
	This will be the same device as if there was no DRBD (use
	the drive letters).

	Update: Started setting the Active flag automatically from
	within DRBD (currently only at successful attach, later
	also on connect. Somewhere else?).

Done: Unset the flag on down / detach. Or better set it on
	becoming primary, clear it on becoming secondary (let
	DRBD do the checks).

Rejected: Remove check in mvolWrite(): DRBD should do this.

	Update: Currently drbd_open() fails because of some
	auto-promote mechanism that never happens. It seems
	that the synchronisation (wait_event_interruptible()
	and the like) are broken.

	Update: We now try to have a separate Windows device for drbd
	and backing device this is more close to what DRBD under
	Linux does.

Done: Create patches for DRBD for recent changes.

Done: README.md

Done: Submit current sources.

Done: make format H: work

Done: Writing partition table should not fail.

Done: Fix sharing violation problem.
	Currently find_windows_device fails (as it should) calling
	IoGetDeviceObjectPointer() (before it can check the list
	of already open backing devices, these are currently indexed
	by exactly that pointer) because close_backing_dev is currently
	not called on detach. The reason is probably that schedule_work()
	mechanism is implemented wrong in windrbd.

	Update: drbd_destroy isn't called because the rcu mechanism
	is not implemented (or not implemented correctly) in windrbd.
	Do that after 0.2

	Update: sharing violation now fixed, however now there is
	an IO ERROR: neither local nor remote data which is new.

	Update: We now shift the backing device by one sector so
	that Windows NT does not recognize the backing device as
	NTFS (or whatever) formatted. This solution works quite
	well for us and also prevents Windows NT from replaying
	journal before the DRBD device is brought up.

Done: Fix IO ERROR
	It seems to come from an 0xc0000022 (access denied) error
	from the lower level device.

	Update: Error was not propagated to user space, this should be
	fixed now.

	Update: error c0000011 on accessing meta data (end of file
	error) when meta data is internal.

	Sectors are now shifted, see sharing violation problem.

Done: where did the volsize blue screen disappear.
	When using IRPs on an NTFS formatted partition, we had
	blue screens which do not happen any more. This is strange.

	Update: Also does not blue screen when meta data is internal,
	however apply-al does not work (error c0000011 (end of file)
	when reading meta data).

	Sectors are now shifted, see sharing violation problem.

Done: when there is NTFS on the backing device drbdadm up fails
	(with internal meta data) because it cannot access meta
	data.

	Plus there is a blue screen when changing from internal
	to external meta data. (This might be a windows internal
	bug tough).

	Update: No it was something else..Irps don't work with
	getting volsize of an NTFS partition, rewrote it to 
	use ZwXXX() API, now we have problems with sharing
	violations.

	Sectors are now shifted, see sharing violation problem.

Done: DeviceControl (there are many more but those
	are the ones called when the device is opened):

Done: implement I/O handler stubs
	Stubs done, return STATUS_OK (or STATUS_NOT_IMPLEMENTED)

Done: nc test
	Works as expected.

Done: Fix Spurious timeout error on receive.
	Was behaving as intended.

Done: hack test

Done: Make drbd run on peer Linux box
	We cannot run 3 VMs on our Macbook Air since it has only
	4 GB of RAM. Now, we are using the production Linux box
	for DRBD peer.

Done: make drbdmeta be able to read near the end of an NTFS 
	partition.
	We now hide NTFS from windows when it is a backing
	device.

Done: tcpdump nc and drbd and see if there is a difference.
	Didn't find anything yet, however there must be
	something. Look at the packets with hex?

	Update: The packets were received but on the windrbd side
	the 80 byte handshake parameter packet never is received
	(it is sent by Linux DRBD).

Rejected: schedule_timeout_interruptible not implemented correctly.

	It just does a wait on single object with a timeout object. so it
	isn't interruptible.

	If solved then also write a small test for it.
	
	Update: No it can only be interrupted by a UNIX signal
	(which does not exist on Windows) so the implementation
	is correct.

Done: Who is supposed to wake up schedule_timeout_interruptible() in
	dtt_connection_established()?

	Ask phil or lars. Don't want to dig too deep into DRBD now.

	Those two are needed to make connection work.

	Done: Nobody.

Done: Make connection work.
	It seems that kernel_recvmsg() does not receive anything
	from the windrbd side (it fails with an EAGAIN error
	reproducible).
	If DRBD on Linux is replaced by a ncat we can see the
	packets arriving on both sockets: 
ncat -l 7600 -k | hexdump -v
0000000 7483 6702 f1ff 0000 7483 6702 f2ff 0000

	Update: If connection is established in the order
	connect send connect send the first packet is received.

	Done: Write a small C program (with gcc) to test that from user
	mode. 
	It works non-interleaved (is a cygwin program)

	Now, check tcpdump output.
	TCP checksums are wrong but this is most likely due to 
	checksum offloadinng (they are correct on the wire only
	the network card displays it wrong).

	Apart from that the packets seem to be equal (sequence number?)
	Update sequence number is Wireshark connection ID.

	Update: difference is that Linux DRBD upon incoming connection
	tries to reach windrbd which fails because windrbd makes a
	bind but no listen currently. What is strange is that 
	connect() on Linux side succeeds while we see a RST in 
	the TCP packet coming from windrbd (but that is maybe
	because the socket is non-blocking on the Linux side).
	
	We now patch Linux DRBD so that connect(2) always fails and
	see if that works.
	Update: unfortunately this did not fix the error.

	netcat on the windrbd port shows that connection is
	accepted(?) but closed immedieately

	Update: No packets get lost. The initial packets are received
	and the 80 byte handshake packet is sent to windrbd.
	However there it is never received (drbd_recv_short
	is never being called by windrbd). So the whole
	thing was because receiving the handshake packet
	(80 bytes) is not implemented on the windrbd side.

	Rejected: write 2 C (user space) programs that show how this
	scenario looks like in POSIX environment (bind without listen
	and connect returning 0)

	Update: Reasons were:
		ping timeout was set incorrectly.
		peer (Linux) disk was too small.

	So in fact it always worked. Arghhhh!


Done: blkdev_put isn't called on drbdadm down

	fix this one day, this is probably a DRBD9 bug. Or maybe
	it is intentional.

	INIT_WORK and schedule_work do what they say?

	Later: Currently bdput is called from within drbd_unregister_device,
	ask phil if that is ok (it should make the device invisible, which
	is what it does).

	Update: this is something with RCUs

	Update: call_rcu now does something, is this fixed now?

	Update: Yes it is. Closed.

Done: implement open and close methods.

Done: Right now, windrbd isn't listening for incoming connections.

	Connection should work nevertheless.
	Update: setting event mask correctly now, incoming
	connections work (tested with disabling outgoing connection,
	the DRBDs eventually connect anyway).

Done: eliminate bio_databuf fields.

Done: Have sshd on Windows and work remotely
	Would be convenient, however setup is a little bit
	complicated ...
	This is a nice to have.

	Yes it works. Needed to add a /etc/groups file with
	correct contents.

Done: errnos should match linux error codes
	(so that errno cmd line tool works).

Done: get cygwin chmod working.

Done: Implement multi page I/O

	Required for DRBD sync

	Currently fixing some blue screens: on multiple page I/O
	one issue was fixed (length of first MDL was wrong), now
	when doing a:

	drbdadm up
	drbdadm cstate == connected
	drbdadm down

	we crash (PFL something)
	when we do

	drbdadm up
	drbdadm cstate == connected
	drbdadm detach
	drbdadm disconnect
	drbdadm down

	everything works. So disconnecting when we have a backing
	device is what doesn't work. Also:

	drbdadm up
	drbdadm cstate == connected
	drbdadm disconnect

	Crashes on disconnect

	Update: Reason most likely a buggy implementation of
	mempool_free() in windrbd. (see drbd_bitmap.c:drbd_bm_endio
	around line 1074: if that line is commented out, no
	crash). mempool_free probably should not free the page
	itself, have reference counting on the page.

	Update: Problem fixed for now. The real problem is the
	question of who owns the memory pointed to by the MDLs.
	There seem to be other instances where the DRBD endio
	routine frees memory and also if we comment out MDL
	freeing we get a blue screen when syncing (at the end
	of format h: command).

	Update: We still have I/O errors however BSODs are gone.
	We now check if MDL has MDL_PAGES_LOCKED set (which is
	only the case for the first entry) before calling
	MmUnlockPages().

	TO DO is to check where the I/O errors come from.

	Jan 11 15:25:13 192.168.56.101  U14:24:54.369|0131bb50 __drbd_chk_io_error_ <3>drbd w0/17 minor 5, ds(Failed), dvflag(0x2c): Local IO failed in __req_mod. Detaching...

	Update: fixed. Was a wrong bi_vcnt in irp_to_bio (windrbd
	toplevel device object (H:)).

Done: windrbd-test destroyed (!) partition table?
	Yes it does (set_partition_info test). Now protected by
	an interactive query (unless --force is given).

Done: make write_whole_disk test work.
	Only fails when connected. Works when primary and disconnected.

	Update: stalls at sector 73924 when primary and disconnected.

	Update: connection fails from time to time and we need to
	reconnect.

	Update: works when unconnected (except the aforementioned stall,
	which we cannot reproduce at the moment).

Done: all I/O should fail when Secondary
	Important.
	Done. format h: however does not display an error (but
	this is a format problem, the data on disk is unchanged).

Done: Throw away lots of Mantech code.
	Mostly done.
	Get rid of PVOLUME_EXTENSION as well.
	Done

Done: Release backing device:
	drbdadm up / drbdadm down / format f:
	Not clear what this means. It works for me.
	Reopen that when it bites.

Done: test external meta data
	Currently running with external meta data

Done: write sometimes stalls when there is too much logging.
	Solved: this is a bug in VirtualBox (network is down
	and write test runs from network share).

Done: Cannot mount NTFS after sync.

	johannes@johannes-VirtualBox:~/Linbit/tmp$ sudo mount /dev/drbd26 -t ntfs mnt/
	ntfs_mst_post_read_fixup_warn: magic: 0x00000000  size: 1024   usa_ofs: 0  usa_count: 65535: Invalid argument
	Record 0 has no FILE magic (0x0)
	Failed to load $MFT: Input/output error
	Failed to mount '/dev/drbd26': Input/output error
	NTFS is either inconsistent, or there is a hardware fault, or it's a
	SoftRAID/FakeRAID hardware. In the first case run chkdsk /f on Windows
	then reboot into Windows twice. The usage of the /f parameter is very
	important! If the device is a SoftRAID/FakeRAID then first activate
	it and mount a different device under the /dev/mapper/ directory, (e.g.
	/dev/mapper/nvidia_eahaabcc1). Please see the 'dmraid' documentation
	for more details.

	Update: It seems that somebody writes to the DRBD device (what we
	did is write it while unconnected, then copy drbd device on windows
	to a file and then connect the DRBD to linux wait until sync is
	finished and then copy the Linux contents to a file and diff the
	hexdumps of both files). Either Sync is broken or somebody writes
	the device where he shouldn't. Update: windows data seems to be
	correct, so sync is broken.

	Strange: DRBD does not sync while all bits are set in bitmap.

	Update: when copiing the dumped DRBD block device from windows
	to Linux, it also fails. Maybe the Linux NTFS driver is buggy?

	Update: when using external meta data and copy the backing
	device (F:) via scp we can mount the NTFS partition with
	ntfs-3g (Update: also with mainline kernel ntfs driver)
	The backing device must be patched so that where it says
	DRBD it should read NTFS in the boot sector (can be done
	with vi).
	It is clear that copiing the DRBD device (instead of the
	backing device) does not work because Windows hides the
	last 8 sectors.

	Update: It seems that the invalid pages point to somewhere
	where windows kernel alloc tags (like WD4E, E4DW in the source
	code) are. So we have an invalid pointer (use after free?)
	problem.

	Check if all pages are transferred first and then validate
	the pointers.

	Test was made with write-test.sh not with NTFS (so NTFS
	driver isn't the problem)

	Update: Problem was that Length of I/O was only the first
	MDL entry not the total length. Should work now. TODO:
	test with NTFS.

	New blue screen: IoBuildPartialMdl was called with a
	virtual address outside the range of the source Mdl.
	When syncing.

	When restricting max number of MDLs to 16 we do not
	blue screen but data is corrupt (at offset 0x1000
	which cannot be explained by the 16 MDLs limit).

	Update: we have 3 errors here: one is that we cannot
	read more than 64K (16 Pages/MDLs) without blue screen
	one is a page fault blue screen (which does not always
	happen) and one is a data corruption between
	DrbdIoCompletion and sending the packet.

	Update: error #3 (data corruption is because 
	_drbd_send_zc_ee is wrongly patched by windrbd. 
	Undo this patch and it should work. Update: yes
	it does.

	Update: Mount works now. Error #2 (page fault blue
	screen) is most likely fixed. Error 1 is TO DO.

	Update: NTFS mounting works now, however there
	is a blue screen when reading more than 64K
	from the backing device. Making seperate TODO.

Done: BSOD sometimes when syncing

	Update: New blue screen page fault in non paged area
	(when waiting before connecting) Update: this is probably
	fixed by locking all the pages into memory. Observe
	and reopen this if it happens again. Update: happened
	again.

	Update: the page fault in non paged area BSOD reappeared
	(while Syncing).

	Update: again, while syncing (2 times in a row)

	Update: again, while syncing (and not freeing pages)

	Update: Fixed something in drbd_main.c this should
	not happen any more. Reopen when it occurs again.

Rejected: fix freeing bio without irp.
	Not to fix. DRBD sometimes allocates bios without ever
	calling generic_make_request on them.

Done: fix memleak in getting volsize.

Done: use after free blue screen after patching bio split in.

	When not freeing mdls and irps and not freeing the bio
	it disappears. Not putting the bio in upper device does
	not help. Nor does not freeing the buffers themselves
	(in __free_page()).

	Now holding reference to bio in generic_make_request this
	seems to solve the problem.

Done: Cannot read more and 64K (16 MDLs) from backing device.

	Blue screen shows STOP: 0x0000012E (0xFFFFFA80037AD980,
	0xFFFFFA80039951A0, 0xFFFFFA800669F000, 0x0000000012000)

	Update: According to:
	http://osronline.com/showThread.CFM?link=204514
	this is a known bug in some Windows versions (esp.
	Windows 7 Professional 64 bit), while it works
	in other versions. We should restrict the number of
	sectors read/written to max 128 and test this on various
	windows versions.

	Update: not possible to patch DRBD not to use more than
	128K because this is an over the wire parameter (would
	have to patch linux DRBD as well). Implement solution
	that splits the bios into smaller pieces.

	Update: its 128K (32 pages) according to our experiments.

	Update: Implemented but currently leaks IRPs.
	Update: fixed leak seem to work ok (except blue screen
	when formatting and drbd is connected). This is now a
	separate TO DO since it also happens when doing something
	(writing) to the DRBD device and the resources are connected.

Done: Network goes down while sync. When syncing an NTFS partition only.

Jan 20 12:46:05 192.168.56.101  U11:46:05.795|0393cb50 find_request <3>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x2): receive_DataReply: failed to find request 0x136c6c00, sector 26160s
Jan 20 12:46:05 192.168.56.101  [last message was in IRQ context]
Jan 20 12:46:05 192.168.56.101  U11:46:05.795|0393cb50 drbdd <3>drbd w0 pnode-id:1, cs(Connected), prole(Secondary), cflag(0x200a), scf(0x1): error receiving P_DATA_REPLY, e: -5 l: 4096!

	This seems to be fixed by the > 32 bio_vecs patch.

Done: check 2 patches using bio_databuf
	bio_databuf is gone. So are the patches.

Done: with DRBD: 500 kB/sec (unconnected) without 900 kB/sec
	500 kB was with lots of debug output. Now we have 600 kB/Sec
	a bit better.
	without DRBD: 983.71 kB/Sec
	with DRBD (unconnected): 586.25 kB / Sec

	Update: with 1Meg write requests it is very fast. So
	the problem seems to be the OS overhead (both DRBD
	and NT kernel)

Done: The functions enclosed by _WIN32_MVFL (see win4lin/src/util.c) are
	not referenced anywhere in the code. I assume that they never have been
	tested. I would like to remove them (or at least rewrite them if the
	functionality is needed) since they depend on some other stuff I would
	like to redesign.

	Update: We need the functionality if DeviceIoControl() (user level
	function) is called on the DRBD device. So leave it in for now.

	Update: We don't want any DRBD specific DeviceIoControls. Check if
	one of those are really needed and then remove the code.

	Done. We removed about 4000 lines of code.

Done: drbd w0 linbit-wdrbd: error receiving P_RS_DATA_REQUEST, e: -22 l: 0!
	Update: didn't observe lately (with 0.3.7) but I am
	pretty sure it is still in there.

	Hopefully fixed by multiple requests patch.
	Update: No it isn't. Just happened while Windows was SyncTarget.

	Update: bm_op was returning unsigned long instead of 
	ULONG_PTR. Fixed by patching DRBD.

Done: Test windows being SyncTarget
	Works now, error receiving P_RS_DATA_REQUEST was fixed.

Done: PFN list corrupted when connected and I/O is on windrbd device
	Just reappeared again when sync completed and windrbd was
	SyncTarget.

	Update: We now unlock the mdl page's memory created by
	IoBuildAsynchronousFdsRequest() right after creating the
	Irp. Furthermore we now use MmBuildMdlForNonPagedPool()
	since the page memory is from NonPagedPool. It seems to
	work now. Please reopen when blue screen happens again.

Done: IRP_MJ_SHUTDOWN (0x10) not implemented.

	Update: Implemented but does not get called if we
	never access the DRBD device. This functionality should
	be in a one time called function.

	Update: shutdown done when the root device object is
	shut down (exactly once).

Done: it seems that free_page crashes sometimes (0x1E)

	Reactivate the hack to see if it crashes there.

	Update: No free_page is ok. Crash is because there are
	still drbd resources on line while we free all buffers
	(which is generally not a good idea). For now don't do
	anything on shutdown, we should see how Linux DRBD behaves
	on forced system shutdown.

Done: logical block sizes do not match (me:512, peer:0); this may cause problems.
	Fix this (should be easy)

	Update: Reenabled assign_p_sizes_qlim() in drbd_main.c
	this should have fixed it.

Done: data corruption when doing a 

	cp /dev/urandom /cygdrive/h/random-file

	and diff it against the synced linux ntfs.

	Maybe this is a sync error.

	Update: bio->bi_sector was set wrong when splitting
	the bio in generic_make_request. Is fixed now.

Rejected: compile user space apps with MinGW
	Isn't meant for POSIX apps

Rejected: Error receiving P_STATE on Linux on split-brain.
	Phil says this is normal

Done: Test with Windows 10 (we have to do that anyway some day)

	Installing to Linbit supplied test machine.

	Driver loads (with TESTSIGNING ON) userland currently fails 
	to find POSIX root (/) dir (/etc/drbd.conf not found).

	Update: works. When accessing windrbd device (dir h:) it
	blue screens
	Update: Blue screen fixed.

	Connection currently unclear (error receiving initial packet).
	With netcat a TCP/IP connection works.

	Update: Was a split brain.

	Except for a sync instability windows 10 now works as good
	as windows 7 (including logging)

Done: Fix logging errors

Done: Have DRBD and windrbd release number in log and properties of driver

	Review. And there is a bug in printk() ring buffer which causes
	corrupt initial log messages.

	Put DRBD and windrbd version number in 1. dialog of self extracting
	exe

Done: make install package
	self extracting exe or msi file.
	Know how to do it (iexpress.exe) do it properly once
	everything else is done.

	Works almost .. we however have to compile user space utilities
	with MinGW, which would use native Windows DLLs. Currently
	bundling with cygwin fails because the POSIX root (/) cannot
	be set to the cygwin path.

	We should switch to msi based install. Or at least get rid
	of the Must reboot now panel, because userland tools are installed
	later.

	Check the GPL line feeds.
	Get rid of reboot now message (change type of driver?)
	Make userland use C:\windrbd as cygwin root (take care not
	to destroy existing Cygwin installations)

	Update: setting StartType to 3 (on demand) makes windows not
	boot. Try this with a freshly installed windows.

	Also blue screens on a virgin windows (well almost..) we
	skip this for now and try again later.

	For now, self extracting exe should be fine. But install
	userland before reboot message appears.

Done: Install userland before driver
	So we can safely reboot.

	This is now done by calling infdefaultinstall from
	within the cmd script (as last command). infdefaultinstall
	needs a path (even if it is the current working directory,
	so do infdefaultinstall .\drbd.inf

	Eventually we want to have msi.

Done: install c:\windrbd filesystem hierachy

	Had to include cygwin's unzip (plus an extra DLL) in package

Done: Remove most registry keys.

	Also do not create them on installing windrbd.

Done: In progress: reinstall windows 7 and check if last 4096 bytes in NTFS
	are still hidden.

	They seem to be under Windows 10.

	Update: Need cygwin to run tests (else WriteFile will always
	fail with error 87 Invalid Parameter, even on a newly created
	partition when running from cmd shell). However I/O returns
	5 (Access denied) when accessing an NTFS partition. So the
	answer is yes.

Duplicate: Logging Eventlog? windrbd server localhost UDP.

Duplicate: In progress: allow user to pass name of symbolic link created
	(i.e. the drive letter) via drbdadm/drbdsetup/kernel

	Update: This should be userspace-only. It should
	also be possible to mount the device upon an
	empty NTFS folder (later).

	At this point also clean up drbd-utils (separate
	files for UNIX and Windows) and integrate upstream
	changes (later).

	Update: we wait for our patched drbd-headers to
	appear on github.

	Update: Created windrbd utility that does it. For now
	users have to execute it manually (it creates drive letters
	only for the user that runs the script which might be
	confusing since drbdadm usually runs as administrator).

	Later, remove the drive letter magic from the kernel driver.

	Nice-to-have: a list-drive-letters command.

	Update: find out how to set drive letters visible to
	all users.

	Update: syntax is:

	device "l:" minor n

	which is quite intuitive

Done: Windows to Windows test: blue screen on both sides on drbdadm up

	Is when backing device contains an NTFS filesystem (which
	is normally not the case, but it shouldn't blue screen).

	Maybe it is in general not a good idea to attach to a backing
	storage containing a file system, because this means that the
	user has done something wrong. (We are patching NTFS<->DRBD,
	so a valid windrbd NTFS contains DRBD as filesystem magic)

	Update: when there is a file system on the backing device
	Windows still crashes.

	We now refuse to attach backing device when it contains
	a file system. Formatting an attached file system currently
	force detaches the device, this is not exactly what we want
	There should be a mandarory locking preventing all I/O
	(except DRBD) on the backing device. Do that later.

Done: When playing with show / hide filesystem blue screen on attach.
	1D (1E?)

	Occured again. Please fix this.

	drbdadm up w0 		# fails to attach
	windrbd hide-filesystem f:
	drbdadm attach w0
	drbdadm primary w0
	ls /cygdrive/h		# blue screens

	Windows seems to cache the file system separately (something
	like Linux' directory cache). Solution would be to unmount
	and mount again it on hide-filesystem (already tried manually
	with mountvol utility). Update: there seem to be some sort
	of reread filesystem mountvol delete does.

	Update: Obviously our patching NTFS <-> DRBD of the filesystem
	bootsector at offset 3 isn't enough .. we need to patch more
	than that. Update: no it isn't. Need to call mountvol to
	remount volume, works now with Windows 7 Windows 10 unclear.

	Reopen when it happens again.

Done: windrbd hide-filesystem <drive-letter/GUID>
	also show-filesystem and filesystem-state
	no GUID yet.

	In progress: umount / mount Volume on hide-filesystem
	to clear windows directory cache (else drbdadm
	up / drbdadm primary / accessing the windrbd device
	will blue screen)

	We now call mountvol directly, it works on Windows 7
	but not (always) on Windows 10 (but maybe this is
	another BSOD)

Done: windrbd log-server -o logfile

Done: Use Linbit certificate to sign driver.
	It should be trusted.

	We have a certificate now, but the root of this certificate
	isn't trusted by Windows 7.

	Phil is currently trying to get a proper certificate.

	Update: Works now, but build / sign process is a little
	bit clumsy. Need to copy files manually and patch
	Windows Makefile.

Done: Don't install cygwin1.dll when cygwin is found on the target.

	Now, taking cygwin1.dll from existing installation. Done:
	Test if this works.

Done: IP address of "Closing unexpected connection" printk is still wrong

Rejected: also test with 32 bit version of Windows 7
	(does it exist for Windows 10?)

Done: clean up the registry
	Except for logging IP we don't need anything IMHO

Done: windrbd.exe hide-ntfs-partition

Rejected: We want to see the syslog output when the system did boot, not
	only when we configure a DRBD device.

	This is sometimes practical.

Done: Implemented flushing for WinDRBD device.

Done: hide backing device from Windows on attach.
	This can (?) be done from user space by including
	windrbd hide-filesystem automatically on drbdadm attach
	(and maybe show-filesystem on drbdadm detach).

	Doing it from kernel does not "add value" .. it would just
	be extra effort (and might fail, since we had troubles
	with ZwCreateFile()).

Done: windrbd show/hide filesystem also with GUIDs.
	
Rejected: show filesystem on drbdadm down (not on detach).
	Instead instruct the user how he could do it.

Done: most windrbd command should also take GUIDs (show-filesystem, ...).

Done: drbdadm should call windrbd to assign the drive letter

Done: remove 'C'+minor magic from kernel
	Maybe: generate a GUID in kernel and create a Volume{GUID}
	entry. So we can assign the drive letter for all users.
	Update: create a GUID once and hardcode it in the driver /
	windrbd utility.

	Update: implement IOCTL_MOUNTDEV_QUERY_DEVICE_NAME
	to return /Device/Drbd5, and check if this is being called.

	Update: have to register device with mount manager, which
	currently fails with invalid device request.

	Update: have drbdsetup new-minor --mount-point parameter
	now, drbdadm uses the device name for the mount point.

Rejected: assign-drive-letter should assign drive letter for all users.
	Still there, but we are not using it. Now there is an extra
	field mount-point in new-minor. 

Rejected: delete drive letter also on drbdadm down.
	Problem is that on down there is no volume. Maybe we have to
	iterate over all volumes.
	Superseded by mount-point flag in new-minor.

Done: drbdmeta called before hide-filesystem and fails
	(on drbdadm up / format f: / down / up)

drbdsetup new-resource w0 2 
drbdsetup new-minor w0 5 17 --mount-point K: 
drbdsetup new-peer w0 1 --_name=ubuntu-gnome --use-rle=no --protocol=A 
drbdsetup new-path w0 1 ipv4:192.168.56.101:7600 ipv4:192.168.56.103:7600 
drbdmeta 5 v09 F: internal apply-al 
windrbd -q hide-filesystem F: 
drbdsetup attach 5 F: F: internal 
drbdsetup connect w0 1 

	should be 

windrbd -q hide-filesystem F: 
drbdmeta 5 v09 F: internal apply-al 

	Update: Done, but this is still invalid. After formatting
	the backing device, meta data gets destroyed. Need to redo
	a create-md.

Done: Cannot format virtual drive.
	Regression introduced recently (right before windrbd-0.6.0)
	
	Impletented Done: test it when we have internet again (just
	format k:, should run without error), works

Done: up / down: down fails with failed to detach
	Fixed, was problem drbd_release() when drbd_open failed before.

Done: Blue screen when opening windrbd_control (root device object)
	with WinObj

	DriverVerifier expects IRP requests to succeed (at least create
	close and cleanup)

Done: receive_DataReply: failed to find request 0x1a186c00, sector 25896s
	When writing on Windows DRBD.

Done: error receiving P_RS_DATA_REQUEST, e: -5 l: 0!

	On windows side when syncing.

	Also:

	linbit-wdrbd: error receiving P_STATE, e: -5 l: 0!
	on windows side on connection establishment.

	Update: The later is because of a split brain. For now
	resolved it by re-creating meta data in the Linux side.

	Update: this seems to be correlated with the data corruption
	bug. Update: no it isn't data corruption happened when accessing
	the backing device.

	Update: it is also (or only) on Linux side.

	Update: error receiving P_STATE on split brain should also not happen.
	But low priority.

	Update: this error is not so critical, do that later

	Update: peer has no local data:

Feb 14 16:08:05 johannes-VirtualBox kernel: [ 4722.510438] drbd w0/17 drbd26: Can not satisfy peer's read request, no local data.

	So maybe this behaves as expected.

	Was typedef char bool which caused is_write_request() to
	always return 0.

Done: blue screen on writing while connected.

	Also reported by Devin.

	Reason is (most likely (Update: yes that was it)) that
	the bi_vecs contain elements bigger than PAGE_SIZE which
        isn't supported by DRBD (when it comes to sending pages).
        On fixing this (at windrbd level, see irp_to_bio) we
	introduced a new error which causes formatting to fail.

	Update: Fixed a bug that caused formatting to fail.
    
	But not the read/write tests of our testsuite..we probably want
	to cover this case too. Formatting works now, as well as writing
	to windrbd device while it is connected (also writing on the
	remote side while being connected works).

Done: remove the #ifdef _WIN32 defines

Done: Segmentation fault on drbdadm invalidate

	drbdadm invalidate-remote works.

	Should be fixed, was easy.

Done: drbdadm del-minor should not call windrbd delete-drive-letter
	any more.

	Check if this is needed and remove that code if not.
	Done, removed. I don't think we still need this.

Done: new blue screen running (new) test.sh
	driver verifier again. Peer is not running (no connection)
	Reason was a missing IoCompleteRequest on windrbd_ioctl()
	when device was already deleted.

	Tested, no blue screen.

Done: DRBD windows to windows sync is very slow.

	Not clear if it is the network or something else.

	Update: it is not the network.

	I/O on Windows 10 is very slow also (format h: on a
	connected resource takes forever)

	Update: when connecting to windows build host it is
	faster (network is over the air), so maybe something
	with the Linbit Windows VM is wrong.

	Update: Devin (Linbit USA) also reported this.

	Update: Something between drbd-9.0.9 and drbd-9.0.13
	has been fixed to solve that (it is slow between a 
	9.0.9 and a 9.0.13 under Linux also (in one direction), 
	upgrading 9.0.9 to 9.0.13 solves that so it is fast in
	both directions). Also put

        disk {
                c-max-rate 4048000;
                c-fill-target 1048000;
        }

	into w0.res (at resource config level) on both sides.
	Then it should work. TODO: upgrade windrbd to 9.0.13

	Done, with 9.0.13 Sync is faster (14MB / sec instead of
	4 MB / sec), should be 50 MB / sec however.

	Update: between much VM (Windows 7) and Windows 10 sync
	rate is still at 200 kB which is way too less.

	Some printk's for researching slow sync show that requests are sent
	by 4k (instead of up to 1m) from the windows side (if windows is
	SyncTarget). Fix that and see if it is faster, then.

	Compared to Linux/Linux sync it is then still slower (about
	a factor of 3 or 4) maybe because Windows I/O is slower?

[ 3979.671662] KARIN cmd: 9 sector: 14336 size: 1048576
[ 3979.671665] KARIN cmd: 9 sector: 16384 size: 32768
[ 3979.780097] KARIN cmd: 9 sector: 16448 size: 32768
[ 3979.780121] KARIN cmd: 9 sector: 16512 size: 65536

	Windows sometimes stucks when replying to data requests (11ms
	pause).

	Update: Initialize max_hw_sects in queue.

	Now resync requests are sent in chunks of (up to) 1M which makes
	resync much faster (was 4K chunks, because max_hw_sects was 0).

	Right now, resync between Windows and Linux is still a bit slower
	(factor 4) than beween Linuxes, this is maybe because the I/O
	stack is slower under Windows (?).

	Update: Between win7 (much VM) and win10 sync gets stucked
	now (number is 0)

	Update: Research showed that when called via drbd_submit_peer_request()
	I/O on the backing device is very slow (reading 512kb takes over
	one minute). Dig deeper into the windrbd implementation and
	see why endio arrives so late (SyncSource was a Windows 10 box)

	Update: We found a performance leak in the Send() (wsk2.c)
	function. It completes synchrouniously, throughput is
	2 MBit/sec (4096 bytes / call). When switching to asynchronous
	completion this raises to 27MBit/sec. Problem is: how to
	free buffer memory (should be done by put_page(), however
	this is not implemented yet), and, much worse, error
	reporting (don't know yet how to solve this).

	Update: we had a version that worked (with SendPage()?) find
	it again. Update: Yes that was the working version. It performs
	well on our test setup (syncing with 100MBit/s, which is on
	the VM side the maximum). However there is a blue screen
	on PingAck didn't arrive in time (see separate TODO) plus
	one or two additional memory leaks. Performance problem
	seems to be fixed now.

Done: Memory leaks on SendPage()
	doing a put_page and MmUnlockPages()

Done: SendPage on sync always sends the same page.
	Probably there is data corruption.

	Update: No it isn't. Linux sendpage() has no callback,
	however uses get_page / put_page to keep the page allocated
	as long as it is needed. DRBD uses the page counter
	(page_count()) to detect this and does not touch pages
	with page_count > 1 (see drbd_peer_req_has_active_page()
	in drbd_int.h). windrbd's SendPage() works just the same
	(regarding get_page / put_page), so DRBD shouldn't re-use
	pages that are currently used by SendPage.

Done: Both sides are SyncSource??
w0 role:Secondary
  volume:17 disk:UpToDate
  linbit-wdrbd role:Secondary
    volume:17 replication:SyncSource peer-disk:Inconsistent
        done:0.00

	Same on other side.

	It seems that DRBD 9.0.13 fails to detect split brain
	correctly (downgrading WinDRBD to DRBD 9.0.10 detects
	the split brain). That seems to be an upstream problem.
	Report? 

	Update: No, upstream already fixed that. Upgrade to
	9.0.14.

Done: upgrade to 9.0.14
	9.0.13 fails to detect split brain correctly.

Done: Create file with version number

Done: Check in install script if it runs as adminstrator.

	I just ran into that ... it fails silently.
	Update: Now we check in cmd script, but eventually it
	should check earlier. We should switch to something
	sane anyway some day (msi?)

Done: Do not display Please reboot .. when installation is finished.

	INF install already does this.

Done: Device FFFFFA8004F2D4C0 accessed after it was deleted.
	Strange.

	Because we didn't unmount (dismount) the volume on drbdadm
	down. Should be fixed now.

Done: what is PnP minor 7 code?
	It is IRP_MN_QUERY_DEVICE_RELATIONS with TargetRelations what
	we are being sent. Currently handling this (correctly, as I
	assume, copiied that from reactos kernel) gives a BSOD.

	See PnP TO DO for more on this.

Done: On formatting: error message cannot write NTFS boot sector.
	Fixed. DRBD signature was also promoted to peer, which
	also shouldn't happen (also fixed).

Duplicate: Create windrbd device on becoming primary and delete
	windrbd device on secondary.

	Update: drbd_create_device needs to assign a valid
	this_bdev. Do not create Windows device in bdget, 
	instead create it on becoming primary and delete
	it (with checking for open references) in becoming
	secondary. This way we do not support auto promote
	(because the block device cannot be opened) but
	that is not so important.

	Update: Phil wants the auto promote feature (for
	virtualization), so alternative would be to
	patch the boot sector as long it is secondary. 
	However this does not solve the read cache problem.

	Update: Right now, we return IO error if a secondary
	resource is accessed via ReadFile/WriteFile. Eventually
	we want to declare the secondary resource offline
	but not sure yet how to do this.

	Rethink this and do that later.

Done: Windows 10 would require more testing.

	Blue screen THREAD_EXCEPTION_NOT_HANDLED when writing data
	while connected (on a NTFS filesystem). Maybe because of
	extensive logging. Update: happened again last log message
	is:
Feb 20 19:04:48 10.43.8.215  U18:04:48.392|51a96700 windrbd_thread_setup <6>[0xFFFFD40351A96700] stopped.

	maybe the rcu?

	Accessing directory (reading) from windrbd device stalls
	when connected (and syncing). Writing data works (but
	that is maybe just in the cache).

	Syncing is very slow at the moment.
	This is most likely a network issue (non-windrbd issue)

	Update: The above issues should be fixed now.

Done: upgrade DRBD to 9.0.12

	So Need Access to up to date data on drbdadm down is fixed.

Done: Cannot write first sector on format h:
	Sector seems to be alright (showing DRBD on the backing device
	and NTFS on the windrbd device). Not sure where this is coming
	from.

	Fixed. Needed to copy on write before patching.

Done: Device FFFFFA80038B03F0 accessed after it was deleted.
	After formatting and drbdadm down

	Fixed. Needed to FSCTL_DISMOUNT_VOLUME it.

Done: check what _WIN32_DEBUG_OOS is really doing.
	Dumping bitmap?

	Removed.

Rejected: have dump_stack function
	We don't have symbols.

Duplicate: Also allow for mounting windrbd device to NTFS folder

Duplicate: make ssh to Windows box work

Rejected: make windrbd use existing drbd-headers.
	Update: we made patches to the protocol (mount_point) and
	hence need a separate windrbd branch of drbd-headers.

Done: BSOD From Devin: kref_debuf_destroy ASSERT FAILED:

	2018-05-17T13:30:09.567725-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) bdget <6>Created new block device \Device\Drbd0 (minor 0).
	2018-05-17T13:30:09.569841-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:ASSERT FAILED
	2018-05-17T13:30:09.569841-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:object of class: device
	2018-05-17T13:30:09.569841-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:  [1] = 1 (struct drbd_peer_device / free)
	2018-05-17T13:30:09.569910-07:00 legolas.us.linbit  U20:30:09.548|d92da040(drbdcmd) kref_debug_destroy <3>:

	Causes (?) BSOD later.

	Update: No, but the BSOD was due to incorrect cleanups.
	Fixed now.

Done: fix kref_debug_destroy asserts should mounting fail.
	They do not hurt, but are ugly.

Done: check if one can build windrbd branch of drbd-utils from github.
	Waiting for Roland to push.

	Roland pushed windrbd (both drbd-headers and drbd-utils) and
	it works like a charm.

Done: Inform windows about new drive.
	So that explorer opens.

Done: Cleanly unmount windows NTFS on drbdadm down (or, later,
	drbdadm secondary).

	Currently, on drbdadm primary we get a panel showing 
	unclean filesystem. Also when mounting under Linux,
	it shows a warning. Chkdsk however works, and finds no
	errors.

	Update: Done, call windrbd_umount() on state change
	Primary -> Secondary *while still primary* (so that
	I/O still happens during unmount).

	Linux now does not complain about unclean shutdown.

Done: race on umount

	Just to be sure, delete the symbolic link once volume
	is opened for sending it the umount fscntl.

Done: invalidate read cache when becoming secondary.

	Problem is that if windows is primary, becomes secondary and
	then primary again the read cache is still filled from the
	former primary.

	Should invalidate when becoming secondary: reason is
	that while secondary requests still are served from
	the read cache (they should fail).

	Update: Moving that to beta2 because we are a little bit
	short on time. Document that defect.

	Update: Implement this for the next beta, there should be
	no windrbd device unless resource is primary.

	Update: It already works with mounting on becoming primary
	and unmounting on becoming secondary. Need to restructure
	code a bit because currently the block device is the
	Device Extension of the Windows device object (and not
	referenced somewhere else).

	Update: now creating windrbd device immeadiately before
	mount it (when becoming primary) and remove the device
	right after unmounting it (when becoming secondary).

	Works now as expected.

Done: mountmanager / register device with PNP

	Drive letter (mount point) is created now.

	Right now, need to log in / log out to make windrbd drive
	visible in explorer.

	Need to have a valid DeviceNode (that is attach it somewhere
	in the PNP device tree). It does not work to attach it to
	the backing device (backing device then becomes invalid and
	BSODs)

	This seems to be a little bit more complicated than expected..
	maybe attaching the windrbd device to the root device object
	helps? (But root device object also does not have a device
	node). Update: fails with PNP BSOD.

	See Microsoft driver samples for how to do this.

	Update: Most driver samples build atop of Windows driver
	framework, we use Windows device model.

	Update: We are now getting PnP IRPs when calling
	ZwFsControlFile( ..., FSCTL_DISMOUNT_VOLUME, ..); According
	to MicroSoft documentation, PnP manager does not send
	IRP_MJ_PNP unless anybody in the system (driver / user app)
	registers for PnP events (using IoRegisterPlugPlayNotification()
	for example).

	See https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mn-query-device-relations:

	Warning A device object cannot be passed to any routine that
	takes a PDO as an argument until the PnP manager creates a
	device node (devnode) for that object. (If the driver does
	pass a device object, the system will bug check with Bug
	Check 0xCA: PNP_DETECTED_FATAL_ERROR.) The PnP manager
	creates the devnode in response to the
	IRP_MN_QUERY_DEVICE_RELATIONS request. The driver can safely
	assume that the PDO's devnode has been created when it receives
	an IRP_MN_QUERY_RESOURCE_REQUIREMENTS request.

	Update: It seems we don't need all of this. Showing the
	drive in Explorer is now implemented in drbd-utils (user
	space only).

	Update: Now it notifies applications / explorer of new drive
	via user space on becoming primary and removal of drive
	when becoming secondary.

Done: clean up left over PNP code.

Rejected: Auto-promote seems not to work as expected.

	dir h: should make device primary if possible and then
	not fail.

	Strange, but neither with read/write nor with read only we get
	a create request on the windrbd device. (tested with windrbd-test)

	Update: It seems to me that when we open \\.\K: the file system
	device object (not the storage device object, that is, we) get
	the open request. File system keeps references to the block device,
	so it doesn't reopen it. We plan to release 1.0 without Auto-promote.
	(also because we should not have a windrbd device when the
	resource is secondary, because of the caching).

	Update: We are delivering windrbd without auto-promote, for
	various reasons (don't have device object when secondary,
	for example).

Rejected: Port agruen's test suite to cygwin.
	exxe is running. Ask phil about how to install it.
	Depends on chmod working (else cannot install
	opensshd).

	Update: chmod works now.

	Update: We probably don't do this, according to phil,
	it takes at least one month to complete.

Rejected: Do not have a root device.
	It is useless.

	Update: Windows requires it. We can use it (later) for
	debugfs or for the netlink ioctl.

Done: Understand what windows means by mounting / dismounting.

	Much like linux with udev always automounting everything. Also
	ofter refers to assigning a drive letter to a volume, but also
	the process of detecting a file system and initializing it is
	part of the mount process. Mounting and unmounting (dismounting)
	now works as expected.

Done: check out drbd-utils from github and see if that works.
	(once it is pushed)

	Yes it works (windrbd branch)

Done: How is sync done? 
	Data appears delayed on backing device (about 10 - 20 
	seconds later).

	This is not part of DRBD (also not on Linux) it is the
	responsibility of the application to send sync requests.
	If it doesn't there is nothing DRBD (and hence also windrbd)
	can do.

	What it does, however is to cleanly dismount (unmount) the
	volume on becoming secondary now.

Duplicate: test if loading drbd driver later (not at boot) works.

Done: read error: Volume dismounted
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 DrbdIoCompletion <4>[0xFFFFFA800131B040] DrbdIoCompletion: I/O failed with error c000026e
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 drbd_report_io_error <4>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x208): local READ IO error sector 0+1 on

	Does this still happen? If yes then please reopen, a lot has
	changed meanwhile.

Done: Redo installation of sshd on Windows VM

Done: remove more dead code.

	This is always fun.
	Saved about 1600 lines.

Done: kzalloc should call kmalloc not the other way around.

Done: Review patches if they are still needed.
	Especially kmalloc(,, Tag) which is not neccessary.

	Update: The Tag thing is a perl script which actually
	works quite well (unusual for a perl script ...), leave
	it in, maybe someday one wants to use windows debugger.

	Some features are hard-patched out (discard, biosets, debugfs,
	online verify (!), RB_CONGESTED_REMOTE, write same, disk stats)
	maybe we want to implement them one day.

Done: patches for lars (kref debug in failure path)

Done: More clean up in drbd_create_device (init_submitter)

Done: check if windows device is accessed when it shouldn't

	(grep syslog)

	Right now, this didn't happen.

Done: Error reporting of SendPage()
	Don't know how to do this .. DRBD seems to implement a mechanism
	that works without having sendpage reporting errors, since Linux
	also doesn't report errors on sendpage. Ask Lars.

	Update: SendPage should return error if there is an error
	in Completion function (of an earlier SendPage()), else success. 
	According to Lars, SendPage() (and also Send()) in Linux
	just queues the buffer, however it seems to report errors
	if the socket is in an error state (else that wouldn't make
	sense, at least not to me).

	Update: Now detects connection close of the peer correctly.
	Update: After a fixing a silly bug this works now. 

	Check if timeout works (separate TODO)

Done: other BSOD from Devin: Handle Send errors correctly.

	2018-05-17T13:37:08.904002-07:00 legolas.us.linbit  U20:37:08.888|8e3a8040(sender) SendPageCompletionRoutine <3>SendPage completed with status c000020d

	But not reported to DRBD.

	Update: now reporting errors on send.

Duplicate: On network failure (unplug cable) stays in NetworkFailure state.

Done: Test network timeout on syncing.

	Test timeout with iptables on linux side (must DROP the TCP/IP
	packets from Windows, else there is some other error).

	Update: "New" API correctly detects timeout by giving
	a STATUS_IO_TIMEOUT in the completion (after approx. 22
	seconds). ("Old" API was patched to have infinite timeout)

	Make WinSocket timeout configurable in WinSocket layer
	(SO_SNDTIMEO, SO_RCVTIMEO): Update: not possible, see below.

	Port Send (and also receive?) to new API. Update: receive
	no, here we need the timeout set by tr_ops->set_rcvtimeo()

	Update: What happens to send buffers? Same as with Pages?

	Update: also don't port Send() to non-blocking, it is only
	used to send the first packet during DRBD handshake (there
	the buffer is on the stack so we have to wait for completion).

	Receive with MSG_PEEK used somewhere in DRBD?
	Update: MSG_PEEK no but MSG_DONTWAIT is used. Need to implement
	this.

	What about CALLER_BUFFER, GROW_BUFFER support in recv()?
	Update: Those are DRBD specific and implemented already.

	WinSocket kernel API does not support setting SO_SNDTIMEO
	and SO_RCVTIMEO, since the API functions are always non-blocking.
	There is a system defined send timeout after which WinSocket
	kernel API reports an STATUS_IO_TIMEOUT and completes the IRP
	(without having it sent), which cannot be set programmatically
	(at least not over WskControlSocket which roughly matches
	setsockopt()). The value for Windows 7 is 22 seconds (measured)
	which seems reasonable.

	For now, we now do not support setting send timeout via config,
	if we did we would need to use (Linux) timers to cancel the
	IRP before it completes and set an error state. Doable but
	not now.

	Update: Behaves good if there is traffic (such as a sync), now
	test with timeouts set and no traffic.

Rejected: report socket error state also in Send() and Receive()

	Not now. The Windows socket functions will report the error
	as soon as it happens (such as STATUS_IO_TIMEOUT), thereby
	also interrupting ongoing receives.

Rejected: receive should also fail if error_status is set.

	See other rejected TODO

Done: activate Ctrl-Alt-Del on Windows Server 2016 VM for VNCViewer

	See https://community.spiceworks.com/how_to/19223-how-to-enable-the-software-secure-attention-sequence-policy-workgroup-procedure

Done: /cygdrive/c/windrbd/var/lib/drbd should exist.

Done: renew the sysroot.zip

Done: New BSOD under Windows 10

	drbdadm up w0
	Invalid configuration request
	drbdadm down w0
	BSOD

	Update: this is a bug in beta-3 and fixed meanwhile.

	Obviously I've installed WinDRBD beta-3 (which is signed)
	and cannot install an unsigned windrbd (test) version over
	it. See TODO about when installing a signed DRBD driver,
	installing an unsigned DRBD driver fails silently.

	Always create snapshots (either VM or clonezilla) before
	installing signed drivers on test machines.

	For now, sign the driver and install it on Windows 10
	machine and repeat test.

Done: review code for kmalloc()

	Replaced by kzalloc where needed.

Done: On ping timeout reached, goes and stays in NetworkFailure.

	Tested with iptables-drop.sh on Linux side while connected
	(not syncing)

	Problem was MSG_DONTWAIT blocking. Fixed now.

Done: Implement MSG_DONTWAIT for recv().

	Later.

	Update: now implemented fixed NetworkFailure stuckness on
	connection loss while idle.

Done: clean up SIGCHLD, printk's

Done: Clean up wsk2.c
	Remove unneccessary code.

Done: logging: printk's without terminating \n not displayed.

	Also: if there are some special characters (\0?) the
	line is not displayed.

	Update: Please fix this, it is annoying, I just ran into
	it.

	Update: again.

Rejected: remove all tags from alloc() routines
	and revert patches.

	Update: there's a perl script that does it for us .. leave
	it in, maybe someone will need this one day.

Done: Have a function that initialized all (global) spinlocks
	and replace the racy solution (with an flag indicating
	wheter it is initialized) we have now.

Rejected: (maybe) support setting send timeout.

	This works differently in Windows socket implementation,
	since the send function is asynchronous. There is a
	(fixed) timeout after which we get an error.

Done: make clean target under Windows should do what one would expect.
	also remove *.pdb and *.ilk files in addition to *.obj

Done: blue screen when backing device fails.

	Not observed lately.

Done: I/O error reading past the device.
	Which is correct, however there is a disconnect. And the
	disk should not fail.

	Reading past the device can be used for I/O error handling
	testing.

	Update: works only if there is no file system on the device,
	else upper layers will filter the I/O requests (windrbd does
	not get an I/O request).

	Update: Disconnect is because of protocol error (sector
	out of range), this is probably intentional (remote goes
	into ProtocolError state and disconnects). Can recover
	by connecting again.

	I/O error handling seems to work as expected. Maybe also
	test this with an USB stick.

Done: Fault injection on backing device.

	If we were saints we also would test with split I/O requests.

Rejected: From Devin: make winsat run.

	It uses undocumented APIs (ioctl 0x2d5190). There are lots
	of other tools, for example CrystalDiskMark.

Done: random read/writes (reported by CrystalDiskMark) are very slow

	Device is unconnected.
	Update: also slow when writing directly to backing device.
	Probably a VirtualBox issue.

Done: Test with fault injection and split I/O requests

	With writing 1meg requests.

Done: Protect against sector out of range by checking in windrbd device entry.

Done: Fix error codes returned by irp_to_bio

Rejected: support I/O vectors in windrbd device (irp_to_bio)
	and clean up code (see TODOs in source code)

	Also have a test that does WriteFileGather and ReadFileScatter.

	Update: Have test, but windows copies the data to have it
	linear in memory (getting one MDL element describing a
	linar buffer for all the vector elements).

	For now, leave that alone, it seems not be used by applications.

Done: test no I/O when disk is failed.

	We now allow I/O since DRBD will serve I/O requests from
	a Primary peer of the local disk fails. This works well.

Done: review README.md: some info is outdated.

Done: Blue screen: Windows 2016 server: cannot format volume

	Strange behaviour. Blue screen on format f: (windrbd device)

	Fix networking first (we cannot reach Linux machine from
	Windows 2016 server at the moment)

	Update: fixed, can now test quite good on much vm's.

	Problem was that MAX_MDL_ELEMENTS is just a guess of what
	a Windows block driver can handle. It is 32 for Windows 7
	(found by trial and error), however Windows 2016 Server
	(and as I suppose also Windows 10) have problems with that
	setting. When setting it to 1, no blue screen so far, however
	it is just too slow. Update: it is slow but not so slow
	(had lots of printk's in the I/O path).

	Maybe we can patch DRBD so it can handle biovec elements
	greater than 4K in size (seperate TODO).

	Blue screen fixed by setting MAX_MDL_ELEMENTS to 1.

Done: Code quality: io_status should not be in struct bio, see comments in
	drbd_windows.h

	Seems to work. Maybe do some more tests (see TODO's in source).

Done: Infrastructure: Get Windows 10 drbd installation working again.

	There's a signed driver installed cannot install
	unsigned drivers over it.

	Update: use rundll32 setupapi ... from uninstall todo
	that should do the trick.

	Update: yes it did. Newer windrbd kernel already installed.

Rejected: when installing a signed DRBD driver, installing an unsigned
	DRBD driver fails silently.

	It is unclear how this really works. When installing a
	signed driver it seems to be not possible any more to
	install an unsigned driver over it. Test signed drivers
	is separate virtual machines.

	Update: we now can uninstall DRBD (currently with a
	command line command, see TODO about uninstall). We
	won't research this in more detail.

Duplicate: One day we want to not blue screen when backing device contains a file system.

Done: lots of more tests (corner cases like reading near the
	end of the device)

Rejected: have windrbd-test execute drbdadm as needed.
	This is a nice to have.

Duplicate: We should really lock the backing devices using NT kernel
	mechanisms.

	Maybe use the mechanically locked IOCTL? Then one would
	have to drbdadm down <res> --force

Done: windrbd hide-filesystem does not work on a DRBD device.

	For now use windrbd-test with do_read_write test.

	If we think a little then we find that this is as it
	should be: hide-filesystem writes DRBD into the boot
	sector. This gets written on the backing device. However
	when reading the backing device, the windrbd driver
	converts the DRBD signature to NTFS, so it looks as
	DRBD never got written. There is no way how we can
	distinguish a (possibly intentional) DRBD signature
	from a NTFS signature on the windrbd device.

Rejected: remove drive letter from volume on attach.
	And not reassign it on detach: Users shouldn't modify
	data on a backing device even when the device is down,
	unless they really want it.

	Print a howto showing:
		how to change from drive letter to GUID in drbd.conf
		how to recover the drive letter later (in case
			DRBD is never needed again, or if it was
			the wrong drive letter).

	Update: are we doing this?

	Update: currently it works quite well .. we recommend
	users to use GUIDs and not assign drive letters. If
	we remove drive letters from backing devices, users
	might get confused (plus there might be a lot of
	race conditions).

Done: Test: test network failure with real network cable.

Done: Test: drbdadm status fails after unplug cable when syncing.

	Still there? I suppose no but test it on physical Windows 10
	machine.

	Update: yes it is. No bluescreen however so far.

	Update: Reason was logging. Windows seems to stall drivers
	that send UDP packets. (maybe this is also connected to the
	problem of having interface address instead of loopback as
	syslog_ip).

	Works now, however after plugging network cable again, no
	connection can be established (with errors like sock_recvmsg
	returned -11, Timeout waiting for feature packet).

	Update: I accidentially re-enabled Windows firewall, deactivating
	it solved the problem.

	On no I/O everything works fine.
	On I/O we stall in sync at 99.85 percent after reconnect.

	After a while that goes to 100 percent.

Done: Test: BSOD on network failure
	Check if still there.

	Update: as far as I can tell, no.

Done: Test: Test lower case drive letters for windrbd device.

	Works.

Done: Test: New blue screen on connecting Windows 10 to buildhost Windows 7
	(I think it was D1).

	This might be because of wrong rcu handling (must sleep
	before cleaning up)

	Update: still there?

	Update: Not observed recently, closing this for now.

Rejected: msi installer instead of self extracting exe.

	Not clear yet .. imdisk for example comes also with a
	homegrown install script.

	Please reopen upon customer request.

Done: Test: test I/O error with USB stick.

	Simple test succeeded (no I/O during unplugging).
	When unplugging while I/O is running (over NTFS),
	BSOD.

	Done, and some things fixed.

Done: Bug: on passive side, on BSOD stays in NetworkFailure

	Also on Diskless Primary (peer) and unplugging cable (without
	BSOD)

	After Down/Up when Sync starts (must attach disk on peer)
	BSOD (see separate TODO).

	Update: Found it:

	Problem was that recv_pages didn't return -EINTR when a
	signal was delivered and data was there (which is probably
	right according to recv manpage, even when MSG_WAITALL is
	given). Right now we have a followup BSOD, probably in
	DRBD, because this apparently never worked.

	Update: Linux hasn't got this problem (it seems that -EINTR
	is returned even if there is data).

Done: Bug: From Devin: Registering mount point failed status = c0000035
	This seems to be something that only happens on Windows Server 2016.
	The mount_point buffer is NULL at end of the windrbd_mount
	function:

	2018-05-17T13:47:08.666486-07:00 legolas.us.linbit  U20:47:08.638|da4db040(drbdcmd) windrbd_mount <6>Assigned device \Device\Drbd0 the mount point (null)
	However, all checks before that succeed.

	Get a Windows 2016 Server and test on it.

	Update: Also happens on Windows 10 with beta 3

	Update: Tested with Windows 2016 server, didn't happen so
	far.

	Update: This happens when drive letter is in use. Report error
	to userspace.

	In case we cannot mount on becoming primary, we do not fail with
	an error (since it is not DRBD's fault), but rather print a
	warning. In most cases users want to review their config,
	then. Fixed (to be fixed by user).

Done: Bug: If windrbd drive letter is used as real drive letter, windows
	accesses the real drive silently.

	Update: in that case, mounting fails with c0000035, this should
	be reported to user space as an error.

	Update: We do not fail (would have to revert becoming primary,
	but print a warning:

	In case we cannot mount on becoming primary, we do not fail with
	an error (since it is not DRBD's fault), but rather print a
	warning. In most cases users want to review their config,
	then.

Done: code quality: experiment with MAX_MDL_ELEMENTS

	Make it a variable, increase and wait for blue screen.

	Update: Done, Here's the results:

	Windows 10 and Windows 2016: maximal 16 MDL elements.
	Windows 7: maximal 32 MDL elements.

	Test was on a (virtual) SCSI disk, other device classes
	(USB stick) may have lower limits.

Done: Infrastructure: Windows 2016 powers off on (some) blue screens.

	Simon will write a script that restarts it over libvirt.

Done: Test: Test protocol B, C

	B seems to work .. if one has A and the other node B then
	B wins (also in upstream).
	C also seems to work.

Done: Test: More tests with Windows 2016

Done: Documentation: Describe BSODs in release description

Done: Documentation: Describe restrictions in release description

Done: Installation: Include inf file in package.

	And document how to uninstall on command line.

Done: test backing device failure with small I/O sizes

	Done, if there is not much I/O no BSOD.

Done: Physical USB stick BSOD on becoming Primary.

	Most likely because of MAX_MDL_ELEMENTS being 16.
	Update: Yes it is. MAX_MDL_ELEMENTS must be 1 for usb stick
	to work. We might leave it that way and fix the way DRBD
	handles temp buffers instead (see performance TODO).

	Update: Set MAX_MDL_ELEMENTS to 1 now and leave it as
	it is.

Done: test I/O with requests > 1 Megabyte

	Done, as expected ASSERTION FAILED on connected peer.
	Must implement splitting Irp into several bio's (and
	call drbd_make_request for each of them).

Done: Test: Fault injection: Keep faults.

	Showing an BSOD on device failure on completion.

Done: Bug: BSOD on backing device failure while I/O is running

	This was tested by unplugging a USB stick (contained the
	backing device) while copiing a large file to windrbd
	device. OS was Windows 10 (physical machine).

	Update: We cannot call the backing device driver again
	if the device already failed (else BSOD). Immeadietly
	before calling it check if it has failed and cancel
	IRP without calling the driver if yes.

	Update: When logging is not on, there's still a BSOD,
	(windrbd log-server not running), reopened. Maybe fix
	the logging first (wait for UDP packet to arrive).

	Update: When there is a lot of I/O going on chances for
	a BSOD increase .. maybe some race condition? Also
	last line is:

Jul  6 18:22:02 10.43.8.215  U16:22:01.009|f8ac2e70(not_drbd_thread) drbd_md_sync_page_io <7>drbd usb-stick/1 minor 3, ds(UpToDate), dvflag(0x2): meta_data io: not_drbd_thread [0]:drbd_md_sync_page_io(,15728568s,WRITE) FFFFF809F892794FS

	Update: Can be simulated by failing (and keep on failing)
	in completion (not on request) when meta data is written
	or when syncing. BSOD does not happen when data is written
	by userspace requests.

	Update: We fixed a double free in the I/O completion routine,
	which most likely was the root cause of this BSOD. It now
	works with physically unplugging the USB stick containing the
	backing device (no BSOD, I/O continues if connected, I/O
	error reported to application if not connected)

Done: Implement: Split requests > 1 Meg into seperate bio's.

	DRBD cannot handle bio's larger than 1 Meg in total
	(which is a sort-of hard limit in current Linux kernels).

	Update: Implemented, first tests (after fixed a nasty
	race condition in completion of upper level IRPs) show
	that it works quite fine. Now also test with fault
	injection on the lower level I/O.

Done: Bug: From Devin: d->bi_size (from peer request) too big:

	2018-05-17T13:37:08.765112-07:00 aragorn.us.linbit  U20:37:08.743|d6f31040(receiver) static_inline_expect_fn_peer_device <3>drbd w0/0 minor 0 pnode-id:1, pdsk(UpToDate), prpl(Established), pdvflag(0x600): ASSERTION d->bi_size <= DRBD_MAX_BIO_SIZE FAILED in read_in_block

	Test with large block device sizes.

	Update: did, but didn't yet happen (sync would take 3 hours)

	Update: happened on syncing between Windows Server 2016 and
	Linux: two more assertions failed:

Jun 27 15:37:45 wintestubuntu kernel: [85326.250911] drbd w0/1 drbd1 WIN-F11R93CP9KI: ASSERTION (n_oos - peer_device->rs_failed) == 0 FAILED in drbd_resync_finished
Jun 27 17:02:04 wintestubuntu kernel: [90385.215243] drbd w0/1 drbd1 WIN-F11R93CP9KI: ASSERTION node_mask == 0 FAILED in _drbd_send_uuids110
Jun 27 17:03:02 wintestubuntu kernel: [90443.041728] drbd w0/1 drbd1 WIN-F11R93CP9KI: ASSERTION d->bi_size <= DRBD_MAX_BIO_SIZE FAILED in read_in_block

	Update: Need to split into seperate bio's for requests larger
	than 1MB. Test later if all assertions are gone, then.

	Update: With implementing bio split into 1Meg pieces this is
	gone now.

Done: Test: New windrbd layer with fault injection on lower device.

	Found a BSOD on failure when request is larger than 1M.
	When request is 1M or smaller, no BSOD.

	Update: IRP was accessed (in loop) after IoComplete() was
	called (which invalidates the IRP), now we call IoComplete
	only after all bio's are finished (and do not access the
	IRP in the bio loop). Need to cleanup code.

	Also free the read buffers in all cases.

	Update: all done.

Done: Implement: patch DRBD to handle biovec elements larger than 4K.

	There might be other limits .. 1 Meg is the maximum size
	of a data request packet, so we still need the splitting
	in windrbd.

	Update: Done and tested with protocol A, B and C (plus
	verifying content. Much faster (for large requests) now.

Done: Bug: logging to localhost (windows) seems to cause boot problems (?)
	When using 192.168.56.101 instead of 127.0.0.1

	Fixed by making SendTo asynchronous.

Done: Implement: WinDRBD unresponsive when syslog host can't be reached.

	This is most likely because we wait for completion. Not
	sure yet if we want to fix this, because that probably
	would cause last messages before BSOD getting lost.

	Update: Implemented this and did a test (log, then crash),
	over a VirtualBox network, the last logging line gets delivered.

	On the other hand this probably can also fix the
	does not boot when local interface IP is configured bug
	(which is severe).

	Update: Yes it does.

	It also might allow us to send while IRP level is raised.

	Update: No it does not. According to MS documentation packet
	will be sent before WskSendTo returns .. so it is unclear if
	we needed the patch at all. However, it works and fixes
	(at least) the Local Network address not boot error (and
	most likely also the network address not reachable, this
	requires more testing).

Done: Rebase windrbd branch of drbd-utils to its master
	Also for drbd-headers. Then, also use the drbd-headers in
	drbd (and remove drbd-headers patches)

	Done, seems to work. Now make the windrbd branch usable under
	Linux

Done: Code quality: #ifdef the Windows netlink code in drbd-utils

	windrbd branch should compile and be usable under Linux
	as well.

	Update: compiles under Linux (when checking out master
	on drbd-headers, see seperate TODO)

	Also need to remove .*.d files seperately (this should
	be fixed upstream).

Done: Code quality: fix drbd-headers patches.

	drbd-headers windrbd branch should be as close as possible
	to Linux DRBD version.

	Done, there are some ugly ifdef WINDRBD's as well as a separate
	windrbd directory for essential headers (netlink, types, ...)

Done: Code quality: duplicate is_guid() function.

Done: Usability: disallow windrbd hide-filesystem on a DRBD device.

	Since we are patching back and forth, show-filesystem won't
	work later. Plus cannot mount those resources on Linux.
	hide-filesystem on a DRBD device is in all cases a user
	error (except stacking which is deprecated).

Done: Implement: Check if patches still apply with newest drbd-headers

	We've touched some of the windrbd specific code.

Rejected: Infrastructure: install kernel manpages

	Must install from kernel source using
	make mandocs ; sudo make installmandocs

	Somehow this does not work..google is your friend.

Done: Code quality: Should report I/O error instead of Permission denied on disk failure

	We now return STATUS_DEVICE_DOES_NOT_EXIST which translates to
	a sane windows error code (also under Windows 10?).

Done: Feature: One day we want to have a more specific error message
	than Device does not have a disk config if the device or
	the drive letter already exists.

	Now, printing warning generated by kernel.

Done: Implement: Allow for enabling fault injection via ioctl (windrbd.exe)

	Implemented on a per device basis.

	Works once we become primary. What is missing is fault
	injection via root device (on all devices), so we can
	test everything before becoming primary.

	Update: Now reworked interface, also possible to inject
	faults before anything else (drbdadm primary, drbdadm up)
	happens.

Duplicate: Feature: on windrbd show/hide filesystem check if attached.

	And refuse to touch it if yes.

Done: Implement: netlink transport over ioctl

	(something that can verify permissions of caller)

	Update: Implemented. Restriction is that event for drbdsetup status
	one needs Administrator priviledges.

	Also does a busy poll for netlink messages in order to
	make interrupting with Ctrl-C work (CygWin implements signals
	in user space, if we wait in kernel space signals never get
	delivered).

Done: Implement: drbdsetup events2 does not work

	Implemented (multicast group events sent to all drbdsetup events2
	processes).

Done: Remove registry entries for TCP/IP based netlink

	Maybe someday also remove the syslog_ip registry key. There is
	a buffer overflow in the InitRegistry function, plus we cannot
	change the syslog_ip during runtime.

Done: Implement: check if windrbd can be loaded not at boot time but later.

	Working on it .. test with demand load on a fresh installed
	windows (it blue screens on boot if there was a windrbd before
	installed).

	Update: imdisk can do it.

	Update: we got it working .. trick was not to register drbd
	as upperfilterdriver in the registry (else windows fails on
	boot when drbd.sys is not loaded). And set StartType to 3
	(imdisk has 2 but accoring to doc this shouldn't be used
	for WDM (which we are) and PnP drivers (which we are not).

	Side-effect is also that AddDevice (see disp.c) isn't needed
	any more.

Done: Implement: user mode helpers

	switch to ioctl() interface first.

	Update: switched to ioctl, now implementing user mode helpers.

	Update: User mode helpers should work now as expected, require
	probably some more testing (and fixing of some TODO's in 
	user space utility).

Done: Ask phil about timeout for user mode helpers.

	DRBD does not enforce any timeouts. We leave them at 10
	seconds for now.

Done: Feature: 'modprobe' (sc start windrbd) for drbdadm

Rejected: Feature: windrbd show-filesystem should check if device is used as
	a backing device.

	Right now, it behaves more or less sane: if one does a show
	filesystem on backing device while the device is up, accesses
	fail as long the device is used as backing device. As soon
	as one does a drbdadm down on that resource the backing
	device can be accessed again (which is what we wanted). I guess
	we leave it that way until someone complains.

Done: Use Linux API for creating DRBD threads.

	Without the weird event logic. Done while attempting to make
	driver removable from the kernel.

Rejected: Also use windrbd_thread helpers for netlink helper thread.

	Would be more code.

Done: User mode helpers: have sane defaults if daemon is not running.

	Stays in SyncSource when invalidating peer sometimes.

	Update: changed to 1 second, resync with out daemon running
	works now.

Done: Build system: Compile with optimizations on.

	Little patch (un-inlined a function, functions never were
	inlined before) to make linker happy. Observe if something
	is faster now.

Done: Bug: loading driver on boot BSOD's now on boot.

	We changed some things in the DriverEntry routine, maybe
	there's a regression. Be sure to create snapshots (set
	driver start registry entry to 0 to make driver start on
	boot).

	Update: We must not printk right after SocketsInit() (in
	the wsk init thread), else BSOD (printk will create a socket
	for sending logs and bind it). Drawback is that we currently
	don't see log messages on sc start windrbd (when loading the
	driver manually) but this is usually done from drbdadm in
	which case we see the logs.

	Note also that driver loaded on boot can be unloaded
	later (unless there is a memory leak).

Done: Feature: flush printk buffer as soon as network is working.

	Don't. Windows will BSOD on boot.

	Update: Fixed something inside creation of UDP socket,
	doing a SendTo probe now and reopen socket later if
	SendTo fails. Basic problem is that error state in
	socket is not cleared (see separate TODO) and SendTo
	always fails (even if it would be possible).

Done: Implement: Rework mount code.

	Should be an ioctl called via windrbd on primary/secondary
	(where add-drive-in-explorer is). Then we do not have to
	change the netlink protocol attributes (and also save patches
	to DRBD).

	Update: Done, works.

Done: Upstream: Linux drbd-utils should not complain about WinDRBD device

	On peers. Do that before merging windrbd into master.

	Accept any string (including empty string)

	Update: Not checking for devices when local host is in
	hosts lists (but checking if hosts list is NULL)

Done: Code quality: fix remaining warnings when compiling drbd-utils with-windrbd

	There is also a warning when compiling with Linux.

	Done, but re-check when done with de-ifdefing code.

Done: Code quality: merge drbd-headers/windrbd branch onto Linux version

	Avoid #ifdefs whereever possible:

	Have windrbd-compat subdir with empty headers to avoid ifdef
	on includes (windrbd-compat/linux, windrbd-compat/sys) add
	-I windrbd-compat to Makefile.

	Mountpoint field: leave it in, phil will patch it out for
	his upstream (Linux mainline)

	Others: Find another way to do it (undef NO_ERROR, ...)

	Update: I think we can do this without any ifdefs in the C
	code (only in Makefiles).

	Update: Yes we did. Only diff is the NO_ERROR thing (which
	we someday will replace by DRBD_NO_ERROR, send a patch
	to Upstream) and the windrbd_ioctl.h (which is ok for
	Phil).

	Submit together with drbd-utils.

Rejected: Upstream: drbd-utils make clean should also remove dependencies.

	One should use make distclean

Done: Code quality: merge drbd-utils/windrbd branch onto Linux version

	Avoid #ifdefs whereever possible: for includes see drbd-headers
	TODO.

	For functions, have a drbdmeta-linux.c and a drbdmeta-windrbd.c
	and link with the right version.

	Update: I think we can do this without any ifdefs in the C
	code (only in Makefiles).

	Update: Working on headers .. we now only have ifdefs for
	including headers that actually do something:

	linux/netlink.h -> windrbd/netlink.h
	linux/genetlink.h -> nothing
	linux/types.h -> windrbd/types.h
	linux/drbd_config.h -> windrbd/drbd_config.h
	Update: Done those above.

	linux/fs.h -> cygwin/fs.h
	(in shared_tool, but this ioctl won't work on Windows).

	Update: split drbdmeta into I/O functions
	(in drbdmeta_{linux,windrbd}.c). No ifdefs in C files, however
	there are some (2) in header and in Makefile (where is doesn't
	hurt). TODO: test it for DRBD < 9 it seems that drbdmeta isn't
	built for that versions (for Linux).

	Update: drbdadm and shared ifdef-free (except for HANDLE's
	in two header files, ask Phil about that). Only drbdsetup
	left to do.

	Update: drbdsetup done, ready for submit.

Done: Code quality: git diff master and undo unneccessary changes

	.gitignore: add Linux binaries again.
	install /var/lib/run: we need it but seperate patch

Done: Implement: Make DRBD driver removable.

	From imdisk:

	start "" "%SystemRoot%\system32\rundll32.exe" setupapi.dll,InstallHinfSection DefaultUninstall 132 %SystemRoot%\inf\imdisk.inf

	In practice a

	rundll32.exe setupapi.dll,InstallHinfSection DefaultUninstall 132 Y:\windrbd\converted-sources\drbd\drbd.inf

	did the trick. DRBD is not stopped, but this uninstalls DRBD
	driver (after reboot drbdadm status fails because DRBD kernel
	module is not running).

	What is missing: write a cmd script that down all DRBD
	resources, stops the driver itself (how? see sepearate todo)
	and executes the setupapi thing above.

	Also create registry keys for Linbit / DRBD in
	HKLM/Software/Microsoft/Windows/Uninstall/DRBD so one can
	use control panel / uninstall software to uninstall DRBD.

	Update: Switched to inno-setup (see http://www.jrsoftware.org)
	Uninstall works for the driver if it is not running.

	Userland binaries should reside in the /Program Files/WinDRBD
	directory (add a PATH to it) same for the cygwin DLLs.

	Uninstall cmd script should also (try to) drbdadm down all
	and sc stop windrbd (maybe ask first?, or call that later)
	(Update: it seems that DefaultUninstall tries to stop the driver)

	Update: Yes it does. We currently BSOD on uninstall (removing
	the driver), (at least) free_mdls_and_irp() never gets called
	bug has to be fixed.

	Update: PATH thing done. Maybe register the cygwin-1.dll as
	shared file? Test cygwin installation after WinDRBD installation
	and decide then.

	unzip'ing sysroot also works, we have now all 'old' features
	implemented.

	Done: When finished, remove the pause from the cmd scripts and
	hide the cmd window.

	Also Done: do not ask user about environment. Update: done

	Done: Integrate into make build system (with iscc) Update: done

Done: Bug: 'modprobe' does not work when invoked via cmd.

	Because it starts a shell. Use WIN32 API instead.
	Using execvp() now.

Done: Bug: Two issues with cygwin1.dll

	Old cygwins (2016) do not understand whitespace in
	path names of programs (at least when the program is
	found via path). Solution is probably to document
	that and tell user to upgrade cygwin (when running
	drbdadm from a cmd shell everything works, so it
	is probably the exec() call).

	cygwin1.dll shipped with WinDRBD is incompatible with
	newer cygwins, removing dll from program directory
	(or renaming it) solves the problem. Probably always
	shipping with the newest cygwin1.dll solves the problem.

	Update: Yes it does. Document the old cygwin thing
	and close this.

Done: Build system: install build utils on Windows 10 box and create signed packages there.

	So we never need the copy-to-another-machine step in building
	signed packages.

	Making progress (installed ewdk, installed visual studio
	(but probably not needed) installed inno-setup and built
	with make package R=1. However, needed to patch Makefile.win
	and ms-cl.cmd (does not compile with Windows 7 VM now).

	Left TODO: document the new process, find a solution to the
	Ewdk makefile hell and update inno-script (would be nice
	to change the version to windrbd-signed or so ...)

Done: Infrastructure: Linux box sometimes loses IP address.

	Was maybe because of updates being installed in the background,
	disabled now, observe if it happens again.

Done: Implement: Detect earlier versions of WinDRBD and offer upgrade.

	(from Devin)

	Done for beta4. We should prepare beta5 for being detected by
	later releases.

	Update: look at
	HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\{{AppId}}\\DisplayVersion
	it will contain {MyAppVersion} of the installation.

Done: Code quality: clean up drbd.inf (again)

	Done. Except for syslog registry entry, which will go
	away soon.

Done: is the .cat file needed?

	No.

Done: Code quality: Update README-windrbd.txt (in sysroot.zip)

Done: Installation: add start menu entry to C:\windrbd\etc

	Was very easy (English only, tough)

Rejected: Infrastructure: Why doesn't it work on Phil's machine?

	Maybe test it with new installer one day.

	Phil doesn't seem to be interested .. I perfectly understand.
	Just now, MS app store has stopped working on my Windows 10
	box and I have no idea why .. I guess I just reinstall it.

Done: Installation: Autostart user mode helper daemon and log server

	Someday ...
	Update: we should do that in modprobe. WinDRBD isn't really
	working smoothly without them.

	Need to define this as Windows service (in inf file) with
	type 16 (daemon).

	As a Windows service? Can it be made dependent of the kernel
	driver?

	Update: Yes we do it as a Windows service (see windrbdsvc.c
	in drbd-utils/user/windrbd). Current issues are:

	When running as a service /sbin/drbdadm symlink is (obviously)
	not found.

	Installer inf file currently uses C:\Program Files (x86) as
	value for the path (because it is a 32-bit app when running
	make install, it works). Update: now putting it in
	C:\Windows\System32 somehow this does not work (cygwin
	DLL not found?).

	log files: we currently don't see output of windrbd processes
	(windrbd user-mode-helper and windrbd log-server). Something
	with the dup code does not work correctly. Update: no it
	was the open(2) flags (O_RDWR was missing), works in
	console mode.

	Also define somehow where the log files should be located
	(C:\windrbd\var\log would be the most sane directory)

	Update: better not. Windows admins don't look there.
	Place it in C:\windrbd

	Installer should include service EXE (this should be easy).
	Update: should be done, test it.

	Update: We now place all binaries in /cygdrive/c/windrbd/usr/sbin
	so a make install does the right thing. Also hardcoded this
	path in drbd_main.c now, so user mode helper finds the helper
	(currently no way to change that via ioctl). TODO: update
	installer script.

	Update: Works now, however drbdadm requires /bin/sh (which
	in turn requires several DLLs we don't want to ship). The
	basic problem seems to be that when running as a service,
	/ does not exists (and so don't /tmp , /bin and all the others)
	However /cygdrive exists. Waiting for stackoverflow answer.

	Proably best for now to have users start user mode helper
	daemon manually in a cygwin terminal, they are not strictly
	needed.

	Right now, we do not see the output of the user mode helper
	daemon (however we see the output of the helper scripts).
	Update: was printf() being fully buffered, fixed.

	Update: now using cygrunsrv (also to install and remove
	services) and it seems to work. User must have cygwin
	installed for using user mode helpers. Later we may support
	PowerShell.

	Update: when packaging cygrunsrv it fails to find the
	cygwin installation (cannot exec /bin/sh). We now switched
	to PowerShell (which has a well known path), this is
	anyway more likely what the users want (no need to
	install cygwin at all).

	Left TODO:

	Do not fail if /bin/sh is not found (for now).
		Is called only when there is a handler. Put a comment
		in windrbd sample res file that explains.

		Update: we now switch to PowerShell (which has a
		sort-of defined fixed path).

	Remove windrbdsrv.c
		Done

	Remove windrbdum service in inf file.
		Done

	Poll for root device on user mode helper startup.
		Done

	modprobe
		Done

	PowerShell patch: move args to platform specific
		C file.
		Done, test it.

	Change timeout for user mode helpers (again) because
	PowerShell is very slow.
		Done

	Also change drbdsetup timeout.
		modprobe may take a while.
		Observe. Right now it is ok.

	Make release (0.8.10)

Done: Bug: Connection fails sometimes with -EAGAIN

	Update: Probably fixed with 4ecababaa, observe
	Update: After some patches this is fixed now.

Done: Disable driver unload before release

	By setting AddDevice. It causes too many BSOD's.
	(maybe) Also disable kmalloc debugger.

Done: Implement: have an ioctl that returns WinDRBD versions string

	What /proc/drbd would contain.

	Update: now have 2 ioctls that just return the interesting
	parts. Works.

Done: Upgrade to latest DRBD (9.0.15) before testing next beta.

	Update: Wait for 9.0.16 (next week, by Oct 18).

	Update: There's (probably) a sync stall bug in 9.0.14,
	so upgrade now to 9.0.15 and see if it gone.

Done: Installation: Windows 2016: Installing a newer version fails when driver is running?

	Yes it does. Problem is a sharing violation of the driver
	file (cannot copy to sysnative directory). We now try to
	delete the file (which worked on the cygwin cmdline).

	Update: now running installer script in 64-bit mode (execing
	from C:\Windows\sysnative\cmd.exe), works now.

Done: Bug: patch_boot_sector: DRBD signature on peer.
	Should only be on backing device, never on the wire.

	Not when Syncing, only when formatting while connected?
	Yes. Make a temporary copy of the boot sector when writing
	in windrbd_generic_make_request(). Do not modify the bio's
	buffer directly, this might also be the Page Cache (or whatever
	this is called on Windows) of the file system which causes
	format to display the weird Boot sector invalid message.

	Update: implemented, weird behaviour when extra field is
	put after io_status (see separate TODO). It seems to work
	now (formatting while connected does not copy DRBD signature
	to peer).

	Update: Reopened: This happens now when invalidating (or otherwise
	syncing) from a windows peer.

	Fixed with 4c66b503af9: reason was check for bi_first_element
	was wrong (race with generic_make_request updating it).

Done: Installation: Update usually fails for *.exe files

	If they are running (need to stop userland services and
	drbdsetup events2).

	Possible solution: install them using inno-setup directly
	to C:\windrbd (however need to get around zip file extraction
	first)

	Update: Did that, it at least notifies the user about the
	error (user must stop services, put a note into README)

Rejected: Installation: Maybe revert drbd-utils in Program Files.

	inno-setup would check if programs (like drbdsetup events2)
	are currently running.

	Update: Tried, we will have to rewrite installer cmd script
	in PascalScript for that.

	We leave it now in C:\windrbd\usr\sbin. Advantage is that
	this is compatible with make install from drbd-utils. Also
	inno-setup now can check if the exe files are in use (user
	must stop services then).

Done: Documentation: define tests to be run before releases.

	And run them ;)

	Update: Now using TESTS file, this is kind-of what we want.

Done: Bug: BSOD on drbdadm up (Windows Server 2016)

	Fix it.

	When peer resource is down no BSOD, however BSOD when it
	comes up. Most likely this BSOD is when sync starts.

	Upgrade DRBD to 9.0.15 (on both sides) and see if the
	problem persists.

	Update: upgraded, so far no BSOD, but requires more testing.

	Update: BSOD also on disconnect connect loop (after 10-20
	iterations).

	Update: Fixed a race in windrbd_threads (windows_thread
	was sometimes invalid at start of a new thread, which
	caused ack_receiver sched_setscheduler() to BSOD), which
	hopefully fixes this (and others) BSOD.

Done: Bug: it seems that free_mdls_and_irp() never gets called.

	After 200 loops of invalidate-loop system runs out of memory.
	This should be fixed.

	Leak is about 1% of data written (12kb for 1Meg).

	Update: leak fixed (one bio_put in completion was missing).
	Tested with NTFS as backing device: replacing IoFreeIrp()
	by IoCompleteRequest() fixed the test for filesystem
	BSOD. Also now removed the might_access_filesystem checks
	(behaves as if it is always 1, MmBuildMdlForNonPagedPool never
	gets called). Also removed the extra copy in the upper
	device (for READ, we needed that because under Windows 10
	we could not read the device properly). TODO: test with
	Windows 10 and find another solution to the copy problem.

	Note that we really cannot do proper tests with NTFS
	backing devices: access fails (with 0xc0000022, access
	denied, also sometimes with 0xc0000054 STATUS_FILE_LOCK_CONFLICT).
	If we ignore them NTFS driver gets invalid data and
	loops.

	Also TODO: clean up code (printk's).

	Update: Tested with Windows 10 it seems to require some
	extra copy (reports 'strange' errors) or some flag to be
	set.

	TODO: clean up code and merge.

Rejected: Code quality: fix the case where backing device contains a file system.
	It should not blue screen.
	(maybe later, this seems to be rather complex)
	We are now avoiding the case when there is a filesystem
	on an attached backing device. This blue screen should
	be fixed but maybe in a later release.

	Update: We found on stackoverflow that one should use
	IoCompleteRequest() instead of IoFreeIrp(). Does that
	help?

	Update: Lots of progress, when there is a NTFS filesystem
	we still have the access denied thing going on but we
	(currently?) do not blue screen.

	Update: There appears to be some internal NTFS bug, which
	triggers when data is copied in the completion routine.
	Since we cannot fix that at the moment (it is not a
	range check error and also not an error in calling
	MmGetSystemAddressForMdlSafe(): I checked both).

	"In the wild" this bug doesn't trigger because we refuse
	to use a device containing NTFS as backing device.

Rejected: Skip the extra copy on read.

	We cannot have it (currently BSOD's). See if there is a
	device flag (something like BUFFERED or so) that does the
	trick (problem is that under Windows 10 a read from the
	upper device returns garbage).

	Rejected. Does not work with Windows 10.

Done: Bug: BSOD when running unattended

	Between Windows Server 2016 and Linux.

Oct  9 04:01:31 10.43.10.11  U02:01:31.841|c9bcfc80(drbd_a_w0) Receive Receiving canceled (errno is -11) but data available (16 bytes, will be discarded).
Oct  9 04:01:32 10.43.10.11  U02:01:32.340|c9bcfc80(drbd_a_w0) drbd_ack_receiver <3>drbd w0 pnode-id:3, cs(Connected), prole(Primary), cflag(0x200e), scf(0x2): meta connection shut down by peer.

	But errno 11 is EAGAIN, shouldn't fail here. And not BSOD later.

	Happened during network failure test (./iptables-drop-dont-drop-loop.sh
	on Linux and ./write-fs-loop.sh on Windows), not sure if it is
	the same BSOD, trying without I/O now.

	Update: Most likely this is an out-of-memory bug, with leak in
	the I/O path. Fix that leak and retry test.

	Update: Without I/O also happened (Server 2016)

	Probably related: Windows Server 2016 machine doesn't answer
	ping (last message is destroy_workqueue stopping a workqueue thread)

	This seems to be server 2016 related, does not happen with
	Windows 7

	Update: fixed with windrbd_thread race fix?

	Update: We assume this was the create thread race, which
	is fixed now. Reopen if it triggers again.

Done: Bug: BSOD on sync

	New BSOD introduced when fixing memory leak.

	Fixed now, do not use IoCompleteRequest on a completed IRP.

Done: Bug: User mode helper returns 127 where it shouldn't

	Only when run from windrbdumhelper service. PowerShell
	issue (tried also with exit 0, same result)?

	We should fix that, it is a showstopper (cannot sync, always
	goes into standalone).

	Use cmd.exe instead of PowerShell (it is way too slow anyways).

	Doesn't help, still those errors. drbdadm bug?

	No, it was cygwin not finding the cygwin1.dll drbdadm wasn't
	even called. Root cause is that PATH from kernel is invalid
	for our setup. We now hardcode a sane PATH (with C:\windrbd\..
	and C:\Program Files\WinDRBD and the Windows pathes), for
	the beta that should be enough. Later we may want cygrunsrv
	get fixed to handle whitespace in PATH components (seperate
	TODO).

Done: Code quality: remove some logs

Done: Feature: Upgrade to DRBD 9.0.16

	Once available.

	Is available now.
	Upgraded. Seems to work.

Done: Bug: BSOD on driver unload (Windows Server 2016, Windows 10)

	Last log message was:

Nov  2 15:54:45 10.43.10.11  U14:54:45.640|68fe9510(not_drbd_thread) mvolUnload WinSocket layer shut down.
Nov  2 15:54:45 10.43.10.11  U14:54:45.640|68fe9510(not_drbd_thread) shutdown_kmalloc_debug kmalloc_debug: Warning: memory leak of size 82, allocated by function SendTo at ../../win4lin/src/wsk2.c:649.

	which is a leak that does not exist on Windows 7.

	Update: This is the buffer for the printk message. Do not
	free it in cleanup routine (will be freed when the completion
	comes). Also wait for all network completions.

	Update: should be fixed with 19fbda0c.

Done: Bug: BSOD on I/O while connected

	write-fs-loop.sh:

	Windows Server 2016 <> Linux. Does not happen (?) with
	Windows 7 and Linux.

	Last log:

Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) windrbd_create <6>DRBD device create request: opening DRBD device read-only
Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) add_opener <7>drbd w0/1 minor 1, ds(UpToDate), dvflag(0x2): openers add: not_drbd_thread(0)
Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) windrbd_create <7>drbd_open returned 0
Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) windrbd_create <7>status is 0
Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) windrbd_cleanup <6>Pretending that cleanup does something.
Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) __prune_or_free_openers <7>drbd w0/1 minor 1, ds(UpToDate), dvflag(0x2): openers del: not_d
rbd_thread(0)Nov  2 16:37:20 10.43.10.11  U15:37:20.506|5e199510(not_drbd_thread) windrbd_close <7>drbd_release returned 0
Nov  2 16:37:27 10.43.10.11  U15:37:27.647|5e199510(not_drbd_thread) windrbd_device_control attrs->Action is 1
Nov  2 16:37:27 10.43.10.11  U15:37:27.647|5e199510(not_drbd_thread) windrbd_device_control 1 items

	Which means that somebody requested a TRIM on the DRBD device..

	Update: 

Nov  2 16:46:10 10.43.10.11  U15:46:10.683|29be9510(not_drbd_thread) add_opener <7>drbd w0/1 minor 1, ds(UpToDate), dvflag(0x80002): openers add: not_drbd_thread(0)
Nov  2 16:46:10 10.43.10.11  U15:46:10.683|29be9510(not_drbd_thread) windrbd_create <7>drbd_open returned 0
Nov  2 16:46:10 10.43.10.11  U15:46:10.683|29be9510(not_drbd_thread) windrbd_create <7>status is 0
Nov  2 16:46:10 10.43.10.11  U15:46:10.683|29be9510(not_drbd_thread) windrbd_cleanup <6>Pretending that cleanup does something.
Nov  2 16:46:10 10.43.10.11  U15:46:10.683|29be9510(not_drbd_thread) __prune_or_free_openers <7>drbd w0/1 minor 1, ds(UpToDate), dvflag(0x80002): openers del: not_drbd_thread(0)
Nov  2 16:46:10 10.43.10.11  U15:46:10.683|29be9510(not_drbd_thread) windrbd_close <7>drbd_release returned 0

	Update: No BSOD on sync. This is something between the
	upper device and networking (big pages?).

	Update: No BSOD on Primary Diskless (and connected).
	Update: No there was one now. Protocol was C. Also BSOD
	with protocol A.

	There was a printk in an error path inside a printk
	(wsk2.c:InitWskData) we fixed that now and the BSOD
	seems to be gone .. however the real reason is a memory
	leak.

	Not a memory leak but the Windows send buffer being full
	(and there is a quota for non-paged memory of 1GB for each
	driver, which acutally makes sense). When the connection
	goes down, consumed memory drops to normal level. Also
	when stopping I/O memory slowly (as being sent) drops
	down to normal level.

Done: Bug: DRBD hang on Server 2016

	After doing many things (testing BSOD on I/O).

	drbd down does not return, after that drbd commands, unloading
	windrbd and shutting down the machine hangs.

Nov  6 16:01:51 10.43.10.11  U15:01:51.633|c5aa9510(not_drbd_thread) windrbd_process_netlink_packet drbd cmd(DRBD_ADM_DOWN:27)
Nov  6 16:01:51 10.43.10.11  U15:01:51.633|c5aa9510(not_drbd_thread) windrbd_create <7>s->Parameters.Create.SecurityContext->DesiredAccess is 80
Nov  6 16:01:51 10.43.10.11  U15:01:51.633|c5aa9510(not_drbd_thread) windrbd_create <6>DRBD device create request: opening DRBD device read-only
Nov  6 16:01:51 10.43.10.11  U15:01:51.633|c5aa9510(not_drbd_thread) windrbd_create <7>drbd_open returned -11
Nov  6 16:01:51 10.43.10.11  U15:01:51.633|c5aa9510(not_drbd_thread) windrbd_create <7>status is c0000010

	After 5 Minutes it worked again ...

	Maybe because of out of memory (see BSOD on I/O TODO)?

	Was it the send timeout being infinite? I suppose..
	Reopen when it happens again.

Done: Implement send buffer limit.

	Hard limit is 1GB which is the quota of non-paged memory
	(at least on Server 2016). But we should stall the sending
	routine if the configured send buffer memory is in flight
	(wait for packets being sent).

	Fix remaining TODO's.
	Done fixing TODO's (except for socket refcount, which we will
	do later).

Done: new BSOD on I/O while connected

	write-fs-loop.sh on Windows side (being primary)
	Protocol C and attached.

	Put muteces around WskSend/WskReceive: does that help?

	No. Now also triggered with protocol C and detached.

	Using drbd_send_bio() (instead of drbd_send_zc_bio()) to
	send the data block. Has an extra copy but maybe there's
	something in drbd_send_zc_bio() (is there an extra
	get_page/put_page required?). MSG_MORE flag?

	Works now (by using drbd_send_bio instead of drbd_send_zc_bio)

Done: Test: test disk none

Done: Code quality: fake commit history (git rebase -i master)

	Remove commits reverted later, clean up.

	Update: Phil said best is to have one big patch for everything.
	That saves a lot of work.

	Update: Rebase once more and sqash commits

	Update: Rebased, not quite clear yet if we should sqash or
	otherwise clean up the commit history. Problem is that
	drbd-headers submodule is also rebased, which in turn
	caused some commits that used to compile to simply
	fail.

	Update: phil ack-ed waiting for Roland. Meanwhile write
	a commit message.

	Update: Minor changes TODO. Roland will do the squeeze,
	just push the changes upon current dev branch.

	Update: submitted, waiting for Roland to merge.

Done: Installation: some last fixes.

	Call Uninstall only once (see stackoverflow).
	Remove usr/sbin on Uninstall
	Do not ask for overwrite of config files (do not overwrite them)
	Hide cmd scripts again if everything works ok
	Stop user mode helpers and logger before upgrade
		(else cannot overwrite windrbd.exe)
	Offer to delete C:\windrbd on uninstall (warn about
	config / log files).

Done: Bug: Cannot stop driver when resource was ever Primary and I/O

	Proably some handle leak. Driver stays in STOP_PENDING state.
	And BSOD when shutting down computer.

	This appears to be fixed. At least it is known to work with
	current versions.

Done: Bug: Also BSOD on driver stop while drbdsetup events2 is running.

	BSOD when drbdsetup events2 is exiting (before it is in
	STOP_PENDING).

	Also seems to be fixed.

Done: Code quality: maybe: use file list in innosetup instead of a zip file.

	What would be cool if this makefile automatically builds the
	utils, installs them to a tmp folder and selects the files.

Done: Bug: When installing two times uninstall reports an error.

	Also when installed, running and installing again.
	Don't know for now, document it and do that later.

	Now, installer registers uninstall routing only once.

Done: Bug: Does not sync with Linux (DRBD 9.0.9)

	Sync stalls at 0%. Try to update Linux DRBD before doing
	anything else.

	Update: Upgraded Linux peer.

	After some reboots it worked again. Observe.

	Maybe something with the user mode helpers?

	Just happened with a 9.0.15 SyncTarget (Windows) and
	9.0.15 SyncSource (Linux).

	Update: fixed with windrbd_thread race fix?

	Update: No, just happened with Windows 7 and Windows 10

	Update: again (between server 2016 and linux) rebooting
	Windows solved it (down / up not, rebooting Linux also not)

	Also reloading driver does not help.

	Update: This might be an upstream problem, there are some
	bugs in sync code (we just had 76% on one side and 0% on
	the other side).

	Update: Now had the case: Linux stalls at 76% Windows at
	0%
	(after Primary Diskless on Windows crashed)
	After down / create-md / up on Windows side: Linux stalls
	at 0% Windows also at 0%
	After down / create-md / up on Linux side: both inconsistent
	After primary --force on Windows side: they sync again.

	Running Primary Diskless and attach it while I/O seems
	to trigger the bug.

	Update: Also on Linux/Linux where it stalls at 0%
	then at 20%, 40% ... and eventually succeeds.

	Finally found it: Uses network socket stats to check if sendbuffer
	is half full. However, these are not implemented. We are reading
	uninitialized data here (that's probably why a reboot helped).

	Observe. But I think it is fixed with d2989fd.

Done: Bug: sc stop windrbd BSOD's if there are resources up.

	We need a refcount on the root object on mod_inc_use_count().
	Once we do so we can support driver unloading officially
	(which also greatly simplifies installation)

	Update: working on refcount, however cannot open any file
	once driver is STOP_PENDING. What we need is a mechanism
	to control the stoppable flag programmatically from the
	kernel (so that sc stop windrbd fails when there are devices
	configured).

        Set AddDevice on module get and unset it on module put.

        That does the trick. Windows checks on sc stop if this
        member is non-NULL and if yes refuses to stop the driver.
        If it is reset to NULL again driver can be stopped again
        (even tough sc query shows it as non stoppable).

	We need a refcount now .. first test it on Windows Server
	2016 and Windows 10.

	Update: have refcount and seems to work on all tested
	platforms.

Done: Implement: Use DOS linefeeds for log file

	So one can open it with NotePad.

Done: Test: repeat the USB stick unplug test (Windows 10).

	Done, works. Also resyncs again if stick is plugged
	and attached.

Done: Documentation: white paper for linbit website.

	Until end of June 2018
	Update: maybe refer to the README.md.

	Update: No we need a TechGuide. Postponed to September.

	Guide how to connect 2 Windows boxes via DRBD.
	(Windows 2016)

	Also document how to run pacemaker under WSL
	Update: no, do a serperate tech guide for that please.

	Update: submitting to Joel for cleaning up my
	English. Other than that, done.

	Update: Done, integrate in package.

Duplicate: Implement: Make windrbd utils relocateable.

	Do not hardcode C:\windrbd

Done: Bug: Uninstall currenty BSOD's if there was ever I/O

	Currently (for beta5) removing the driver is disabled
	(made it a PnP driver (again) by setting AddDevice which
	causes sc stop windrbd to fail).

	There is a mechanism to block driver unload if resources
	are up.

Done: Bug: Syncing sometimes stalls now.

	And seems to be slow.

	Update: When WinDRBD is SyncSource it takes around 4-5 seconds
	When SyncTarget, it takes up to 55 seconds (!).

	cond_wait busy loop?

	We know of a 4k per request issue, fix that and check if sync
	is faster. The stall was probably because of uninitialized
	data in network statistics and is fixed now.

Done: Usability: show how to load driver if drbdadm --version does not work.

	From Devin.
	Done, but shell escaped.

Done: Installation: exe containing everything (no zip file please)

	Done: Release number? (0.9.0?) yes
	Done: Remove old beta from site. -> Roland
	Done: Techguide as pdf seperately. -> Roland
	Done: Run a rootkit detector on exe?
	Done: Link to download WinDRBD in tech guide
	Done: Start menu entry for techguide

	Push WinDRBD -> Phil (after setting 0.9.0 tag)
	Push drbd-utils -> Lars

	Latest cygwin1.dll (works with current one, no need to change).

Rejected: Code quality: fix drbd_send_zc_copy and use it again.

	Maybe just moving get_page before wait_for_sendbuf fixes
	it.

	No.

	BSOD also happens when diskless primary. setting sendbuf
	to 1 changed behaviour a bit (?). Printk's show that it is
	most likely something in the completion routine (last line
	reached changes between runs).

	Maybe because memory is from NTFS driver and we do something
	in the Irp/MDL handling wrong in that case. Maybe check what
	happens when copiing write requests also to a tmp buffer
	(similar to read requests).

	Update: This seems not to happen if the device is accessed
	directly (without NTFS). Yes, test ran overnight without
	issue.

	This again seems to be a subtile NTFS driver bug (which is
	present in Server 2016 but not in Windows 7). Since it
	works (we would have to copy every write request else to
	have a stable version) do not use zero copy at all. Don't
	know how to fix zero copy at the moment.

Rejected: Code quality: do not unlock pages

	Not doing so BSODs on drbdadm up on Windows 7 and
	on Primary (write? read?) on Server 2016. Maybe
	using MmBuildMdlForNonPagedPool fixes it?

	This may cause BSODs when the system starts paging,
	so please fix. Update: Test with memory consumer didn't
	crash.

	Just calling MmBuildMdlForNonPagedPool() for MDLs allocated
	by IoBuildAsynchronousFsdRequest() BSODs. Also not unlocking
	pages BSODs (for NonPaged pages). It seems that the solution
	we have is the one that works. Leave it like this until
	someone complains (the Unlock is only done for pages that
	are in the NonPaged pool and the memory consumer test didn't
	find anything, so I think we can leave it like this).

Done: Research: Check if pacemaker under WSL works

	And include in documentation.

	Update: our Windows 10 physical machine cannot install
	apps or updates and a manual download of Ubuntu for WSL
	does not start. Don't know why. We however need the machine
	for something else, so get a Windows 10 VM (on much or
	somewhere else) and try the WSL thing there.

	Update: Got it running. Not suitable for our case (WSL)
	since WSL is not designed for running services (a poweroff -f
	for example just closes the Window).

Done: Documentation: Blog for Linbit homepage

	Describe 3 use cases:

	Making existing services highly available
	Virtualization (see OpenNebula project)
	LinDrive: Diskless Primary on Clients

	Until Mid January 2019

	Update: until Jan, 23

Done: Research: typeof() replacement

	It exists, but only when compiled as C++ (which we can't).
	Is called decltype (expression) and is part of C++ 11. We
	cannot use it since everything is C, not C++.

Done: Bug: 3 node setup sometimes does not work.

	If node with node-id 1 is missing, node 2 thinks that node
	3 is node 1 during connection establishment:

Jun 26 17:13:17 wintestubuntu kernel: [ 4658.372463] drbd w0 tcp:win7-64: Closing unexpected connection from 10.43.8.188

	(but 10.43.8.188 is WIN-F11R93CP9KI).

	Sometimes connection can be established however we get a
	BSOD then.

	Connection between 2 nodes (Linux and Windows VirtualBox)
	works, but 3rd node (Windows 10 physical machine) BSOD's.

	Update: Now managed to have stable 3-node setup between
	Windows 7 VM, Linux VM and Windows 10 PhysM.

	Update: Happened again, this time without the presence of
	the DESKTOP-0VHSFB5 node (didn't touch config, before doing
	experiments with logging (log to a non-existing host) it
	worked).

Aug  3 22:56:36 johannes-VirtualBox kernel: [12446.338715] drbd w0 tcp:DESKTOP-0VHSFB5: Closing unexpected connection from 192.168.56.101

	(note that this log message is from a drbd-9.0.14 Linux
	host).

	Update: Rebooting the Linux machine solved the problem
	(resource on Windows wasn't taken down meanwhile) so
	most likely something that causes Linux DRBD to mistake
	one Windows host for another.

	Update: something with the waiters in the listener:

Oct 23 18:51:07 192.168.56.101  U16:51:05.086|057ea4f0(not_drbd_thread) addr_equal addr1->ss_family is 2
Oct 23 18:51:07 192.168.56.101  U16:51:05.086|057ea4f0(not_drbd_thread) addr_equal addr2->ss_family is 2
Oct 23 18:51:07 192.168.56.101  U16:51:05.086|057ea4f0(not_drbd_thread) addr_equal addr1 is 10.43.10.14
Oct 23 18:51:07 192.168.56.101  U16:51:05.086|057ea4f0(not_drbd_thread) addr_equal addr2 is 10.43.10.14
Oct 23 18:51:07 192.168.56.101  U16:51:05.086|057ea4f0(not_drbd_thread) dtt_incoming_connection <4>Closing unexpected connection from 10.43.10.13

	showing that 10.43.10.13 is not in the waiters list (the
	compare is ok). Ask phil. Do it after beta5.

	Re-port drbd_transport_tcp first and see if it is still a
	problem.

	Update: 4 node setup works now, however some minor errors
	(see seperate bug entries)

Done: Bug: Sometimes it takes a while until Windows can connect to Windows

	On one side (Windows 10 physical machine):

Jul  9 16:16:37 10.43.8.215  U14:16:34.379|c214be70(receiver) dtt_connect <7>[0xFFFFA88BC20B8380] dtt_connect:(FFFFA88BC20B8380) Accepted:  10.43.8.215:7600 <- 10.43.7.228:7600
Jul  9 16:16:38 10.43.8.215  U14:16:34.879|c214be70(receiver) Receive <6>[0xFFFFA88BC20B8380] RECV(receiver) wsk(0xFFFFA88BC43A5688) multiWait err(0xc000020d:CONNECTION_RESET)
Jul  9 16:16:38 10.43.8.215  U14:16:34.879|c214be70(receiver) drbd_recv <6>drbd w0 pnode-id:2, cs(Connecting), prole(Unknown), cflag(0x200e), scf(0x0): sock was reset by peer
Jul  9 16:16:38 10.43.8.215  U14:16:34.879|c214be70(receiver) print_state_change <6>drbd w0 pnode-id:2, cs(Connecting), prole(Unknown), cflag(0x200e), scf(0x21): conn( Connecting -> BrokenPipe )
Jul  9 16:16:38 10.43.8.215  [last message was in IRQ context]
Jul  9 16:16:38 10.43.8.215  U14:16:34.879|c214be70(receiver) drbd_recv_all_warn <4>drbd w0 pnode-id:2, cs(BrokenPipe), prole(Unknown), cflag(0x200e), scf(0x0): short read (expected size 8)

	On other side (Windows 7 VM):

Jul  9 16:11:43 192.168.56.101  U14:11:40.240|12904fa0(receiver) dtt_connect <7>[0xFFFFFA800373EA50] dtt_connect: Connected: 10.43.7.228:7600 -> 10.43.8.215:7600
Jul  9 16:11:44 192.168.56.101  U14:11:41.271|12904fa0(receiver) drbd_recv <6>drbd w0 pnode-id:1, cs(Connecting), prole(Unknown), cflag(0x0), scf(0x0): sock was shut down by peer
Jul  9 16:11:44 192.168.56.101  U14:11:41.271|12904fa0(receiver) print_state_change <6>drbd w0 pnode-id:1, cs(Connecting), prole(Unknown), cflag(0x0), scf(0x21): conn( Connecting -> BrokenPipe )
Jul  9 16:11:44 192.168.56.101  [last message was in IRQ context]
Jul  9 16:11:44 192.168.56.101  U14:11:41.271|12904fa0(receiver) drbd_recv_all_warn <4>drbd w0 pnode-id:1, cs(BrokenPipe), prole(Unknown), cflag(0x0), scf(0x0): short read (expected size 8)

	After a while the two machines find each other.

	Re-port drbd_transport_tcp first and see if it is still a
	problem.

	Update: drbd_tranport_tcp reported, works a little bit better:
	Currently getting sock_recvmsg returned -11 on one Windows node.
	Comes into Sync at 0% but then aborts connection.

	We also had:

Feb  1 17:33:29 wintestubuntu kernel: [7339344.294343] drbd vamp-4nodes tcp:server-2016-B: Closing unexpected connection from 10.43.10.10

	(but 10.43.10.10 is jt-win7-vm)
	(with DRBD 9.0.9) updated DRBD not observed so far.

	Update: fixed a receive error (MSG_WAITALL wasn't implemented)
	seems to work now.

Duplicate: Research: Auto-Promote possible?

	If Windows accesses drive read-only on poll.

Done: Implement: Make drbd service stoppable
	This probably takes some while
	Update: with the new architecture that should be possible
	one day.

	Probably some setting in the inf section. Or the way DRBD
	registers itself in DriverEntry? DriverUnload() routine
	returning something?

	Update: After changing linker options (/DRIVER:WDM to
	/DRIVER /SUBSYSTEM:WINDOWS) this works in theory. Things
	we need to clean up include:

	*) Threads (PsCreateSystemThread())
		alloc_ordered_workqueue()
		destroy_workqueue()
	*) Lookaside lists (ExInitializeNPagedLookasideList())
		kmem_cache_create() see slab.c
	*) Update: All memory leaks (ExAllocatePoolWithTag(NonPagedPool, ...))
		kmalloc() and friends. Also for PagedPool?

	Right now, almost everything works, as long as no resources
	are created. Missing: Terminate reply_reaper thread, wait
	for wsk init thread completion (or terminate it?), really
	clean up after resources. Sockets really don't need destroy
	function?

	Update: Works quite nice, however after a drbdsetup create-resource
	drbdsetup del-resource some resources are not freed, which in
	turn causes Unload not being called (which in turn causes
	driver verifier to BSOD).

	Update: As soon as there is just a single memory leak, driver
	verifier BSOD's after unload. This will be fun to fix all of
	those ...

	Update: We need something like dmalloc .. maybe implement some
	of it for our kmalloc()/kfree() to see at driver unload where
	we leak (and free it there). At this point also get rid of the
	Tag patches, we really don't need them. What also would be nice
	at this point is to be able to inject out of memory faults selected
	by source line.

	For now defer that TODO to somewhere later (after beta5).

	Update: Or maybe implement kmalloc debugger now and fix some of the
	leaks (don't deliver beta with kmalloc debugger enabled)
	but do not unload driver on uninstall. Users may use
	sc stop windrbd if they really want to.

	Update: kmalloc() debugger implemented and works fine. On drbdadm up
	down leaks at 3 code paths are found (plus an extra leak that the
	debugger didn't find, probably kmem_cache_alloc()). Fix them
	one day (there are probably more than that).

	Update: We just discovered that driver verifier was activated
	on every make install. Technically, a 'normal' Windows installation
	doesn't have driver verifier enabled. So we would have saved
	tons of nerves (and time) if we never had driver verifier
	enabled (no BSOD at least not so many). Removed the line from
	the Makefile, now unloading works as expected (tough probably
	the driver is still in memory a new version of the driver
	can be loaded without rebooting). Think about including
	driver unload in beta5.

	Update: no beta5 will be with unloading disabled.

	Update: driver now is not stoppable while there are resources
	up, just as with Linux. As long as driver verifier isn't enabled
	no BSODs. Fix the remaining memory leaks and close this
	TODO.

Done: Code quality: Re-port drbd_transport_tcp.c to windrbd's
	drbd_transport_wtcp.c.
	Update: currently it seems that the problem is
	somewhere else. 
	However we need those updates. Best way would be to
	git diff the original drbd transport_tcp to the version
	we had before and apply the patches manually.

	Update: we should integrate drbd_transport_tcp back to
	converted-sources.

	Update: it seems to be doable, but first change the
	wsk2.c API to match the kernel API (Send->kernel_send_msg
	and so on).

Done: Code Quality: Make windrbd-test compile again.

	Needed 2 patches to drbd-headers/drbd-utils, however.

Duplicate: Bug: leaking disk (see TODO in drbd_main.c)

Duplicate: Bug: leaking something allocated by fifo_alloc

	Probably also in upstream DRBD.

Done: Code quality: use drbd-headers/windrbd merged branch in Linux DRBD

Done: Bug: In 4 node setup cannot make 2 of the nodes primary

	Error message is:

$ drbdadm primary vamp-4nodes
vamp-4nodes: State change failed: (-19) Concurrent state changes detected and aborted
Command 'drbdsetup primary vamp-4nodes' terminated with exit code 11

	Update: Was -EINTR on receive dropping data. Should not
	happen any more.

Done: Test: Test Primary Diskless after EINTR patch

	We introduced this for a reason, see if the patch breaks
	things.

    " ... When being the peer of a Diskless Primary doing I/O (sending
    P_DATA packets) windrbd was stuck in NetworkFailure when
    the cable was unplugged. ..."

	No NetworkFailure stuckness, behaves as expected.

Done: Bug: Cancel Disconnect Socket

Feb  5 14:56:43 10.43.10.11  U13:56:43.283|4260b600(drbd_r_vamp-4nodes) drbd_recv <6>drbd vamp-4nodes pnode-id:4, cs(NetworkFailure), prole(Unknown), cflag(0x2000a), scf(0x0): sock_recvmsg returned -4
....
Feb  5 14:56:44 10.43.10.11  U13:56:44.283|4260b600(drbd_r_vamp-4nodes) kernel_sock_shutdown Timeout... Cancel Disconnect socket:FFFFBC853E36E4A8

	This probably happens if the peer fails to shut down the TCP/IP
	connection (for example when he is down). Increased timeout to
	connect_timeo (which makes sense, because on the net connect
	and disconnect is very similar). Have a message, but users
	can ignore it.

Done: Bug: Connection instable when connecting two Windows boxes.

	In that case our physical Windows 10 with Windows 7 VM on
	much.

	And one box is not pingable any more. Maybe something with
	libvirt? Hangs because logging does not work (was configured
	to log to Linux VM).

	Update: happens also with VirtualBox (Mac) Windows 7 box.
	drbdadm down / up on Windows 10 usually solves the problem.

	Update: really? Was split-brain, IP address change.

	Update: We also just had a complete network outage on
	the testing subnet..

	Update: Windows 10 to Mac VMs seems to have no problems.
	Problem seems to be only between much VM's and Windows 10.

	Update: After re-porting the transport_tcp code, this seems
	to be fixed.

Done: Bug: In 4 node setup, connection loss on I/O

	Windows Server 2016 machine (Secondary) loses connection
	to 2 other nodes and cannot establish it unless disconnect/
	connect is done on the other nodes. The Primary node has
	to be taken down completely (down/up).

	Update: After EINTR fix, does this still happen?

	It didn't happen recently, please reopen when it happens again.

Done: Code quality: drbd-patches directory probably should go away.

	Also samples dir. Reorganize a bit (put release description
	in separate dir, ...)

Done: sendbuf_cur -> into sk

Rejected: try to implement typeof (for list iterators)
	No we need C++

Done: sock_create_kern extra parameters (SocketContect, Dispatch, Flags)?
	Now have WinDRBD specific SOCK_LISTEN socket type.

Rejected: Submit platform_update_socket_buffer_sizes()?
	No.

Done: Bug: bio_set_op_attrs <2>[0xFFFFFA80033783B0] BUG: failure

	Maybe this was introduced during code cleanup. Update: no it wasn't.
	The reason is that REQ_OP_FLUSH != REQ_OP_WRITE in windrbd,
	which has to be fixed (they also should be powers of two,
	see comment in win4lin/drbd_wrappers.h:544.

	The bug appears on testing resync.

	Update: Also happened to Devin.

	Now, changed error message to see the values.

	For now, do a rate limit on the message (it shouldn't fill
	the log).

	Update: found it: REQ_OP_FLUSH is != REQ_OP_WRITE in WinDRBD,
	allow for this also.

Done: Bug: BSOD on 4 node setup when doing I/O

	On the node that does I/O (Windows 10 machine).

Feb  5 14:56:49 10.43.10.13  U13:56:45.180|01741f10(drbd_a_vamp-4nodes) print_state_change <6>drbd vamp-4nodes pnode-id:4, cs(Connected), prole(Secondary), cflag(0x2040e), scf(0x21): conn( Connected -> NetworkFailure ) peer( Secondary -> Unknown )
Feb  5 14:56:49 10.43.10.13  U13:56:45.180|01741f10(drbd_a_vamp-4nodes) print_state_change <6>drbd vamp-4nodes/1 minor 1 pnode-id:4, pdsk(UpToDate), prpl(Established), pdvflag(0xc00): pdsk( UpToDate -> DUnknown ) repl( Established -> Off )
Feb  5 14:56:49 10.43.10.13  [last 2 messages were in IRQ context]
Feb  5 14:56:49 10.43.10.13  U13:56:45.180|017417d0(drbd_r_vamp-4nodes) drbd_recv <6>drbd vamp-4nodes pnode-id:4, cs(Connected), prole(Secondary), cflag(0x2040e), scf(0x21): sock_recvmsg returned -4
Feb  5 14:56:49 10.43.10.13  U13:56:45.180|01741f10(drbd_a_vamp-4nodes) drbd_ack_receiver <6>drbd vamp-4nodes pnode-id:4, cs(NetworkFailure), prole(Unknown), cflag(0x2040e), scf(0x0): ack_receiver terminated
Feb  5 14:56:49 10.43.10.13  U13:56:45.180|01741f10(drbd_a_vamp-4nodes) drbd_thread_setup <6>drbd vamp-4nodes pnode-id:4, cs(NetworkFailure), prole(Unknown), cflag(0x2040e), scf(0x21): Terminating ack_recv thread
Feb  5 14:56:49 10.43.10.13  [last message was in IRQ context]
Feb  5 14:56:49 10.43.10.13  U13:56:45.226|e991b560(not_drbd_thread) windrbd_reap_threads Buried drbd_a_vamp-4nodes thread
Feb  5 14:56:52 10.43.10.13  U13:56:47.414|f4f10410(drbd_s_vamp-4nodes) dtt_send_page <4>drbd vamp-4nodes tcp:jt-win7-vm: dtt_send_page: size=40 len=40 sent=-110
Feb  5 14:56:52 10.43.10.13  [last message was in IRQ context]
Feb  5 14:56:52 10.43.10.13  U13:56:48.758|0171bce0(drbd_w_vamp-4nodes) __drbd_uuid_new_current <6>drbd vamp-4nodes/1 minor 1, ds(UpToDate), dvflag(0x80286): new current UUID: 22A0B49B89D25CEF weak: FFFFFFFFFFFFFFF1

	Also observed BSOD on Secondary (win7). No BSOD so far
	on Server 2016 (Primary) (20 hour test).

	Currently testing with win7 being Primary.
	No crash (ran 3 hours), now testing with Windows 10 (again).

	Crash on Windows 10 when Windows 7 was rebooted (and Windows 10
	being Primary and doing I/O).

	Also when packets are dropped (via iptables) on the Linux machine
	(being secondary), however not always.

	Strange: goes into NetworkFailure with congested on (send should
	report errors) first then freezes then BSOD's

	Test with local VMs (2 nodes) could not reproduce behaviour.

	Test with 2 nodes setup (Windows 10 / Linux): error happens,
	so it is most likely Windows 10 specific.

	It appears to be fixed with fca13116f, do some more tests
	with 4 nodes and close this TODO.

Done: Implement: Create patch file(s) for tcp transport.

	Done. Always use the output of the cocci, perl and shell
	scripts (with long -> LONG_PTR and the like) as base for
	manual patches since they are applied before manual patches
	by the transform script (use make on a linux box without
	manual patches to create them). We are now using the original
	DRBD (with patches) TCP transport implementation.

Done: Bug: BSOD on driver unload after up (tmp patches for create boot device)

	2 reasons: kmalloc_debug freeing printk sockets on memory leak
	cleanup (function name of function doing kmalloc() changed) and
	there were leaks in sock_create_kern (if CreateSocket() failed,
	Linux sockets were not deallocated).

	Works with 0f94023c1.

Done: Bug: Right now, sc stop windrbd stalls.

	Works with c8a2ab?

	Works again with 0f94023c1: need to close all sockets before
	releasing provider NPI (including printk sockets).

	Update: But not when there were connections up. We narrowed
	the problem down to the incoming socket handler (we leak
	incoming sockets somewhere here).

	Update: Also close incoming wsk sockets that are not
	accepted by DRBD (see 36d3d972). Stall problem is
	fixed now.

Done: Code quality: allow recursive printk's.

	For example within SendTo (check if there is a printk
	ongoing and write it just into the ring buffer if yes).

	Implemented. Be aware that logging all the time in a
	function in the printk still endless loops (logging
	only error conditions should work, tough).

Done: Code quality: clear error state on socket if status is success.

	This caused printk on boot not to work. We now have a
	workaround (discard the socket if SendTo() returns an
	error) but one day we want to fix this.

	Update: we now clear the error status for datagram sockets
	if status is success later. This allows us to reuse the
	socket in printk.

Done: Bug: BSOD on load/unload loop

	Appears to be a resource leak in networking (does not
	connect since peer resource is down). No BSOD so far
	when doing only status and also when doing only attach.

	Update: now reaping all threads, is this fixed?

	Update: updown loop ran 100 times, no BSOD. Seems to
	be fixed, reopen on problems.

Done: Bug: drbdadm wait-connect does not work as expected

	Please fix, this is helpful for testing.

    Following happens:

    .) drbdadm wait-connect joins a multicast group with pid X.
    .) drbdadm wait-connect exits.
    .) WinDRBD kernel driver continues to send message to that multicast
       group.
    .) drbdadm is started later with the same pid (CygWin recycles
       unused PIDs).
    .) This drbdadm gets messages sent meanwhile to the mc group
       with wrong sequence numbers.
 
    We have 2 bugs here:

    .) There is no 'leave multicast' group. multicast groups remain
       until the driver is unloaded or the system reboots.
    .) The PID is probably not a good unique ID. However if we
       fix the above, it wouldn't matter.

    Probably the correct way to solve this is to destroy the multicast
    group when the file handle that was used to create it is closed
    (drbd-utils does not explicitly close the handle, it is closed
    implicitly by the OS when the process exits).

	Update: Implemented removing the multicast group when the
	file for the root device that was used to create the mc
	group is closed (i.e. when the drbdsetup command exits).

	It should be fixed with 7b7b90708.

Done: BSOD on drbdadm up

	With new 9.0.17 DRBD code.

	Fixed with 4c8c46a4, see commit message.

Done: Implement: Upgrade DRBD to 9.0.17

	Once it is released.

Done: Implement: fix the spinlocks (see comments in drbd_windows.c).

	Windows doesn't have an equivalent of spin_lock_irq()
	(without flags) however we can assume that interrupts
	are enabled when spin_lock_irq is called and reset it
	to enabled when spin_unlock_irq is called (set it to
	PASSIVE_LEVEL).

	So no need for a tmp storage here. (Maybe put an assert
	at the beginning of spin_lock_irq that tests for IRQL
	being PASSIVE_LEVEL).

	Update: Unfortunately this is a little bit more complicated.
	IRQL is often 2 at the start of spin_lock() and there is
	no such thing as a spin_lock that does not touch the
	IRQL. Also, since RCU uses a spin lock internally it
	also raises the IRQ level (where DRBD does not expect it).
	We fixed some of the spin locks (turning them into
	spin_lock_irqsave/spin_unlock_irqrestore), but that's
	probably not the way to go finally. Plus Windows 10
	kernels (and probably others) BSOD if the IRQL is
	changed in a wrong way (by spin_unlock()).

	Update: We found a (probably 'illegal') way of acquiring
	a spinlock without touching the IRQL (this is what spin_lock/
	spin_unlock is supposed to do). Calling
	KeAcquireSpinLockAtDpcLevel does this (but according to
	the docs, IRQL is required to be >= DISPATCH_LEVEL here).

	Of the spinlock 'bugs' only a few remained (on Windows 10
	when becoming Primary, IRQL is a APC_LEVEL (1) when executing
	I/O finished callbacks). After fixing those is runs quite
	stable, however more tests are required (we had a new hang on
	Windows 7 / Secondary on connection loss which is probably
	due to the KeAcquireSpinLockAtDpcLevel patch).

	If possible revert (some of the) spin_lock_irqsave patches
	later (they don't hurt, but are probably not neccessary
	any more).

	Spinlocks now re-implemented. Setting IRQL to PASSIVE_LEVEL
	in spin_unlock_irq() seems not to cause problems. However
	one day we might chose to switch to KeAcquireSpinLockAtDpcLevel()
	in spin_lock, thereby not changing the IRQL.

Done: Code quality: RCU needs change
	At least call_rcu now calls the function. I don't think
	that it is a good idea to port the linked list thing to
	windows, we want to stay thin..

	Update: talk to phil about current solution (just call
	the function). I don't think that it is a good idea to
	mimic the original intended behaviour in Windows.

	Update: We now call the cleanup / on update function 
	in the call_rcu() function, which makes the thing work.
	Double check if that works as expected.

	Update: RCU should currently cause problems on SMP machines
	only (we always tested single CPU, so this was not a problem).
	Implement Phil's algorithm.

	Update: I think it is a bad idea to sleep in synchronize_rcu()
	to make sure that other tasks are not using the old RCU
	and use a linear list. I think leaving it like it is
	(as a read/write lock) and not doing a copy on update
	is the best way to implement it. Performance is still
	poor on many other code paths (like Syncing or
	wait_event). However allow the read_lock being taken
	recursively.

Done: Install: also sign install EXE

	Done for release builds. Users will be displayed a panel
	saying that EXE is signed by Linbit-HA Solutions.

Done: Bug: Sync stall at 0 percent.

	Introduced when upgrading to DRBD 9.0.17

	Most likely because ktime_get() always returns 0, therefore
	for DRBD time stands still. Implement ktime_get and see if
	it works (can use GetTickCount64 for that).

Done: Bug: Had a Sync stall in 4 node setup

	One node at 98.9 percent other at around 50% (but 130% on its
	peer).

	According to Roland there are known issues with 4-nodes in
	Linux as well. He recommended not to test with more than 3
	nodes for now.

	Do that later.

	No, now, also happens when 2 of the nodes are disconnected.

	Also in 2 node setup?

	Yes, between Windows 10 (Primary) and Linux

	This is probably something for upstream. Also: how long
	did we wait for sync to complete? Update: we waited 30
	Minutes, that is too long.

	Try to reproduce in a Linux/Linux setup (possible with ntfs
	atop of it, according to Lars this might matter).

	Update: According to phil there are new patches to upstream
	DRBD which should solve that issue. DRBD 9.0.17 will be released
	in about 2-3 weeks, wait with 0.9.2 for that release. Upgrade
	now to see if the sync problem is fixed already.

	Update: Upgraded. Still problems when syncing and there is
	I/O.

	Works when win7 is Primary (on Windows 10 Sync finishes), but
	not the other way around.

	Update: Fixed with 4c8c46a4a (based on DRBD 9.0.17)?
	It seems to be fixed now (ran 100 times with I/O on
	Linux and invalidate-wait-sync on Windows Server 2016)

Done: Bug: BSOD on drbdadm down (with PnP)

Done: Bug: unblock SCSI size requests on drbdadm down
	Else REMOVE_DEVICE is never called.

Done: Bug: PnP BSOD on opening partition manager

Done: implement SCSI I/O

	Right now, partition manager fails with Invalid function.
	Update: Works now (must set SRB status to success)

Done: Make device create on boot Primary.

Done: Feature: Configure DHCP for autobooting image

	Using standard iPXE booting a sanboot (and probably other
	DRBD related features) enabled iPXE and then boot Windows
	via sanboot.

	Done, it is documented in howto

Done: Bug: Windows does not switch into graphics mode any more

	We observe about 1800000 drbd packets (sectors?) being read,
	however Windows does not switch into graphics mode any more.
	Probably because it crashed several times before? Maybe we
	need to repair the image.

	This seems to be fixed after chkdsk'ing the image

Done: Bug: Windows freezes very soon when booted via WinDRBD system volume
	Hasn't happened recently after giving it more RAM (and turned
	off pagefile) and disabling both net and mem printk's

