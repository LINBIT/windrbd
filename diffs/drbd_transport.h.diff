--- ../../drbd/drbd/drbd-headers/drbd_transport.h	2023-02-17 14:26:26.854467352 +0000
+++ drbd-headers/drbd_transport.h	2023-02-17 14:26:29.362420219 +0000
@@ -27,24 +27,26 @@
  */
 #define GFP_TRY	(__GFP_HIGHMEM | __GFP_NOWARN | __GFP_RECLAIM)
! manual those tr_printk macros are too gcc specific ...
 
-#define tr_printk(level, transport, fmt, args...)  ({		\
-	rcu_read_lock();					\
-	printk(level "drbd %s %s:%s: " fmt,			\
-	       (transport)->log_prefix,				\
-	       (transport)->class->name,			\
-	       rcu_dereference((transport)->net_conf)->name,	\
-	       ## args);					\
-	rcu_read_unlock();					\
-	})
-
-#define tr_err(transport, fmt, args...) \
-	tr_printk(KERN_ERR, transport, fmt, ## args)
-#define tr_warn(transport, fmt, args...) \
-	tr_printk(KERN_WARNING, transport, fmt, ## args)
-#define tr_notice(transport, fmt, args...) \
-	tr_printk(KERN_NOTICE, transport, fmt, ## args)
-#define tr_info(transport, fmt, args...) \
-	tr_printk(KERN_INFO, transport, fmt, ## args)
+
+#define tr_printk(level, transport, fmt, ...)  {                        \
+    KIRQL _tr_printk_rcu_flags;                                         \
+    _tr_printk_rcu_flags = rcu_read_lock();                             \
+    printk(level "drbd %s %s:%s: " fmt,                                 \
+           (transport)->log_prefix,                                     \
+           (transport)->class->name,                                    \
+           rcu_dereference((transport)->net_conf)->name,                \
+           __VA_ARGS__);                                                \
+    rcu_read_unlock(_tr_printk_rcu_flags);                              \
+    }
+
+#define tr_err(transport, fmt, ...) \
+	tr_printk(KERN_ERR, transport, fmt, ## __VA_ARGS__)
+#define tr_warn(transport, fmt, ...) \
+	tr_printk(KERN_WARNING, transport, fmt, ## __VA_ARGS__)
+#define tr_notice(transport, fmt, ...) \
+	tr_printk(KERN_NOTICE, transport, fmt, ## __VA_ARGS__)
+#define tr_info(transport, fmt, ...) \
+	tr_printk(KERN_INFO, transport, fmt, ## __VA_ARGS__)
 
 #define TR_ASSERT(x, exp)							\
 	do {									\
@@ -120,7 +122,7 @@
 
 	/* These members are intended to be updated by the transport: */
 	unsigned int ko_count;
! cocci
-	unsigned long flags;
+	ULONG_PTR flags;
 };
 
 struct drbd_transport_stats {
@@ -194,8 +196,8 @@
 
 	void (*stats)(struct drbd_transport *, struct drbd_transport_stats *stats);
 	void (*net_conf_change)(struct drbd_transport *, struct net_conf *new_net_conf);
! cocci
-	void (*set_rcvtimeo)(struct drbd_transport *, enum drbd_stream, long timeout);
-	long (*get_rcvtimeo)(struct drbd_transport *, enum drbd_stream);
+	void (*set_rcvtimeo)(struct drbd_transport *, enum drbd_stream, LONG_PTR timeout);
+	LONG_PTR (*get_rcvtimeo)(struct drbd_transport *, enum drbd_stream);
 	int (*send_page)(struct drbd_transport *, enum drbd_stream, struct page *,
 			 int offset, size_t size, unsigned msg_flags);
 	int (*send_zc_bio)(struct drbd_transport *, struct bio *bio);
@@ -216,7 +218,6 @@
 	struct list_head list;
 };
 
-
 /* An "abstract base class" for transport implementations. I.e. it
    should be embedded into a transport specific representation of a
    listening "socket" */
@@ -252,15 +253,15 @@
 extern void drbd_path_event(struct drbd_transport *transport, struct drbd_path *path, bool destroyed);
 
 /* drbd_receiver.c*/
! review: we should not change the signature of drbd_alloc_pages
-extern struct page *drbd_alloc_pages(struct drbd_transport *, unsigned int, gfp_t);
+extern struct page *drbd_alloc_pages(struct drbd_transport *, unsigned int, gfp_t, int use_big_pages);
 extern void drbd_free_pages(struct drbd_transport *transport, struct page *page, int is_net);
 extern void drbd_control_data_ready(struct drbd_transport *transport, struct drbd_const_buffer *pool);
 extern void drbd_control_event(struct drbd_transport *transport, enum drbd_tr_event);
 
! review: we should not change the signature of drbd_alloc_pages
 static inline void drbd_alloc_page_chain(struct drbd_transport *t,
-	struct drbd_page_chain_head *chain, unsigned int nr, gfp_t gfp_flags)
+	struct drbd_page_chain_head *chain, unsigned int nr, gfp_t gfp_flags, int use_big_pages)
 {
! review: we should not change the signature of drbd_alloc_pages
-	chain->head = drbd_alloc_pages(t, nr, gfp_flags);
+	chain->head = drbd_alloc_pages(t, nr, gfp_flags, use_big_pages);
 	chain->nr_pages = chain->head ? nr : 0;
 }
 
@@ -305,16 +306,8 @@
 /* grafted over struct page.lru */
 struct drbd_page_chain {
 	struct page *next;	/* next page in chain, if any */
! review: hmm this unsigned short most likely does not work for drbd_page_chain so make sure CONFIG_64BIT is set
-#ifdef CONFIG_64BIT
 	unsigned int offset;	/* start offset of data within this page */
 	unsigned int size;	/* number of data bytes within this page */
-#else
-#if PAGE_SIZE > (1U<<16)
-#error "won't work."
-#endif
-	unsigned short offset;	/* start offset of data within this page */
-	unsigned short size;	/* number of data bytes within this page */
-#endif
 };
 
 static inline void dummy_for_buildbug(void)
@@ -335,19 +328,19 @@
 	(((struct drbd_page_chain*)&(page)->lru)->size = (v))
 #define set_page_chain_offset(page, v) \
 	(((struct drbd_page_chain*)&(page)->lru)->offset = (v))
! manual: again no GCC type initalizer in set_page_chain_next_offset_size
-#define set_page_chain_next_offset_size(page, n, o, s)	\
-	*((struct drbd_page_chain*)&(page)->lru) =	\
-	((struct drbd_page_chain) {			\
-		.next = (n),				\
-		.offset = (o),				\
-		.size = (s),				\
-	 })
+#define set_page_chain_next_offset_size(page, n, o, s)  \
+    do {                                                \
+	struct drbd_page_chain *__dpc =                 \
+		(struct drbd_page_chain*)(&(page)->lru);\
+	__dpc->next = (n);                              \
+	__dpc->offset = (o);                            \
+	__dpc->size = (s);                              \
+    } while (0)
 
 #define page_chain_for_each(page) \
! manual: no ({ support outside gcc
-	for (; page && ({ prefetch(page_chain_next(page)); 1; }); \
-			page = page_chain_next(page))
+	for (; page; page = page_chain_next(page))
 #define page_chain_for_each_safe(page, n) \
! manual: no ({ support outside gcc
-	for (; page && ({ n = page_chain_next(page); 1; }); page = n)
+	for (; page && ( n = page_chain_next(page), 1 ); page = n)
 
 #ifndef SK_CAN_REUSE
 /* This constant was introduced by Pavel Emelyanov <xemul@parallels.com> on
